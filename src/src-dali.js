/*! For license information please see vendor.js.LICENSE.txt */
"use strict";
(self.webpackChunk_dala_website = self.webpackChunk_dala_website || []).push([[941], {
    1389: function(t, e, n) {
        n.d(e, {
            Z: function() {
                return d
            }
        });
        var r = n(8439);
        const i = {}
          , s = {}
          , a = ["mouseenter", "mouseleave", "pointerenter", "pointerleave"];
        function o(t) {
            void 0 === s[t] && (s[t] = [])
        }
        function l(t) {
            return "string" == typeof t ? document.querySelectorAll(t) : t
        }
        function c(t) {
            let e = function(t, e) {
                const n = [];
                let r = e;
                do {
                    if (1 !== r.nodeType)
                        break;
                    const e = t.matches(r);
                    e.length && n.push({
                        delegatedTarget: r,
                        stack: e
                    })
                } while (r = r.parentElement);
                return n
            }(i[t.type], t.target);
            if (e.length)
                for (let n = 0; n < e.length; n++)
                    for (let r = 0; r < e[n].stack.length; r++)
                        -1 !== a.indexOf(t.type) ? (u(t, e[n].delegatedTarget),
                        t.target === e[n].delegatedTarget && e[n].stack[r].data(t)) : (u(t, e[n].delegatedTarget),
                        e[n].stack[r].data(t))
        }
        function u(t, e) {
            Object.defineProperty(t, "currentTarget", {
                configurable: !0,
                enumerable: !0,
                get: ()=>e
            })
        }
        function h(t) {
            return JSON.parse(JSON.stringify(t))
        }
        class d {
            bindAll(t, e) {
                void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t)));
                for (let n = 0; n < e.length; n++)
                    t[e[n]] = t[e[n]].bind(t)
            }
            on(t, e, n, r) {
                const i = t.split(" ");
                for (let t = 0; t < i.length; t++)
                    if ("function" != typeof e || void 0 !== n)
                        if (e.nodeType && 1 === e.nodeType || e === window || e === document)
                            e.addEventListener(i[t], n, r);
                        else {
                            e = l(e);
                            for (let s = 0; s < e.length; s++)
                                e[s].addEventListener(i[t], n, r)
                        }
                    else
                        o(i[t]),
                        s[i[t]].push(e)
            }
            delegate(t, e, n) {
                const s = t.split(" ");
                for (let t = 0; t < s.length; t++) {
                    let o = i[s[t]];
                    void 0 === o && (o = new r.Z,
                    i[s[t]] = o,
                    -1 !== a.indexOf(s[t]) ? document.addEventListener(s[t], c, !0) : document.addEventListener(s[t], c)),
                    o.add(e, n)
                }
            }
            off(t, e, n, r) {
                const u = t.split(" ");
                for (let t = 0; t < u.length; t++) {
                    if (void 0 === e) {
                        s[u[t]] = [];
                        continue
                    }
                    if ("function" == typeof e) {
                        o(u[t]);
                        for (let n = 0; n < s[u[t]].length; n++)
                            s[u[t]][n] === e && s[u[t]].splice(n, 1);
                        continue
                    }
                    const h = i[u[t]];
                    if (void 0 === h || (h.remove(e, n),
                    0 !== h.size))
                        if (void 0 === e.removeEventListener) {
                            e = l(e);
                            for (let i = 0; i < e.length; i++)
                                e[i].removeEventListener(u[t], n, r)
                        } else
                            e.removeEventListener(u[t], n, r);
                    else
                        delete i[u[t]],
                        -1 !== a.indexOf(u[t]) ? document.removeEventListener(u[t], c, !0) : document.removeEventListener(u[t], c)
                }
            }
            emit(t, ...e) {
                !function(t, e) {
                    if (s[t])
                        for (let n = 0; n < s[t].length; n++)
                            s[t][n](...e)
                }(t, e)
            }
            debugDelegated() {
                return h(i)
            }
            debugBus() {
                return h(s)
            }
        }
    },
    9975: function(t, e, n) {
        n.d(e, {
            ZP: function() {
                return Tt
            },
            _Z: function() {
                return Tt
            }
        });
        var r, i, s, a, o, l, c, u, h = n(5317), d = {}, f = 180 / Math.PI, p = Math.PI / 180, m = Math.atan2, g = /([A-Z])/g, v = /(left|right|width|margin|padding|x)/i, _ = /[\s,\(]\S/, y = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, x = function(t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }, b = function(t, e) {
            return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }, w = function(t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        }, M = function(t, e) {
            var n = e.s + e.c * t;
            e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
        }, T = function(t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        }, S = function(t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        }, E = function(t, e, n) {
            return t.style[e] = n
        }, A = function(t, e, n) {
            return t.style.setProperty(e, n)
        }, R = function(t, e, n) {
            return t._gsap[e] = n
        }, L = function(t, e, n) {
            return t._gsap.scaleX = t._gsap.scaleY = n
        }, P = function(t, e, n, r, i) {
            var s = t._gsap;
            s.scaleX = s.scaleY = n,
            s.renderTransform(i, s)
        }, C = function(t, e, n, r, i) {
            var s = t._gsap;
            s[e] = n,
            s.renderTransform(i, s)
        }, D = "transform", I = D + "Origin", N = function(t, e) {
            var n = this
              , r = this.target
              , i = r.style;
            if (t in d) {
                if (this.tfm = this.tfm || {},
                "transform" !== t && (~(t = y[t] || t).indexOf(",") ? t.split(",").forEach((function(t) {
                    return n.tfm[t] = Q(r, t)
                }
                )) : this.tfm[t] = r._gsap.x ? r._gsap[t] : Q(r, t)),
                this.props.indexOf(D) >= 0)
                    return;
                r._gsap.svg && (this.svgo = r.getAttribute("data-svg-origin"),
                this.props.push(I, e, "")),
                t = D
            }
            (i || e) && this.props.push(t, e, i[t])
        }, F = function(t) {
            t.translate && (t.removeProperty("translate"),
            t.removeProperty("scale"),
            t.removeProperty("rotate"))
        }, O = function() {
            var t, e, n = this.props, r = this.target, i = r.style, s = r._gsap;
            for (t = 0; t < n.length; t += 3)
                n[t + 1] ? r[n[t]] = n[t + 2] : n[t + 2] ? i[n[t]] = n[t + 2] : i.removeProperty(n[t].replace(g, "-$1").toLowerCase());
            if (this.tfm) {
                for (e in this.tfm)
                    s[e] = this.tfm[e];
                s.svg && (s.renderTransform(),
                r.setAttribute("data-svg-origin", this.svgo || "")),
                !(t = c()) || t.isStart || i[D] || (F(i),
                s.uncache = 1)
            }
        }, U = function(t, e) {
            var n = {
                target: t,
                props: [],
                revert: O,
                save: N
            };
            return e && e.split(",").forEach((function(t) {
                return n.save(t)
            }
            )),
            n
        }, z = function(t, e) {
            var n = i.createElementNS ? i.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : i.createElement(t);
            return n.style ? n : i.createElement(t)
        }, B = function t(e, n, r) {
            var i = getComputedStyle(e);
            return i[n] || i.getPropertyValue(n.replace(g, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, G(n) || n, 1) || ""
        }, k = "O,Moz,ms,Ms,Webkit".split(","), G = function(t, e, n) {
            var r = (e || o).style
              , i = 5;
            if (t in r && !n)
                return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(k[i] + t in r); )
                ;
            return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? k[i] : "") + t
        }, H = function() {
            "undefined" != typeof window && window.document && (r = window,
            i = r.document,
            s = i.documentElement,
            o = z("div") || {
                style: {}
            },
            z("div"),
            D = G(D),
            I = D + "Origin",
            o.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
            u = !!G("perspective"),
            c = h.p8.core.reverting,
            a = 1)
        }, V = function t(e) {
            var n, r = z("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, a = this.nextSibling, o = this.style.cssText;
            if (s.appendChild(r),
            r.appendChild(this),
            this.style.display = "block",
            e)
                try {
                    n = this.getBBox(),
                    this._gsapBBox = this.getBBox,
                    this.getBBox = t
                } catch (t) {}
            else
                this._gsapBBox && (n = this._gsapBBox());
            return i && (a ? i.insertBefore(this, a) : i.appendChild(this)),
            s.removeChild(r),
            this.style.cssText = o,
            n
        }, W = function(t, e) {
            for (var n = e.length; n--; )
                if (t.hasAttribute(e[n]))
                    return t.getAttribute(e[n])
        }, X = function(t) {
            var e;
            try {
                e = t.getBBox()
            } catch (n) {
                e = V.call(t, !0)
            }
            return e && (e.width || e.height) || t.getBBox === V || (e = V.call(t, !0)),
            !e || e.width || e.x || e.y ? e : {
                x: +W(t, ["x", "cx", "x1"]) || 0,
                y: +W(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        }, j = function(t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !X(t))
        }, Y = function(t, e) {
            if (e) {
                var n = t.style;
                e in d && e !== I && (e = D),
                n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
                n.removeProperty(e.replace(g, "-$1").toLowerCase())) : n.removeAttribute(e)
            }
        }, q = function(t, e, n, r, i, s) {
            var a = new h.Fo(t._pt,e,n,0,1,s ? S : T);
            return t._pt = a,
            a.b = r,
            a.e = i,
            t._props.push(n),
            a
        }, Z = {
            deg: 1,
            rad: 1,
            turn: 1
        }, K = {
            grid: 1,
            flex: 1
        }, J = function t(e, n, r, s) {
            var a, l, c, u, f = parseFloat(r) || 0, p = (r + "").trim().substr((f + "").length) || "px", m = o.style, g = v.test(n), _ = "svg" === e.tagName.toLowerCase(), y = (_ ? "client" : "offset") + (g ? "Width" : "Height"), x = 100, b = "px" === s, w = "%" === s;
            return s === p || !f || Z[s] || Z[p] ? f : ("px" !== p && !b && (f = t(e, n, r, "px")),
            u = e.getCTM && j(e),
            !w && "%" !== p || !d[n] && !~n.indexOf("adius") ? (m[g ? "width" : "height"] = x + (b ? p : s),
            l = ~n.indexOf("adius") || "em" === s && e.appendChild && !_ ? e : e.parentNode,
            u && (l = (e.ownerSVGElement || {}).parentNode),
            l && l !== i && l.appendChild || (l = i.body),
            (c = l._gsap) && w && c.width && g && c.time === h.xr.time && !c.uncache ? (0,
            h.Pr)(f / c.width * x) : ((w || "%" === p) && !K[B(l, "display")] && (m.position = B(e, "position")),
            l === e && (m.position = "static"),
            l.appendChild(o),
            a = o[y],
            l.removeChild(o),
            m.position = "absolute",
            g && w && ((c = (0,
            h.DY)(l)).time = h.xr.time,
            c.width = l[y]),
            (0,
            h.Pr)(b ? a * f / x : a && f ? x / a * f : 0))) : (a = u ? e.getBBox()[g ? "width" : "height"] : e[y],
            (0,
            h.Pr)(w ? f / a * x : f / 100 * a)))
        }, Q = function(t, e, n, r) {
            var i;
            return a || H(),
            e in y && "transform" !== e && ~(e = y[e]).indexOf(",") && (e = e.split(",")[0]),
            d[e] && "transform" !== e ? (i = ct(t, r),
            i = "transformOrigin" !== e ? i[e] : i.svg ? i.origin : ut(B(t, I)) + " " + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = nt[e] && nt[e](t, e, n) || B(t, e) || (0,
            h.Ok)(t, e) || ("opacity" === e ? 1 : 0)),
            n && !~(i + "").trim().indexOf(" ") ? J(t, e, i, n) + n : i
        }, $ = function(t, e, n, r) {
            if (!n || "none" === n) {
                var i = G(e, t, 1)
                  , s = i && B(t, i, 1);
                s && s !== n ? (e = i,
                n = s) : "borderColor" === e && (n = B(t, "borderTopColor"))
            }
            var a, o, l, c, u, d, f, p, m, g, v, _ = new h.Fo(this._pt,t.style,e,0,1,h.Ks), y = 0, x = 0;
            if (_.b = n,
            _.e = r,
            n += "",
            "auto" === (r += "") && (t.style[e] = r,
            r = B(t, e) || r,
            t.style[e] = n),
            a = [n, r],
            (0,
            h.kr)(a),
            r = a[1],
            l = (n = a[0]).match(h.d4) || [],
            (r.match(h.d4) || []).length) {
                for (; o = h.d4.exec(r); )
                    f = o[0],
                    m = r.substring(y, o.index),
                    u ? u = (u + 1) % 5 : "rgba(" !== m.substr(-5) && "hsla(" !== m.substr(-5) || (u = 1),
                    f !== (d = l[x++] || "") && (c = parseFloat(d) || 0,
                    v = d.substr((c + "").length),
                    "=" === f.charAt(1) && (f = (0,
                    h.cy)(c, f) + v),
                    p = parseFloat(f),
                    g = f.substr((p + "").length),
                    y = h.d4.lastIndex - g.length,
                    g || (g = g || h.Fc.units[e] || v,
                    y === r.length && (r += g,
                    _.e += g)),
                    v !== g && (c = J(t, e, d, g) || 0),
                    _._pt = {
                        _next: _._pt,
                        p: m || 1 === x ? m : ",",
                        s: c,
                        c: p - c,
                        m: u && u < 4 || "zIndex" === e ? Math.round : 0
                    });
                _.c = y < r.length ? r.substring(y, r.length) : ""
            } else
                _.r = "display" === e && "none" === r ? S : T;
            return h.bQ.test(r) && (_.e = 0),
            this._pt = _,
            _
        }, tt = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, et = function(t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                var n, r, i, s = e.t, a = s.style, o = e.u, l = s._gsap;
                if ("all" === o || !0 === o)
                    a.cssText = "",
                    r = 1;
                else
                    for (i = (o = o.split(",")).length; --i > -1; )
                        n = o[i],
                        d[n] && (r = 1,
                        n = "transformOrigin" === n ? I : D),
                        Y(s, n);
                r && (Y(s, D),
                l && (l.svg && s.removeAttribute("transform"),
                ct(s, 1),
                l.uncache = 1,
                F(a)))
            }
        }, nt = {
            clearProps: function(t, e, n, r, i) {
                if ("isFromStart" !== i.data) {
                    var s = t._pt = new h.Fo(t._pt,e,n,0,0,et);
                    return s.u = r,
                    s.pr = -10,
                    s.tween = i,
                    t._props.push(n),
                    1
                }
            }
        }, rt = [1, 0, 0, 1, 0, 0], it = {}, st = function(t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
        }, at = function(t) {
            var e = B(t, D);
            return st(e) ? rt : e.substr(7).match(h.SI).map(h.Pr)
        }, ot = function(t, e) {
            var n, r, i, a, o = t._gsap || (0,
            h.DY)(t), l = t.style, c = at(t);
            return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (c = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? rt : c : (c !== rt || t.offsetParent || t === s || o.svg || (i = l.display,
            l.display = "block",
            (n = t.parentNode) && t.offsetParent || (a = 1,
            r = t.nextElementSibling,
            s.appendChild(t)),
            c = at(t),
            i ? l.display = i : Y(t, "display"),
            a && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : s.removeChild(t))),
            e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c)
        }, lt = function(t, e, n, r, i, s) {
            var a, o, l, c = t._gsap, u = i || ot(t, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, f = c.xOffset || 0, p = c.yOffset || 0, m = u[0], g = u[1], v = u[2], _ = u[3], y = u[4], x = u[5], b = e.split(" "), w = parseFloat(b[0]) || 0, M = parseFloat(b[1]) || 0;
            n ? u !== rt && (o = m * _ - g * v) && (l = w * (-g / o) + M * (m / o) - (m * x - g * y) / o,
            w = w * (_ / o) + M * (-v / o) + (v * x - _ * y) / o,
            M = l) : (w = (a = X(t)).x + (~b[0].indexOf("%") ? w / 100 * a.width : w),
            M = a.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * a.height : M)),
            r || !1 !== r && c.smooth ? (y = w - h,
            x = M - d,
            c.xOffset = f + (y * m + x * v) - y,
            c.yOffset = p + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0,
            c.xOrigin = w,
            c.yOrigin = M,
            c.smooth = !!r,
            c.origin = e,
            c.originIsAbsolute = !!n,
            t.style[I] = "0px 0px",
            s && (q(s, c, "xOrigin", h, w),
            q(s, c, "yOrigin", d, M),
            q(s, c, "xOffset", f, c.xOffset),
            q(s, c, "yOffset", p, c.yOffset)),
            t.setAttribute("data-svg-origin", w + " " + M)
        }, ct = function(t, e) {
            var n = t._gsap || new h.l1(t);
            if ("x"in n && !e && !n.uncache)
                return n;
            var r, i, s, a, o, l, c, d, g, v, _, y, x, b, w, M, T, S, E, A, R, L, P, C, N, F, O, U, z, k, G, H, V = t.style, W = n.scaleX < 0, X = "px", Y = "deg", q = getComputedStyle(t), Z = B(t, I) || "0";
            return r = i = s = l = c = d = g = v = _ = 0,
            a = o = 1,
            n.svg = !(!t.getCTM || !j(t)),
            q.translate && ("none" === q.translate && "none" === q.scale && "none" === q.rotate || (V[D] = ("none" !== q.translate ? "translate3d(" + (q.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== q.rotate ? "rotate(" + q.rotate + ") " : "") + ("none" !== q.scale ? "scale(" + q.scale.split(" ").join(",") + ") " : "") + ("none" !== q[D] ? q[D] : "")),
            V.scale = V.rotate = V.translate = "none"),
            b = ot(t, n.svg),
            n.svg && (n.uncache ? (N = t.getBBox(),
            Z = n.xOrigin - N.x + "px " + (n.yOrigin - N.y) + "px",
            C = "") : C = !e && t.getAttribute("data-svg-origin"),
            lt(t, C || Z, !!C || n.originIsAbsolute, !1 !== n.smooth, b)),
            y = n.xOrigin || 0,
            x = n.yOrigin || 0,
            b !== rt && (S = b[0],
            E = b[1],
            A = b[2],
            R = b[3],
            r = L = b[4],
            i = P = b[5],
            6 === b.length ? (a = Math.sqrt(S * S + E * E),
            o = Math.sqrt(R * R + A * A),
            l = S || E ? m(E, S) * f : 0,
            (g = A || R ? m(A, R) * f + l : 0) && (o *= Math.abs(Math.cos(g * p))),
            n.svg && (r -= y - (y * S + x * A),
            i -= x - (y * E + x * R))) : (H = b[6],
            k = b[7],
            O = b[8],
            U = b[9],
            z = b[10],
            G = b[11],
            r = b[12],
            i = b[13],
            s = b[14],
            c = (w = m(H, z)) * f,
            w && (C = L * (M = Math.cos(-w)) + O * (T = Math.sin(-w)),
            N = P * M + U * T,
            F = H * M + z * T,
            O = L * -T + O * M,
            U = P * -T + U * M,
            z = H * -T + z * M,
            G = k * -T + G * M,
            L = C,
            P = N,
            H = F),
            d = (w = m(-A, z)) * f,
            w && (M = Math.cos(-w),
            G = R * (T = Math.sin(-w)) + G * M,
            S = C = S * M - O * T,
            E = N = E * M - U * T,
            A = F = A * M - z * T),
            l = (w = m(E, S)) * f,
            w && (C = S * (M = Math.cos(w)) + E * (T = Math.sin(w)),
            N = L * M + P * T,
            E = E * M - S * T,
            P = P * M - L * T,
            S = C,
            L = N),
            c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
            d = 180 - d),
            a = (0,
            h.Pr)(Math.sqrt(S * S + E * E + A * A)),
            o = (0,
            h.Pr)(Math.sqrt(P * P + H * H)),
            w = m(L, P),
            g = Math.abs(w) > 2e-4 ? w * f : 0,
            _ = G ? 1 / (G < 0 ? -G : G) : 0),
            n.svg && (C = t.getAttribute("transform"),
            n.forceCSS = t.setAttribute("transform", "") || !st(B(t, D)),
            C && t.setAttribute("transform", C))),
            Math.abs(g) > 90 && Math.abs(g) < 270 && (W ? (a *= -1,
            g += l <= 0 ? 180 : -180,
            l += l <= 0 ? 180 : -180) : (o *= -1,
            g += g <= 0 ? 180 : -180)),
            e = e || n.uncache,
            n.x = r - ((n.xPercent = r && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + X,
            n.y = i - ((n.yPercent = i && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + X,
            n.z = s + X,
            n.scaleX = (0,
            h.Pr)(a),
            n.scaleY = (0,
            h.Pr)(o),
            n.rotation = (0,
            h.Pr)(l) + Y,
            n.rotationX = (0,
            h.Pr)(c) + Y,
            n.rotationY = (0,
            h.Pr)(d) + Y,
            n.skewX = g + Y,
            n.skewY = v + Y,
            n.transformPerspective = _ + X,
            (n.zOrigin = parseFloat(Z.split(" ")[2]) || 0) && (V[I] = ut(Z)),
            n.xOffset = n.yOffset = 0,
            n.force3D = h.Fc.force3D,
            n.renderTransform = n.svg ? vt : u ? gt : dt,
            n.uncache = 0,
            n
        }, ut = function(t) {
            return (t = t.split(" "))[0] + " " + t[1]
        }, ht = function(t, e, n) {
            var r = (0,
            h.Wy)(e);
            return (0,
            h.Pr)(parseFloat(e) + parseFloat(J(t, "x", n + "px", r))) + r
        }, dt = function(t, e) {
            e.z = "0px",
            e.rotationY = e.rotationX = "0deg",
            e.force3D = 0,
            gt(t, e)
        }, ft = "0deg", pt = "0px", mt = ") ", gt = function(t, e) {
            var n = e || this
              , r = n.xPercent
              , i = n.yPercent
              , s = n.x
              , a = n.y
              , o = n.z
              , l = n.rotation
              , c = n.rotationY
              , u = n.rotationX
              , h = n.skewX
              , d = n.skewY
              , f = n.scaleX
              , m = n.scaleY
              , g = n.transformPerspective
              , v = n.force3D
              , _ = n.target
              , y = n.zOrigin
              , x = ""
              , b = "auto" === v && t && 1 !== t || !0 === v;
            if (y && (u !== ft || c !== ft)) {
                var w, M = parseFloat(c) * p, T = Math.sin(M), S = Math.cos(M);
                M = parseFloat(u) * p,
                w = Math.cos(M),
                s = ht(_, s, T * w * -y),
                a = ht(_, a, -Math.sin(M) * -y),
                o = ht(_, o, S * w * -y + y)
            }
            g !== pt && (x += "perspective(" + g + mt),
            (r || i) && (x += "translate(" + r + "%, " + i + "%) "),
            (b || s !== pt || a !== pt || o !== pt) && (x += o !== pt || b ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + mt),
            l !== ft && (x += "rotate(" + l + mt),
            c !== ft && (x += "rotateY(" + c + mt),
            u !== ft && (x += "rotateX(" + u + mt),
            h === ft && d === ft || (x += "skew(" + h + ", " + d + mt),
            1 === f && 1 === m || (x += "scale(" + f + ", " + m + mt),
            _.style[D] = x || "translate(0, 0)"
        }, vt = function(t, e) {
            var n, r, i, s, a, o = e || this, l = o.xPercent, c = o.yPercent, u = o.x, d = o.y, f = o.rotation, m = o.skewX, g = o.skewY, v = o.scaleX, _ = o.scaleY, y = o.target, x = o.xOrigin, b = o.yOrigin, w = o.xOffset, M = o.yOffset, T = o.forceCSS, S = parseFloat(u), E = parseFloat(d);
            f = parseFloat(f),
            m = parseFloat(m),
            (g = parseFloat(g)) && (m += g = parseFloat(g),
            f += g),
            f || m ? (f *= p,
            m *= p,
            n = Math.cos(f) * v,
            r = Math.sin(f) * v,
            i = Math.sin(f - m) * -_,
            s = Math.cos(f - m) * _,
            m && (g *= p,
            a = Math.tan(m - g),
            i *= a = Math.sqrt(1 + a * a),
            s *= a,
            g && (a = Math.tan(g),
            n *= a = Math.sqrt(1 + a * a),
            r *= a)),
            n = (0,
            h.Pr)(n),
            r = (0,
            h.Pr)(r),
            i = (0,
            h.Pr)(i),
            s = (0,
            h.Pr)(s)) : (n = v,
            s = _,
            r = i = 0),
            (S && !~(u + "").indexOf("px") || E && !~(d + "").indexOf("px")) && (S = J(y, "x", u, "px"),
            E = J(y, "y", d, "px")),
            (x || b || w || M) && (S = (0,
            h.Pr)(S + x - (x * n + b * i) + w),
            E = (0,
            h.Pr)(E + b - (x * r + b * s) + M)),
            (l || c) && (a = y.getBBox(),
            S = (0,
            h.Pr)(S + l / 100 * a.width),
            E = (0,
            h.Pr)(E + c / 100 * a.height)),
            a = "matrix(" + n + "," + r + "," + i + "," + s + "," + S + "," + E + ")",
            y.setAttribute("transform", a),
            T && (y.style[D] = a)
        }, _t = function(t, e, n, r, i) {
            var s, a, o = 360, l = (0,
            h.r9)(i), c = parseFloat(i) * (l && ~i.indexOf("rad") ? f : 1) - r, u = r + c + "deg";
            return l && ("short" === (s = i.split("_")[1]) && (c %= o) !== c % 180 && (c += c < 0 ? o : -360),
            "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)),
            t._pt = a = new h.Fo(t._pt,e,n,r,c,b),
            a.e = u,
            a.u = "deg",
            t._props.push(n),
            a
        }, yt = function(t, e) {
            for (var n in e)
                t[n] = e[n];
            return t
        }, xt = function(t, e, n) {
            var r, i, s, a, o, l, c, u = yt({}, n._gsap), f = n.style;
            for (i in u.svg ? (s = n.getAttribute("transform"),
            n.setAttribute("transform", ""),
            f[D] = e,
            r = ct(n, 1),
            Y(n, D),
            n.setAttribute("transform", s)) : (s = getComputedStyle(n)[D],
            f[D] = e,
            r = ct(n, 1),
            f[D] = s),
            d)
                (s = u[i]) !== (a = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (o = (0,
                h.Wy)(s) !== (c = (0,
                h.Wy)(a)) ? J(n, i, s, c) : parseFloat(s),
                l = parseFloat(a),
                t._pt = new h.Fo(t._pt,r,i,o,l - o,x),
                t._pt.u = c || 0,
                t._props.push(i));
            yt(r, u)
        };
        (0,
        h.fS)("padding,margin,Width,Radius", (function(t, e) {
            var n = "Top"
              , r = "Right"
              , i = "Bottom"
              , s = "Left"
              , a = (e < 3 ? [n, r, i, s] : [n + s, n + r, i + r, i + s]).map((function(n) {
                return e < 2 ? t + n : "border" + n + t
            }
            ));
            nt[e > 1 ? "border" + t : t] = function(t, e, n, r, i) {
                var s, o;
                if (arguments.length < 4)
                    return s = a.map((function(e) {
                        return Q(t, e, n)
                    }
                    )),
                    5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
                s = (r + "").split(" "),
                o = {},
                a.forEach((function(t, e) {
                    return o[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                }
                )),
                t.init(e, o, i)
            }
        }
        ));
        var bt, wt, Mt, Tt = {
            name: "css",
            register: H,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, n, r, i) {
                var s, o, l, c, u, f, p, m, g, v, b, T, S, E, A, R, L, P, C, N, F = this._props, O = t.style, z = n.vars.startAt;
                for (p in a || H(),
                this.styles = this.styles || U(t),
                R = this.styles.props,
                this.tween = n,
                e)
                    if ("autoRound" !== p && (o = e[p],
                    !h.$i[p] || !(0,
                    h.if)(p, e, n, r, t, i)))
                        if (u = typeof o,
                        f = nt[p],
                        "function" === u && (u = typeof (o = o.call(n, r, t, i))),
                        "string" === u && ~o.indexOf("random(") && (o = (0,
                        h.UI)(o)),
                        f)
                            f(this, t, p, o, n) && (A = 1);
                        else if ("--" === p.substr(0, 2))
                            s = (getComputedStyle(t).getPropertyValue(p) + "").trim(),
                            o += "",
                            h.GN.lastIndex = 0,
                            h.GN.test(s) || (m = (0,
                            h.Wy)(s),
                            g = (0,
                            h.Wy)(o)),
                            g ? m !== g && (s = J(t, p, s, g) + g) : m && (o += m),
                            this.add(O, "setProperty", s, o, r, i, 0, 0, p),
                            F.push(p),
                            R.push(p, 0, O[p]);
                        else if ("undefined" !== u) {
                            if (z && p in z ? (s = "function" == typeof z[p] ? z[p].call(n, r, t, i) : z[p],
                            (0,
                            h.r9)(s) && ~s.indexOf("random(") && (s = (0,
                            h.UI)(s)),
                            (0,
                            h.Wy)(s + "") || (s += h.Fc.units[p] || (0,
                            h.Wy)(Q(t, p)) || ""),
                            "=" === (s + "").charAt(1) && (s = Q(t, p))) : s = Q(t, p),
                            c = parseFloat(s),
                            (v = "string" === u && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)),
                            l = parseFloat(o),
                            p in y && ("autoAlpha" === p && (1 === c && "hidden" === Q(t, "visibility") && l && (c = 0),
                            R.push("visibility", 0, O.visibility),
                            q(this, O, "visibility", c ? "inherit" : "hidden", l ? "inherit" : "hidden", !l)),
                            "scale" !== p && "transform" !== p && ~(p = y[p]).indexOf(",") && (p = p.split(",")[0])),
                            b = p in d)
                                if (this.styles.save(p),
                                T || ((S = t._gsap).renderTransform && !e.parseTransform || ct(t, e.parseTransform),
                                E = !1 !== e.smoothOrigin && S.smooth,
                                (T = this._pt = new h.Fo(this._pt,O,D,0,1,S.renderTransform,S,0,-1)).dep = 1),
                                "scale" === p)
                                    this._pt = new h.Fo(this._pt,S,"scaleY",S.scaleY,(v ? (0,
                                    h.cy)(S.scaleY, v + l) : l) - S.scaleY || 0,x),
                                    this._pt.u = 0,
                                    F.push("scaleY", p),
                                    p += "X";
                                else {
                                    if ("transformOrigin" === p) {
                                        R.push(I, 0, O[I]),
                                        P = void 0,
                                        C = void 0,
                                        N = void 0,
                                        P = (L = o).split(" "),
                                        C = P[0],
                                        N = P[1] || "50%",
                                        "top" !== C && "bottom" !== C && "left" !== N && "right" !== N || (L = C,
                                        C = N,
                                        N = L),
                                        P[0] = tt[C] || C,
                                        P[1] = tt[N] || N,
                                        o = P.join(" "),
                                        S.svg ? lt(t, o, 0, E, 0, this) : ((g = parseFloat(o.split(" ")[2]) || 0) !== S.zOrigin && q(this, S, "zOrigin", S.zOrigin, g),
                                        q(this, O, p, ut(s), ut(o)));
                                        continue
                                    }
                                    if ("svgOrigin" === p) {
                                        lt(t, o, 1, E, 0, this);
                                        continue
                                    }
                                    if (p in it) {
                                        _t(this, S, p, c, v ? (0,
                                        h.cy)(c, v + o) : o);
                                        continue
                                    }
                                    if ("smoothOrigin" === p) {
                                        q(this, S, "smooth", S.smooth, o);
                                        continue
                                    }
                                    if ("force3D" === p) {
                                        S[p] = o;
                                        continue
                                    }
                                    if ("transform" === p) {
                                        xt(this, o, t);
                                        continue
                                    }
                                }
                            else
                                p in O || (p = G(p) || p);
                            if (b || (l || 0 === l) && (c || 0 === c) && !_.test(o) && p in O)
                                l || (l = 0),
                                (m = (s + "").substr((c + "").length)) !== (g = (0,
                                h.Wy)(o) || (p in h.Fc.units ? h.Fc.units[p] : m)) && (c = J(t, p, s, g)),
                                this._pt = new h.Fo(this._pt,b ? S : O,p,c,(v ? (0,
                                h.cy)(c, v + l) : l) - c,b || "px" !== g && "zIndex" !== p || !1 === e.autoRound ? x : M),
                                this._pt.u = g || 0,
                                m !== g && "%" !== g && (this._pt.b = s,
                                this._pt.r = w);
                            else if (p in O)
                                $.call(this, t, p, s, v ? v + o : o);
                            else if (p in t)
                                this.add(t, p, s || t[p], v ? v + o : o, r, i);
                            else if ("parseTransform" !== p) {
                                (0,
                                h.lC)(p, o);
                                continue
                            }
                            b || (p in O ? R.push(p, 0, O[p]) : R.push(p, 1, s || t[p])),
                            F.push(p)
                        }
                A && (0,
                h.JV)(this)
            },
            render: function(t, e) {
                if (e.tween._time || !c())
                    for (var n = e._pt; n; )
                        n.r(t, n.d),
                        n = n._next;
                else
                    e.styles.revert()
            },
            get: Q,
            aliases: y,
            getSetter: function(t, e, n) {
                var r = y[e];
                return r && r.indexOf(",") < 0 && (e = r),
                e in d && e !== I && (t._gsap.x || Q(t, "x")) ? n && l === n ? "scale" === e ? L : R : (l = n || {}) && ("scale" === e ? P : C) : t.style && !(0,
                h.m2)(t.style[e]) ? E : ~e.indexOf("-") ? A : (0,
                h.S5)(t, e)
            },
            core: {
                _removeProperty: Y,
                _getMatrix: ot
            }
        };
        h.p8.utils.checkPrefix = G,
        h.p8.core.getStyleSaver = U,
        bt = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
        wt = "rotation,rotationX,rotationY,skewX,skewY",
        Mt = (0,
        h.fS)(bt + "," + wt + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
            d[t] = 1
        }
        )),
        (0,
        h.fS)(wt, (function(t) {
            h.Fc.units[t] = "deg",
            it[t] = 1
        }
        )),
        y[Mt[13]] = bt + "," + wt,
        (0,
        h.fS)("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
            var e = t.split(":");
            y[e[1]] = Mt[e[0]]
        }
        )),
        (0,
        h.fS)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
            h.Fc.units[t] = "px"
        }
        )),
        h.p8.registerPlugin(Tt)
    },
    9805: function(t, e, n) {
        function r(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1,
                r.configurable = !0,
                "value"in r && (r.writable = !0),
                Object.defineProperty(t, r.key, r)
            }
        }
        n.d(e, {
            Z: function() {
                return Ke
            }
        });
        var i, s, a, o, l, c, u, h, d, f, p, m, g, v = function() {
            return i || "undefined" != typeof window && (i = window.gsap) && i.registerPlugin && i
        }, _ = 1, y = [], x = [], b = [], w = Date.now, M = function(t, e) {
            return e
        }, T = function(t, e) {
            return ~b.indexOf(t) && b[b.indexOf(t) + 1][e]
        }, S = function(t) {
            return !!~f.indexOf(t)
        }, E = function(t, e, n, r, i) {
            return t.addEventListener(e, n, {
                passive: !r,
                capture: !!i
            })
        }, A = function(t, e, n, r) {
            return t.removeEventListener(e, n, !!r)
        }, R = "scrollLeft", L = "scrollTop", P = function() {
            return p && p.isPressed || x.cache++
        }, C = function(t, e) {
            var n = function n(r) {
                if (r || 0 === r) {
                    _ && (a.history.scrollRestoration = "manual");
                    var i = p && p.isPressed;
                    r = n.v = Math.round(r) || (p && p.iOS ? 1 : 0),
                    t(r),
                    n.cacheID = x.cache,
                    i && M("ss", r)
                } else
                    (e || x.cache !== n.cacheID || M("ref")) && (n.cacheID = x.cache,
                    n.v = t());
                return n.v + n.offset
            };
            return n.offset = 0,
            t && n
        }, D = {
            s: R,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: C((function(t) {
                return arguments.length ? a.scrollTo(t, I.sc()) : a.pageXOffset || o[R] || l[R] || c[R] || 0
            }
            ))
        }, I = {
            s: L,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: D,
            sc: C((function(t) {
                return arguments.length ? a.scrollTo(D.sc(), t) : a.pageYOffset || o[L] || l[L] || c[L] || 0
            }
            ))
        }, N = function(t) {
            return i.utils.toArray(t)[0] || ("string" == typeof t && !1 !== i.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
        }, F = function(t, e) {
            var n = e.s
              , r = e.sc;
            S(t) && (t = o.scrollingElement || l);
            var s = x.indexOf(t)
              , a = r === I.sc ? 1 : 2;
            !~s && (s = x.push(t) - 1),
            x[s + a] || t.addEventListener("scroll", P);
            var c = x[s + a]
              , u = c || (x[s + a] = C(T(t, n), !0) || (S(t) ? r : C((function(e) {
                return arguments.length ? t[n] = e : t[n]
            }
            ))));
            return u.target = t,
            c || (u.smooth = "smooth" === i.getProperty(t, "scrollBehavior")),
            u
        }, O = function(t, e, n) {
            var r = t
              , i = t
              , s = w()
              , a = s
              , o = e || 50
              , l = Math.max(500, 3 * o)
              , c = function(t, e) {
                var l = w();
                e || l - s > o ? (i = r,
                r = t,
                a = s,
                s = l) : n ? r += t : r = i + (t - i) / (l - a) * (s - a)
            };
            return {
                update: c,
                reset: function() {
                    i = r = n ? 0 : r,
                    a = s = 0
                },
                getVelocity: function(t) {
                    var e = a
                      , o = i
                      , u = w();
                    return (t || 0 === t) && t !== r && c(t),
                    s === a || u - a > l ? 0 : (r + (n ? o : -o)) / ((n ? u : s) - e) * 1e3
                }
            }
        }, U = function(t, e) {
            return e && !t._gsapAllow && t.preventDefault(),
            t.changedTouches ? t.changedTouches[0] : t
        }, z = function(t) {
            var e = Math.max.apply(Math, t)
              , n = Math.min.apply(Math, t);
            return Math.abs(e) >= Math.abs(n) ? e : n
        }, B = function() {
            var t, e, n, r;
            (d = i.core.globals().ScrollTrigger) && d.core && (t = d.core,
            e = t.bridge || {},
            n = t._scrollers,
            r = t._proxies,
            n.push.apply(n, x),
            r.push.apply(r, b),
            x = n,
            b = r,
            M = function(t, n) {
                return e[t](n)
            }
            )
        }, k = function(t) {
            return (i = t || v()) && "undefined" != typeof document && document.body && (a = window,
            o = document,
            l = o.documentElement,
            c = o.body,
            f = [a, o, l, c],
            i.utils.clamp,
            g = i.core.context || function() {}
            ,
            h = "onpointerenter"in c ? "pointer" : "mouse",
            u = G.isTouch = a.matchMedia && a.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in a || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
            m = G.eventTypes = ("ontouchstart"in l ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in l ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
            setTimeout((function() {
                return _ = 0
            }
            ), 500),
            B(),
            s = 1),
            s
        };
        D.op = I,
        x.cache = 0;
        var G = function() {
            function t(t) {
                this.init(t)
            }
            var e, n, f;
            return t.prototype.init = function(t) {
                s || k(i) || console.warn("Please gsap.registerPlugin(Observer)"),
                d || B();
                var e = t.tolerance
                  , n = t.dragMinimum
                  , r = t.type
                  , f = t.target
                  , v = t.lineHeight
                  , _ = t.debounce
                  , x = t.preventDefault
                  , b = t.onStop
                  , M = t.onStopDelay
                  , T = t.ignore
                  , R = t.wheelSpeed
                  , L = t.event
                  , C = t.onDragStart
                  , G = t.onDragEnd
                  , H = t.onDrag
                  , V = t.onPress
                  , W = t.onRelease
                  , X = t.onRight
                  , j = t.onLeft
                  , Y = t.onUp
                  , q = t.onDown
                  , Z = t.onChangeX
                  , K = t.onChangeY
                  , J = t.onChange
                  , Q = t.onToggleX
                  , $ = t.onToggleY
                  , tt = t.onHover
                  , et = t.onHoverEnd
                  , nt = t.onMove
                  , rt = t.ignoreCheck
                  , it = t.isNormalizer
                  , st = t.onGestureStart
                  , at = t.onGestureEnd
                  , ot = t.onWheel
                  , lt = t.onEnable
                  , ct = t.onDisable
                  , ut = t.onClick
                  , ht = t.scrollSpeed
                  , dt = t.capture
                  , ft = t.allowClicks
                  , pt = t.lockAxis
                  , mt = t.onLockAxis;
                this.target = f = N(f) || l,
                this.vars = t,
                T && (T = i.utils.toArray(T)),
                e = e || 1e-9,
                n = n || 0,
                R = R || 1,
                ht = ht || 1,
                r = r || "wheel,touch,pointer",
                _ = !1 !== _,
                v || (v = parseFloat(a.getComputedStyle(c).lineHeight) || 22);
                var gt, vt, _t, yt, xt, bt, wt, Mt = this, Tt = 0, St = 0, Et = F(f, D), At = F(f, I), Rt = Et(), Lt = At(), Pt = ~r.indexOf("touch") && !~r.indexOf("pointer") && "pointerdown" === m[0], Ct = S(f), Dt = f.ownerDocument || o, It = [0, 0, 0], Nt = [0, 0, 0], Ft = 0, Ot = function() {
                    return Ft = w()
                }, Ut = function(t, e) {
                    return (Mt.event = t) && T && ~T.indexOf(t.target) || e && Pt && "touch" !== t.pointerType || rt && rt(t, e)
                }, zt = function() {
                    var t = Mt.deltaX = z(It)
                      , n = Mt.deltaY = z(Nt)
                      , r = Math.abs(t) >= e
                      , i = Math.abs(n) >= e;
                    J && (r || i) && J(Mt, t, n, It, Nt),
                    r && (X && Mt.deltaX > 0 && X(Mt),
                    j && Mt.deltaX < 0 && j(Mt),
                    Z && Z(Mt),
                    Q && Mt.deltaX < 0 != Tt < 0 && Q(Mt),
                    Tt = Mt.deltaX,
                    It[0] = It[1] = It[2] = 0),
                    i && (q && Mt.deltaY > 0 && q(Mt),
                    Y && Mt.deltaY < 0 && Y(Mt),
                    K && K(Mt),
                    $ && Mt.deltaY < 0 != St < 0 && $(Mt),
                    St = Mt.deltaY,
                    Nt[0] = Nt[1] = Nt[2] = 0),
                    (yt || _t) && (nt && nt(Mt),
                    _t && (H(Mt),
                    _t = !1),
                    yt = !1),
                    bt && !(bt = !1) && mt && mt(Mt),
                    xt && (ot(Mt),
                    xt = !1),
                    gt = 0
                }, Bt = function(t, e, n) {
                    It[n] += t,
                    Nt[n] += e,
                    Mt._vx.update(t),
                    Mt._vy.update(e),
                    _ ? gt || (gt = requestAnimationFrame(zt)) : zt()
                }, kt = function(t, e) {
                    pt && !wt && (Mt.axis = wt = Math.abs(t) > Math.abs(e) ? "x" : "y",
                    bt = !0),
                    "y" !== wt && (It[2] += t,
                    Mt._vx.update(t, !0)),
                    "x" !== wt && (Nt[2] += e,
                    Mt._vy.update(e, !0)),
                    _ ? gt || (gt = requestAnimationFrame(zt)) : zt()
                }, Gt = function(t) {
                    if (!Ut(t, 1)) {
                        var e = (t = U(t, x)).clientX
                          , r = t.clientY
                          , i = e - Mt.x
                          , s = r - Mt.y
                          , a = Mt.isDragging;
                        Mt.x = e,
                        Mt.y = r,
                        (a || Math.abs(Mt.startX - e) >= n || Math.abs(Mt.startY - r) >= n) && (H && (_t = !0),
                        a || (Mt.isDragging = !0),
                        kt(i, s),
                        a || C && C(Mt))
                    }
                }, Ht = Mt.onPress = function(t) {
                    Ut(t, 1) || (Mt.axis = wt = null,
                    vt.pause(),
                    Mt.isPressed = !0,
                    t = U(t),
                    Tt = St = 0,
                    Mt.startX = Mt.x = t.clientX,
                    Mt.startY = Mt.y = t.clientY,
                    Mt._vx.reset(),
                    Mt._vy.reset(),
                    E(it ? f : Dt, m[1], Gt, x, !0),
                    Mt.deltaX = Mt.deltaY = 0,
                    V && V(Mt))
                }
                , Vt = function(t) {
                    if (!Ut(t, 1)) {
                        A(it ? f : Dt, m[1], Gt, !0);
                        var e = !isNaN(Mt.y - Mt.startY)
                          , n = Mt.isDragging && (Math.abs(Mt.x - Mt.startX) > 3 || Math.abs(Mt.y - Mt.startY) > 3)
                          , r = U(t);
                        !n && e && (Mt._vx.reset(),
                        Mt._vy.reset(),
                        x && ft && i.delayedCall(.08, (function() {
                            if (w() - Ft > 300 && !t.defaultPrevented)
                                if (t.target.click)
                                    t.target.click();
                                else if (Dt.createEvent) {
                                    var e = Dt.createEvent("MouseEvents");
                                    e.initMouseEvent("click", !0, !0, a, 1, r.screenX, r.screenY, r.clientX, r.clientY, !1, !1, !1, !1, 0, null),
                                    t.target.dispatchEvent(e)
                                }
                        }
                        ))),
                        Mt.isDragging = Mt.isGesturing = Mt.isPressed = !1,
                        b && !it && vt.restart(!0),
                        G && n && G(Mt),
                        W && W(Mt, n)
                    }
                }, Wt = function(t) {
                    return t.touches && t.touches.length > 1 && (Mt.isGesturing = !0) && st(t, Mt.isDragging)
                }, Xt = function() {
                    return (Mt.isGesturing = !1) || at(Mt)
                }, jt = function(t) {
                    if (!Ut(t)) {
                        var e = Et()
                          , n = At();
                        Bt((e - Rt) * ht, (n - Lt) * ht, 1),
                        Rt = e,
                        Lt = n,
                        b && vt.restart(!0)
                    }
                }, Yt = function(t) {
                    if (!Ut(t)) {
                        t = U(t, x),
                        ot && (xt = !0);
                        var e = (1 === t.deltaMode ? v : 2 === t.deltaMode ? a.innerHeight : 1) * R;
                        Bt(t.deltaX * e, t.deltaY * e, 0),
                        b && !it && vt.restart(!0)
                    }
                }, qt = function(t) {
                    if (!Ut(t)) {
                        var e = t.clientX
                          , n = t.clientY
                          , r = e - Mt.x
                          , i = n - Mt.y;
                        Mt.x = e,
                        Mt.y = n,
                        yt = !0,
                        (r || i) && kt(r, i)
                    }
                }, Zt = function(t) {
                    Mt.event = t,
                    tt(Mt)
                }, Kt = function(t) {
                    Mt.event = t,
                    et(Mt)
                }, Jt = function(t) {
                    return Ut(t) || U(t, x) && ut(Mt)
                };
                vt = Mt._dc = i.delayedCall(M || .25, (function() {
                    Mt._vx.reset(),
                    Mt._vy.reset(),
                    vt.pause(),
                    b && b(Mt)
                }
                )).pause(),
                Mt.deltaX = Mt.deltaY = 0,
                Mt._vx = O(0, 50, !0),
                Mt._vy = O(0, 50, !0),
                Mt.scrollX = Et,
                Mt.scrollY = At,
                Mt.isDragging = Mt.isGesturing = Mt.isPressed = !1,
                g(this),
                Mt.enable = function(t) {
                    return Mt.isEnabled || (E(Ct ? Dt : f, "scroll", P),
                    r.indexOf("scroll") >= 0 && E(Ct ? Dt : f, "scroll", jt, x, dt),
                    r.indexOf("wheel") >= 0 && E(f, "wheel", Yt, x, dt),
                    (r.indexOf("touch") >= 0 && u || r.indexOf("pointer") >= 0) && (E(f, m[0], Ht, x, dt),
                    E(Dt, m[2], Vt),
                    E(Dt, m[3], Vt),
                    ft && E(f, "click", Ot, !1, !0),
                    ut && E(f, "click", Jt),
                    st && E(Dt, "gesturestart", Wt),
                    at && E(Dt, "gestureend", Xt),
                    tt && E(f, h + "enter", Zt),
                    et && E(f, h + "leave", Kt),
                    nt && E(f, h + "move", qt)),
                    Mt.isEnabled = !0,
                    t && t.type && Ht(t),
                    lt && lt(Mt)),
                    Mt
                }
                ,
                Mt.disable = function() {
                    Mt.isEnabled && (y.filter((function(t) {
                        return t !== Mt && S(t.target)
                    }
                    )).length || A(Ct ? Dt : f, "scroll", P),
                    Mt.isPressed && (Mt._vx.reset(),
                    Mt._vy.reset(),
                    A(it ? f : Dt, m[1], Gt, !0)),
                    A(Ct ? Dt : f, "scroll", jt, dt),
                    A(f, "wheel", Yt, dt),
                    A(f, m[0], Ht, dt),
                    A(Dt, m[2], Vt),
                    A(Dt, m[3], Vt),
                    A(f, "click", Ot, !0),
                    A(f, "click", Jt),
                    A(Dt, "gesturestart", Wt),
                    A(Dt, "gestureend", Xt),
                    A(f, h + "enter", Zt),
                    A(f, h + "leave", Kt),
                    A(f, h + "move", qt),
                    Mt.isEnabled = Mt.isPressed = Mt.isDragging = !1,
                    ct && ct(Mt))
                }
                ,
                Mt.kill = Mt.revert = function() {
                    Mt.disable();
                    var t = y.indexOf(Mt);
                    t >= 0 && y.splice(t, 1),
                    p === Mt && (p = 0)
                }
                ,
                y.push(Mt),
                it && S(f) && (p = Mt),
                Mt.enable(L)
            }
            ,
            e = t,
            (n = [{
                key: "velocityX",
                get: function() {
                    return this._vx.getVelocity()
                }
            }, {
                key: "velocityY",
                get: function() {
                    return this._vy.getVelocity()
                }
            }]) && r(e.prototype, n),
            f && r(e, f),
            t
        }();
        G.version = "3.11.4",
        G.create = function(t) {
            return new G(t)
        }
        ,
        G.register = k,
        G.getAll = function() {
            return y.slice()
        }
        ,
        G.getById = function(t) {
            return y.filter((function(e) {
                return e.vars.id === t
            }
            ))[0]
        }
        ,
        v() && i.registerPlugin(G);
        var H, V, W, X, j, Y, q, Z, K, J, Q, $, tt, et, nt, rt, it, st, at, ot, lt, ct, ut, ht, dt, ft, pt, mt, gt, vt, _t, yt, xt, bt, wt = 1, Mt = Date.now, Tt = Mt(), St = 0, Et = 0, At = function() {
            return et = 1
        }, Rt = function() {
            return et = 0
        }, Lt = function(t) {
            return t
        }, Pt = function(t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }, Ct = function() {
            return "undefined" != typeof window
        }, Dt = function() {
            return H || Ct() && (H = window.gsap) && H.registerPlugin && H
        }, It = function(t) {
            return !!~q.indexOf(t)
        }, Nt = function(t) {
            return T(t, "getBoundingClientRect") || (It(t) ? function() {
                return Xe.width = W.innerWidth,
                Xe.height = W.innerHeight,
                Xe
            }
            : function() {
                return ae(t)
            }
            )
        }, Ft = function(t, e) {
            var n = e.s
              , r = e.d2
              , i = e.d
              , s = e.a;
            return (n = "scroll" + r) && (s = T(t, n)) ? s() - Nt(t)()[i] : It(t) ? (j[n] || Y[n]) - (W["inner" + r] || j["client" + r] || Y["client" + r]) : t[n] - t["offset" + r]
        }, Ot = function(t, e) {
            for (var n = 0; n < at.length; n += 3)
                (!e || ~e.indexOf(at[n + 1])) && t(at[n], at[n + 1], at[n + 2])
        }, Ut = function(t) {
            return "string" == typeof t
        }, zt = function(t) {
            return "function" == typeof t
        }, Bt = function(t) {
            return "number" == typeof t
        }, kt = function(t) {
            return "object" == typeof t
        }, Gt = function(t, e, n) {
            return t && t.progress(e ? 0 : 1) && n && t.pause()
        }, Ht = function(t, e) {
            if (t.enabled) {
                var n = e(t);
                n && n.totalTime && (t.callbackAnimation = n)
            }
        }, Vt = Math.abs, Wt = "left", Xt = "right", jt = "bottom", Yt = "width", qt = "height", Zt = "Right", Kt = "Left", Jt = "Top", Qt = "Bottom", $t = "padding", te = "margin", ee = "Width", ne = "Height", re = "px", ie = function(t) {
            return W.getComputedStyle(t)
        }, se = function(t, e) {
            for (var n in e)
                n in t || (t[n] = e[n]);
            return t
        }, ae = function(t, e) {
            var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== ie(t)[nt] && H.to(t, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1)
              , r = t.getBoundingClientRect();
            return n && n.progress(0).kill(),
            r
        }, oe = function(t, e) {
            var n = e.d2;
            return t["offset" + n] || t["client" + n] || 0
        }, le = function(t) {
            var e, n = [], r = t.labels, i = t.duration();
            for (e in r)
                n.push(r[e] / i);
            return n
        }, ce = function(t) {
            var e = H.utils.snap(t)
              , n = Array.isArray(t) && t.slice(0).sort((function(t, e) {
                return t - e
            }
            ));
            return n ? function(t, r, i) {
                var s;
                if (void 0 === i && (i = .001),
                !r)
                    return e(t);
                if (r > 0) {
                    for (t -= i,
                    s = 0; s < n.length; s++)
                        if (n[s] >= t)
                            return n[s];
                    return n[s - 1]
                }
                for (s = n.length,
                t += i; s--; )
                    if (n[s] <= t)
                        return n[s];
                return n[0]
            }
            : function(n, r, i) {
                void 0 === i && (i = .001);
                var s = e(n);
                return !r || Math.abs(s - n) < i || s - n < 0 == r < 0 ? s : e(r < 0 ? n - t : n + t)
            }
        }, ue = function(t, e, n, r) {
            return n.split(",").forEach((function(n) {
                return t(e, n, r)
            }
            ))
        }, he = function(t, e, n, r, i) {
            return t.addEventListener(e, n, {
                passive: !r,
                capture: !!i
            })
        }, de = function(t, e, n, r) {
            return t.removeEventListener(e, n, !!r)
        }, fe = function(t, e, n) {
            return n && n.wheelHandler && t(e, "wheel", n)
        }, pe = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        }, me = {
            toggleActions: "play",
            anticipatePin: 0
        }, ge = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        }, ve = function(t, e) {
            if (Ut(t)) {
                var n = t.indexOf("=")
                  , r = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
                ~n && (t.indexOf("%") > n && (r *= e / 100),
                t = t.substr(0, n - 1)),
                t = r + (t in ge ? ge[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
            }
            return t
        }, _e = function(t, e, n, r, i, s, a, o) {
            var l = i.startColor
              , c = i.endColor
              , u = i.fontSize
              , h = i.indent
              , d = i.fontWeight
              , f = X.createElement("div")
              , p = It(n) || "fixed" === T(n, "pinType")
              , m = -1 !== t.indexOf("scroller")
              , g = p ? Y : n
              , v = -1 !== t.indexOf("start")
              , _ = v ? l : c
              , y = "border-color:" + _ + ";font-size:" + u + ";color:" + _ + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return y += "position:" + ((m || o) && p ? "fixed;" : "absolute;"),
            (m || o || !p) && (y += (r === I ? Xt : jt) + ":" + (s + parseFloat(h)) + "px;"),
            a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
            f._isStart = v,
            f.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
            f.style.cssText = y,
            f.innerText = e || 0 === e ? t + "-" + e : t,
            g.children[0] ? g.insertBefore(f, g.children[0]) : g.appendChild(f),
            f._offset = f["offset" + r.op.d2],
            ye(f, 0, r, v),
            f
        }, ye = function(t, e, n, r) {
            var i = {
                display: "block"
            }
              , s = n[r ? "os2" : "p2"]
              , a = n[r ? "p2" : "os2"];
            t._isFlipped = r,
            i[n.a + "Percent"] = r ? -100 : 0,
            i[n.a] = r ? "1px" : 0,
            i["border" + s + ee] = 1,
            i["border" + a + ee] = 0,
            i[n.p] = e + "px",
            H.set(t, i)
        }, xe = [], be = {}, we = function() {
            return Mt() - St > 34 && (_t || (_t = requestAnimationFrame(ze)))
        }, Me = function() {
            (!ut || !ut.isPressed || ut.startX > Y.clientWidth) && (x.cache++,
            ut ? _t || (_t = requestAnimationFrame(ze)) : ze(),
            St || Le("scrollStart"),
            St = Mt())
        }, Te = function() {
            ft = W.innerWidth,
            dt = W.innerHeight
        }, Se = function() {
            x.cache++,
            !tt && !ct && !X.fullscreenElement && !X.webkitFullscreenElement && (!ht || ft !== W.innerWidth || Math.abs(W.innerHeight - dt) > .25 * W.innerHeight) && Z.restart(!0)
        }, Ee = {}, Ae = [], Re = function t() {
            return de(Ke, "scrollEnd", t) || Fe(!0)
        }, Le = function(t) {
            return Ee[t] && Ee[t].map((function(t) {
                return t()
            }
            )) || Ae
        }, Pe = [], Ce = function(t) {
            for (var e = 0; e < Pe.length; e += 5)
                (!t || Pe[e + 4] && Pe[e + 4].query === t) && (Pe[e].style.cssText = Pe[e + 1],
                Pe[e].getBBox && Pe[e].setAttribute("transform", Pe[e + 2] || ""),
                Pe[e + 3].uncache = 1)
        }, De = function(t, e) {
            var n;
            for (rt = 0; rt < xe.length; rt++)
                !(n = xe[rt]) || e && n._ctx !== e || (t ? n.kill(1) : n.revert(!0, !0));
            e && Ce(e),
            e || Le("revert")
        }, Ie = function(t, e) {
            x.cache++,
            (e || !yt) && x.forEach((function(t) {
                return zt(t) && t.cacheID++ && (t.rec = 0)
            }
            )),
            Ut(t) && (W.history.scrollRestoration = gt = t)
        }, Ne = 0, Fe = function(t, e) {
            if (!St || t) {
                yt = Ke.isRefreshing = !0,
                x.forEach((function(t) {
                    return zt(t) && t.cacheID++ && (t.rec = t())
                }
                ));
                var n = Le("refreshInit");
                ot && Ke.sort(),
                e || De(),
                x.forEach((function(t) {
                    zt(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"),
                    t(0))
                }
                )),
                xe.slice(0).forEach((function(t) {
                    return t.refresh()
                }
                )),
                xe.forEach((function(t, e) {
                    if (t._subPinOffset && t.pin) {
                        var n = t.vars.horizontal ? "offsetWidth" : "offsetHeight"
                          , r = t.pin[n];
                        t.revert(!0, 1),
                        t.adjustPinSpacing(t.pin[n] - r),
                        t.revert(!1, 1)
                    }
                }
                )),
                xe.forEach((function(t) {
                    return "max" === t.vars.end && t.setPositions(t.start, Math.max(t.start + 1, Ft(t.scroller, t._dir)))
                }
                )),
                n.forEach((function(t) {
                    return t && t.render && t.render(-1)
                }
                )),
                x.forEach((function(t) {
                    zt(t) && (t.smooth && requestAnimationFrame((function() {
                        return t.target.style.scrollBehavior = "smooth"
                    }
                    )),
                    t.rec && t(t.rec))
                }
                )),
                Ie(gt, 1),
                Z.pause(),
                Ne++,
                ze(2),
                xe.forEach((function(t) {
                    return zt(t.vars.onRefresh) && t.vars.onRefresh(t)
                }
                )),
                yt = Ke.isRefreshing = !1,
                Le("refresh")
            } else
                he(Ke, "scrollEnd", Re)
        }, Oe = 0, Ue = 1, ze = function(t) {
            if (!yt || 2 === t) {
                Ke.isUpdating = !0,
                bt && bt.update(0);
                var e = xe.length
                  , n = Mt()
                  , r = n - Tt >= 50
                  , i = e && xe[0].scroll();
                if (Ue = Oe > i ? -1 : 1,
                Oe = i,
                r && (St && !et && n - St > 200 && (St = 0,
                Le("scrollEnd")),
                Q = Tt,
                Tt = n),
                Ue < 0) {
                    for (rt = e; rt-- > 0; )
                        xe[rt] && xe[rt].update(0, r);
                    Ue = 1
                } else
                    for (rt = 0; rt < e; rt++)
                        xe[rt] && xe[rt].update(0, r);
                Ke.isUpdating = !1
            }
            _t = 0
        }, Be = [Wt, "top", jt, Xt, te + Qt, te + Zt, te + Jt, te + Kt, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], ke = Be.concat([Yt, qt, "boxSizing", "max" + ee, "max" + ne, "position", te, $t, $t + Jt, $t + Zt, $t + Qt, $t + Kt]), Ge = function(t, e, n, r) {
            if (!t._gsap.swappedIn) {
                for (var i, s = Be.length, a = e.style, o = t.style; s--; )
                    a[i = Be[s]] = n[i];
                a.position = "absolute" === n.position ? "absolute" : "relative",
                "inline" === n.display && (a.display = "inline-block"),
                o[jt] = o[Xt] = "auto",
                a.flexBasis = n.flexBasis || "auto",
                a.overflow = "visible",
                a.boxSizing = "border-box",
                a[Yt] = oe(t, D) + re,
                a[qt] = oe(t, I) + re,
                a[$t] = o[te] = o.top = o[Wt] = "0",
                Ve(r),
                o[Yt] = o["max" + ee] = n[Yt],
                o[qt] = o["max" + ne] = n[qt],
                o[$t] = n[$t],
                t.parentNode !== e && (t.parentNode.insertBefore(e, t),
                e.appendChild(t)),
                t._gsap.swappedIn = !0
            }
        }, He = /([A-Z])/g, Ve = function(t) {
            if (t) {
                var e, n, r = t.t.style, i = t.length, s = 0;
                for ((t.t._gsap || H.core.getCache(t.t)).uncache = 1; s < i; s += 2)
                    n = t[s + 1],
                    e = t[s],
                    n ? r[e] = n : r[e] && r.removeProperty(e.replace(He, "-$1").toLowerCase())
            }
        }, We = function(t) {
            for (var e = ke.length, n = t.style, r = [], i = 0; i < e; i++)
                r.push(ke[i], n[ke[i]]);
            return r.t = t,
            r
        }, Xe = {
            left: 0,
            top: 0
        }, je = function(t, e, n, r, i, s, a, o, l, c, u, h, d) {
            zt(t) && (t = t(o)),
            Ut(t) && "max" === t.substr(0, 3) && (t = h + ("=" === t.charAt(4) ? ve("0" + t.substr(3), n) : 0));
            var f, p, m, g = d ? d.time() : 0;
            if (d && d.seek(0),
            Bt(t))
                a && ye(a, n, r, !0);
            else {
                zt(e) && (e = e(o));
                var v, _, y, x, b = (t || "0").split(" ");
                m = N(e) || Y,
                (v = ae(m) || {}) && (v.left || v.top) || "none" !== ie(m).display || (x = m.style.display,
                m.style.display = "block",
                v = ae(m),
                x ? m.style.display = x : m.style.removeProperty("display")),
                _ = ve(b[0], v[r.d]),
                y = ve(b[1] || "0", n),
                t = v[r.p] - l[r.p] - c + _ + i - y,
                a && ye(a, y, r, n - y < 20 || a._isStart && y > 20),
                n -= n - y
            }
            if (s) {
                var w = t + n
                  , M = s._isStart;
                f = "scroll" + r.d2,
                ye(s, w, r, M && w > 20 || !M && (u ? Math.max(Y[f], j[f]) : s.parentNode[f]) <= w + 1),
                u && (l = ae(a),
                u && (s.style[r.op.p] = l[r.op.p] - r.op.m - s._offset + re))
            }
            return d && m && (f = ae(m),
            d.seek(h),
            p = ae(m),
            d._caScrollDist = f[r.p] - p[r.p],
            t = t / d._caScrollDist * h),
            d && d.seek(g),
            d ? t : Math.round(t)
        }, Ye = /(webkit|moz|length|cssText|inset)/i, qe = function(t, e, n, r) {
            if (t.parentNode !== e) {
                var i, s, a = t.style;
                if (e === Y) {
                    for (i in t._stOrig = a.cssText,
                    s = ie(t))
                        +i || Ye.test(i) || !s[i] || "string" != typeof a[i] || "0" === i || (a[i] = s[i]);
                    a.top = n,
                    a.left = r
                } else
                    a.cssText = t._stOrig;
                H.core.getCache(t).uncache = 1,
                e.appendChild(t)
            }
        }, Ze = function(t, e) {
            var n, r, i = F(t, e), s = "_scroll" + e.p2, a = function e(a, o, l, c, u) {
                var h = e.tween
                  , d = o.onComplete
                  , f = {};
                return l = l || i(),
                u = c && u || 0,
                c = c || a - l,
                h && h.kill(),
                n = Math.round(l),
                o[s] = a,
                o.modifiers = f,
                f[s] = function(t) {
                    return (t = Math.round(i())) !== n && t !== r && Math.abs(t - n) > 3 && Math.abs(t - r) > 3 ? (h.kill(),
                    e.tween = 0) : t = l + c * h.ratio + u * h.ratio * h.ratio,
                    r = n,
                    n = Math.round(t)
                }
                ,
                o.onUpdate = function() {
                    x.cache++,
                    ze()
                }
                ,
                o.onComplete = function() {
                    e.tween = 0,
                    d && d.call(h)
                }
                ,
                h = e.tween = H.to(t, o)
            };
            return t[s] = i,
            i.wheelHandler = function() {
                return a.tween && a.tween.kill() && (a.tween = 0)
            }
            ,
            he(t, "wheel", i.wheelHandler),
            a
        }, Ke = function() {
            function t(e, n) {
                V || t.register(H) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                this.init(e, n)
            }
            return t.prototype.init = function(e, n) {
                if (this.progress = this.start = 0,
                this.vars && this.kill(!0, !0),
                Et) {
                    var r, i, s, a, o, l, c, u, h, d, f, p, m, g, v, _, y, w, M, S, E, A, R, L, P, C, O, U, z, B, k, G, V, q, Z, $, nt, it, st, at, ct, ut, ht = e = se(Ut(e) || Bt(e) || e.nodeType ? {
                        trigger: e
                    } : e, me), dt = ht.onUpdate, ft = ht.toggleClass, pt = ht.id, gt = ht.onToggle, _t = ht.onRefresh, Tt = ht.scrub, At = ht.trigger, Rt = ht.pin, Ct = ht.pinSpacing, Dt = ht.invalidateOnRefresh, Ot = ht.anticipatePin, Wt = ht.onScrubComplete, Xt = ht.onSnapComplete, jt = ht.once, ue = ht.snap, fe = ht.pinReparent, ge = ht.pinSpacer, ye = ht.containerAnimation, we = ht.fastScrollEnd, Te = ht.preventOverlaps, Ee = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? D : I, Ae = !Tt && 0 !== Tt, Le = N(e.scroller || W), Pe = H.core.getCache(Le), Ce = It(Le), De = "fixed" === ("pinType"in e ? e.pinType : T(Le, "pinType") || Ce && "fixed"), Ie = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], Oe = Ae && e.toggleActions.split(" "), ze = "markers"in e ? e.markers : me.markers, Be = Ce ? 0 : parseFloat(ie(Le)["border" + Ee.p2 + ee]) || 0, ke = this, He = e.onRefreshInit && function() {
                        return e.onRefreshInit(ke)
                    }
                    , Ye = function(t, e, n) {
                        var r = n.d
                          , i = n.d2
                          , s = n.a;
                        return (s = T(t, "getBoundingClientRect")) ? function() {
                            return s()[r]
                        }
                        : function() {
                            return (e ? W["inner" + i] : t["client" + i]) || 0
                        }
                    }(Le, Ce, Ee), Ke = function(t, e) {
                        return !e || ~b.indexOf(t) ? Nt(t) : function() {
                            return Xe
                        }
                    }(Le, Ce), Je = 0, Qe = 0, $e = F(Le, Ee);
                    if (mt(ke),
                    ke._dir = Ee,
                    Ot *= 45,
                    ke.scroller = Le,
                    ke.scroll = ye ? ye.time.bind(ye) : $e,
                    a = $e(),
                    ke.vars = e,
                    n = n || e.animation,
                    "refreshPriority"in e && (ot = 1,
                    -9999 === e.refreshPriority && (bt = ke)),
                    Pe.tweenScroll = Pe.tweenScroll || {
                        top: Ze(Le, I),
                        left: Ze(Le, D)
                    },
                    ke.tweenTo = r = Pe.tweenScroll[Ee.p],
                    ke.scrubDuration = function(t) {
                        (G = Bt(t) && t) ? k ? k.duration(t) : k = H.to(n, {
                            ease: "expo",
                            totalProgress: "+=0.001",
                            duration: G,
                            paused: !0,
                            onComplete: function() {
                                return Wt && Wt(ke)
                            }
                        }) : (k && k.progress(1).kill(),
                        k = 0)
                    }
                    ,
                    n && (n.vars.lazy = !1,
                    n._initted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.duration() && n.render(0, !0, !0),
                    ke.animation = n.pause(),
                    n.scrollTrigger = ke,
                    ke.scrubDuration(Tt),
                    z = 0,
                    pt || (pt = n.vars.id)),
                    xe.push(ke),
                    ue && (kt(ue) && !ue.push || (ue = {
                        snapTo: ue
                    }),
                    "scrollBehavior"in Y.style && H.set(Ce ? [Y, j] : Le, {
                        scrollBehavior: "auto"
                    }),
                    x.forEach((function(t) {
                        return zt(t) && t.target === (Ce ? X.scrollingElement || j : Le) && (t.smooth = !1)
                    }
                    )),
                    s = zt(ue.snapTo) ? ue.snapTo : "labels" === ue.snapTo ? function(t) {
                        return function(e) {
                            return H.utils.snap(le(t), e)
                        }
                    }(n) : "labelsDirectional" === ue.snapTo ? (at = n,
                    function(t, e) {
                        return ce(le(at))(t, e.direction)
                    }
                    ) : !1 !== ue.directional ? function(t, e) {
                        return ce(ue.snapTo)(t, Mt() - Qe < 500 ? 0 : e.direction)
                    }
                    : H.utils.snap(ue.snapTo),
                    V = ue.duration || {
                        min: .1,
                        max: 2
                    },
                    V = kt(V) ? J(V.min, V.max) : J(V, V),
                    q = H.delayedCall(ue.delay || G / 2 || .1, (function() {
                        var t = $e()
                          , e = Mt() - Qe < 500
                          , i = r.tween;
                        if (!(e || Math.abs(ke.getVelocity()) < 10) || i || et || Je === t)
                            ke.isActive && Je !== t && q.restart(!0);
                        else {
                            var a = (t - l) / m
                              , o = n && !Ae ? n.totalProgress() : a
                              , u = e ? 0 : (o - B) / (Mt() - Q) * 1e3 || 0
                              , h = H.utils.clamp(-a, 1 - a, Vt(u / 2) * u / .185)
                              , d = a + (!1 === ue.inertia ? 0 : h)
                              , f = J(0, 1, s(d, ke))
                              , p = Math.round(l + f * m)
                              , g = ue
                              , v = g.onStart
                              , _ = g.onInterrupt
                              , y = g.onComplete;
                            if (t <= c && t >= l && p !== t) {
                                if (i && !i._initted && i.data <= Vt(p - t))
                                    return;
                                !1 === ue.inertia && (h = f - a),
                                r(p, {
                                    duration: V(Vt(.185 * Math.max(Vt(d - o), Vt(f - o)) / u / .05 || 0)),
                                    ease: ue.ease || "power3",
                                    data: Vt(p - t),
                                    onInterrupt: function() {
                                        return q.restart(!0) && _ && _(ke)
                                    },
                                    onComplete: function() {
                                        ke.update(),
                                        Je = $e(),
                                        z = B = n && !Ae ? n.totalProgress() : ke.progress,
                                        Xt && Xt(ke),
                                        y && y(ke)
                                    }
                                }, t, h * m, p - t - h * m),
                                v && v(ke, r.tween)
                            }
                        }
                    }
                    )).pause()),
                    pt && (be[pt] = ke),
                    (st = (At = ke.trigger = N(At || Rt)) && At._gsap && At._gsap.stRevert) && (st = st(ke)),
                    Rt = !0 === Rt ? At : N(Rt),
                    Ut(ft) && (ft = {
                        targets: At,
                        className: ft
                    }),
                    Rt && (!1 === Ct || Ct === te || (Ct = !(!Ct && Rt.parentNode && Rt.parentNode.style && "flex" === ie(Rt.parentNode).display) && $t),
                    ke.pin = Rt,
                    (i = H.core.getCache(Rt)).spacer ? g = i.pinState : (ge && ((ge = N(ge)) && !ge.nodeType && (ge = ge.current || ge.nativeElement),
                    i.spacerIsNative = !!ge,
                    ge && (i.spacerState = We(ge))),
                    i.spacer = y = ge || X.createElement("div"),
                    y.classList.add("pin-spacer"),
                    pt && y.classList.add("pin-spacer-" + pt),
                    i.pinState = g = We(Rt)),
                    !1 !== e.force3D && H.set(Rt, {
                        force3D: !0
                    }),
                    ke.spacer = y = i.spacer,
                    U = ie(Rt),
                    R = U[Ct + Ee.os2],
                    M = H.getProperty(Rt),
                    S = H.quickSetter(Rt, Ee.a, re),
                    Ge(Rt, y, U),
                    _ = We(Rt)),
                    ze) {
                        p = kt(ze) ? se(ze, pe) : pe,
                        d = _e("scroller-start", pt, Le, Ee, p, 0),
                        f = _e("scroller-end", pt, Le, Ee, p, 0, d),
                        w = d["offset" + Ee.op.d2];
                        var tn = N(T(Le, "content") || Le);
                        u = this.markerStart = _e("start", pt, tn, Ee, p, w, 0, ye),
                        h = this.markerEnd = _e("end", pt, tn, Ee, p, w, 0, ye),
                        ye && (it = H.quickSetter([u, h], Ee.a, re)),
                        De || b.length && !0 === T(Le, "fixedMarkers") || (ut = ie(ct = Ce ? Y : Le).position,
                        ct.style.position = "absolute" === ut || "fixed" === ut ? ut : "relative",
                        H.set([d, f], {
                            force3D: !0
                        }),
                        P = H.quickSetter(d, Ee.a, re),
                        O = H.quickSetter(f, Ee.a, re))
                    }
                    if (ye) {
                        var en = ye.vars.onUpdate
                          , nn = ye.vars.onUpdateParams;
                        ye.eventCallback("onUpdate", (function() {
                            ke.update(0, 0, 1),
                            en && en.apply(nn || [])
                        }
                        ))
                    }
                    ke.previous = function() {
                        return xe[xe.indexOf(ke) - 1]
                    }
                    ,
                    ke.next = function() {
                        return xe[xe.indexOf(ke) + 1]
                    }
                    ,
                    ke.revert = function(t, e) {
                        if (!e)
                            return ke.kill(!0);
                        var r = !1 !== t || !ke.enabled
                          , i = tt;
                        r !== ke.isReverted && (r && ($ = Math.max($e(), ke.scroll.rec || 0),
                        Z = ke.progress,
                        nt = n && n.progress()),
                        u && [u, h, d, f].forEach((function(t) {
                            return t.style.display = r ? "none" : "block"
                        }
                        )),
                        r && (tt = 1,
                        ke.update(r)),
                        !Rt || fe && ke.isActive || (r ? function(t, e, n) {
                            Ve(n);
                            var r = t._gsap;
                            if (r.spacerIsNative)
                                Ve(r.spacerState);
                            else if (t._gsap.swappedIn) {
                                var i = e.parentNode;
                                i && (i.insertBefore(t, e),
                                i.removeChild(e))
                            }
                            t._gsap.swappedIn = !1
                        }(Rt, y, g) : Ge(Rt, y, ie(Rt), L)),
                        r || ke.update(r),
                        tt = i,
                        ke.isReverted = r)
                    }
                    ,
                    ke.refresh = function(i, s) {
                        if (!tt && ke.enabled || s)
                            if (Rt && i && St)
                                he(t, "scrollEnd", Re);
                            else {
                                !yt && He && He(ke),
                                tt = 1,
                                Qe = Mt(),
                                r.tween && (r.tween.kill(),
                                r.tween = 0),
                                k && k.pause(),
                                Dt && n && n.revert({
                                    kill: !1
                                }).invalidate(),
                                ke.isReverted || ke.revert(!0, !0),
                                ke._subPinOffset = !1;
                                for (var p, x, b, w, T, S, R, P, O, U, z, B = Ye(), G = Ke(), V = ye ? ye.duration() : Ft(Le, Ee), W = 0, K = 0, J = e.end, Q = e.endTrigger || At, et = e.start || (0 !== e.start && At ? Rt ? "0 0" : "0 100%" : 0), rt = ke.pinnedContainer = e.pinnedContainer && N(e.pinnedContainer), it = At && Math.max(0, xe.indexOf(ke)) || 0, st = it; st--; )
                                    (S = xe[st]).end || S.refresh(0, 1) || (tt = 1),
                                    !(R = S.pin) || R !== At && R !== Rt || S.isReverted || (U || (U = []),
                                    U.unshift(S),
                                    S.revert(!0, !0)),
                                    S !== xe[st] && (it--,
                                    st--);
                                for (zt(et) && (et = et(ke)),
                                l = je(et, At, B, Ee, $e(), u, d, ke, G, Be, De, V, ye) || (Rt ? -.001 : 0),
                                zt(J) && (J = J(ke)),
                                Ut(J) && !J.indexOf("+=") && (~J.indexOf(" ") ? J = (Ut(et) ? et.split(" ")[0] : "") + J : (W = ve(J.substr(2), B),
                                J = Ut(et) ? et : l + W,
                                Q = At)),
                                c = Math.max(l, je(J || (Q ? "100% 0" : V), Q, B, Ee, $e() + W, h, f, ke, G, Be, De, V, ye)) || -.001,
                                m = c - l || (l -= .01) && .001,
                                W = 0,
                                st = it; st--; )
                                    (R = (S = xe[st]).pin) && S.start - S._pinPush <= l && !ye && S.end > 0 && (p = S.end - S.start,
                                    (R === At && S.start - S._pinPush < l || R === rt) && !Bt(et) && (W += p * (1 - S.progress)),
                                    R === Rt && (K += p));
                                if (l += W,
                                c += W,
                                ke._pinPush = K,
                                u && W && ((p = {})[Ee.a] = "+=" + W,
                                rt && (p[Ee.p] = "-=" + $e()),
                                H.set([u, h], p)),
                                Rt)
                                    p = ie(Rt),
                                    w = Ee === I,
                                    b = $e(),
                                    E = parseFloat(M(Ee.a)) + K,
                                    !V && c > 1 && ((z = {
                                        style: z = (Ce ? X.scrollingElement || j : Le).style,
                                        value: z["overflow" + Ee.a.toUpperCase()]
                                    })["overflow" + Ee.a.toUpperCase()] = "scroll"),
                                    Ge(Rt, y, p),
                                    _ = We(Rt),
                                    x = ae(Rt, !0),
                                    P = De && F(Le, w ? D : I)(),
                                    Ct && ((L = [Ct + Ee.os2, m + K + re]).t = y,
                                    (st = Ct === $t ? oe(Rt, Ee) + m + K : 0) && L.push(Ee.d, st + re),
                                    Ve(L),
                                    rt && xe.forEach((function(t) {
                                        t.pin === rt && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0)
                                    }
                                    )),
                                    De && $e($)),
                                    De && ((T = {
                                        top: x.top + (w ? b - l : P) + re,
                                        left: x.left + (w ? P : b - l) + re,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    })[Yt] = T["max" + ee] = Math.ceil(x.width) + re,
                                    T[qt] = T["max" + ne] = Math.ceil(x.height) + re,
                                    T[te] = T[te + Jt] = T[te + Zt] = T[te + Qt] = T[te + Kt] = "0",
                                    T[$t] = p[$t],
                                    T[$t + Jt] = p[$t + Jt],
                                    T[$t + Zt] = p[$t + Zt],
                                    T[$t + Qt] = p[$t + Qt],
                                    T[$t + Kt] = p[$t + Kt],
                                    v = function(t, e, n) {
                                        for (var r, i = [], s = t.length, a = n ? 8 : 0; a < s; a += 2)
                                            r = t[a],
                                            i.push(r, r in e ? e[r] : t[a + 1]);
                                        return i.t = t.t,
                                        i
                                    }(g, T, fe),
                                    yt && $e(0)),
                                    n ? (O = n._initted,
                                    lt(1),
                                    n.render(n.duration(), !0, !0),
                                    A = M(Ee.a) - E + m + K,
                                    C = Math.abs(m - A) > 1,
                                    De && C && v.splice(v.length - 2, 2),
                                    n.render(0, !0, !0),
                                    O || n.invalidate(!0),
                                    n.parent || n.totalTime(n.totalTime()),
                                    lt(0)) : A = m,
                                    z && (z.value ? z.style["overflow" + Ee.a.toUpperCase()] = z.value : z.style.removeProperty("overflow-" + Ee.a));
                                else if (At && $e() && !ye)
                                    for (x = At.parentNode; x && x !== Y; )
                                        x._pinOffset && (l -= x._pinOffset,
                                        c -= x._pinOffset),
                                        x = x.parentNode;
                                U && U.forEach((function(t) {
                                    return t.revert(!1, !0)
                                }
                                )),
                                ke.start = l,
                                ke.end = c,
                                a = o = yt ? $ : $e(),
                                ye || yt || (a < $ && $e($),
                                ke.scroll.rec = 0),
                                ke.revert(!1, !0),
                                q && (Je = -1,
                                ke.isActive && $e(l + m * Z),
                                q.restart(!0)),
                                tt = 0,
                                n && Ae && (n._initted || nt) && n.progress() !== nt && n.progress(nt, !0).render(n.time(), !0, !0),
                                (Z !== ke.progress || ye) && (n && !Ae && n.totalProgress(Z, !0),
                                ke.progress = (a - l) / m === Z ? 0 : Z),
                                Rt && Ct && (y._pinOffset = Math.round(ke.progress * A)),
                                _t && !yt && _t(ke)
                            }
                    }
                    ,
                    ke.getVelocity = function() {
                        return ($e() - o) / (Mt() - Q) * 1e3 || 0
                    }
                    ,
                    ke.endAnimation = function() {
                        Gt(ke.callbackAnimation),
                        n && (k ? k.progress(1) : n.paused() ? Ae || Gt(n, ke.direction < 0, 1) : Gt(n, n.reversed()))
                    }
                    ,
                    ke.labelToScroll = function(t) {
                        return n && n.labels && (l || ke.refresh() || l) + n.labels[t] / n.duration() * m || 0
                    }
                    ,
                    ke.getTrailing = function(t) {
                        var e = xe.indexOf(ke)
                          , n = ke.direction > 0 ? xe.slice(0, e).reverse() : xe.slice(e + 1);
                        return (Ut(t) ? n.filter((function(e) {
                            return e.vars.preventOverlaps === t
                        }
                        )) : n).filter((function(t) {
                            return ke.direction > 0 ? t.end <= l : t.start >= c
                        }
                        ))
                    }
                    ,
                    ke.update = function(t, e, i) {
                        if (!ye || i || t) {
                            var s, u, h, f, p, g, x, b = yt ? $ : ke.scroll(), w = t ? 0 : (b - l) / m, M = w < 0 ? 0 : w > 1 ? 1 : w || 0, T = ke.progress;
                            if (e && (o = a,
                            a = ye ? $e() : b,
                            ue && (B = z,
                            z = n && !Ae ? n.totalProgress() : M)),
                            Ot && !M && Rt && !tt && !wt && St && l < b + (b - o) / (Mt() - Q) * Ot && (M = 1e-4),
                            M !== T && ke.enabled) {
                                if (f = (p = (s = ke.isActive = !!M && M < 1) !== (!!T && T < 1)) || !!M != !!T,
                                ke.direction = M > T ? 1 : -1,
                                ke.progress = M,
                                f && !tt && (u = M && !T ? 0 : 1 === M ? 1 : 1 === T ? 2 : 3,
                                Ae && (h = !p && "none" !== Oe[u + 1] && Oe[u + 1] || Oe[u],
                                x = n && ("complete" === h || "reset" === h || h in n))),
                                Te && (p || x) && (x || Tt || !n) && (zt(Te) ? Te(ke) : ke.getTrailing(Te).forEach((function(t) {
                                    return t.endAnimation()
                                }
                                ))),
                                Ae || (!k || tt || wt ? n && n.totalProgress(M, !!tt) : (k._dp._time - k._start !== k._time && k.render(k._dp._time - k._start),
                                k.resetTo ? k.resetTo("totalProgress", M, n._tTime / n._tDur) : (k.vars.totalProgress = M,
                                k.invalidate().restart()))),
                                Rt)
                                    if (t && Ct && (y.style[Ct + Ee.os2] = R),
                                    De) {
                                        if (f) {
                                            if (g = !t && M > T && c + 1 > b && b + 1 >= Ft(Le, Ee),
                                            fe)
                                                if (t || !s && !g)
                                                    qe(Rt, y);
                                                else {
                                                    var L = ae(Rt, !0)
                                                      , D = b - l;
                                                    qe(Rt, Y, L.top + (Ee === I ? D : 0) + re, L.left + (Ee === I ? 0 : D) + re)
                                                }
                                            Ve(s || g ? v : _),
                                            C && M < 1 && s || S(E + (1 !== M || g ? 0 : A))
                                        }
                                    } else
                                        S(Pt(E + A * M));
                                ue && !r.tween && !tt && !wt && q.restart(!0),
                                ft && (p || jt && M && (M < 1 || !vt)) && K(ft.targets).forEach((function(t) {
                                    return t.classList[s || jt ? "add" : "remove"](ft.className)
                                }
                                )),
                                dt && !Ae && !t && dt(ke),
                                f && !tt ? (Ae && (x && ("complete" === h ? n.pause().totalProgress(1) : "reset" === h ? n.restart(!0).pause() : "restart" === h ? n.restart(!0) : n[h]()),
                                dt && dt(ke)),
                                !p && vt || (gt && p && Ht(ke, gt),
                                Ie[u] && Ht(ke, Ie[u]),
                                jt && (1 === M ? ke.kill(!1, 1) : Ie[u] = 0),
                                p || Ie[u = 1 === M ? 1 : 3] && Ht(ke, Ie[u])),
                                we && !s && Math.abs(ke.getVelocity()) > (Bt(we) ? we : 2500) && (Gt(ke.callbackAnimation),
                                k ? k.progress(1) : Gt(n, "reverse" === h ? 1 : !M, 1))) : Ae && dt && !tt && dt(ke)
                            }
                            if (O) {
                                var N = ye ? b / ye.duration() * (ye._caScrollDist || 0) : b;
                                P(N + (d._isFlipped ? 1 : 0)),
                                O(N)
                            }
                            it && it(-b / ye.duration() * (ye._caScrollDist || 0))
                        }
                    }
                    ,
                    ke.enable = function(e, n) {
                        ke.enabled || (ke.enabled = !0,
                        he(Le, "resize", Se),
                        he(Ce ? X : Le, "scroll", Me),
                        He && he(t, "refreshInit", He),
                        !1 !== e && (ke.progress = Z = 0,
                        a = o = Je = $e()),
                        !1 !== n && ke.refresh())
                    }
                    ,
                    ke.getTween = function(t) {
                        return t && r ? r.tween : k
                    }
                    ,
                    ke.setPositions = function(t, e) {
                        Rt && (E += t - l,
                        A += e - t - m,
                        Ct === $t && ke.adjustPinSpacing(e - t - m)),
                        ke.start = l = t,
                        ke.end = c = e,
                        m = e - t,
                        ke.update()
                    }
                    ,
                    ke.adjustPinSpacing = function(t) {
                        if (L) {
                            var e = L.indexOf(Ee.d) + 1;
                            L[e] = parseFloat(L[e]) + t + re,
                            L[1] = parseFloat(L[1]) + t + re,
                            Ve(L)
                        }
                    }
                    ,
                    ke.disable = function(e, n) {
                        if (ke.enabled && (!1 !== e && ke.revert(!0, !0),
                        ke.enabled = ke.isActive = !1,
                        n || k && k.pause(),
                        $ = 0,
                        i && (i.uncache = 1),
                        He && de(t, "refreshInit", He),
                        q && (q.pause(),
                        r.tween && r.tween.kill() && (r.tween = 0)),
                        !Ce)) {
                            for (var s = xe.length; s--; )
                                if (xe[s].scroller === Le && xe[s] !== ke)
                                    return;
                            de(Le, "resize", Se),
                            de(Le, "scroll", Me)
                        }
                    }
                    ,
                    ke.kill = function(t, r) {
                        ke.disable(t, r),
                        k && !r && k.kill(),
                        pt && delete be[pt];
                        var s = xe.indexOf(ke);
                        s >= 0 && xe.splice(s, 1),
                        s === rt && Ue > 0 && rt--,
                        s = 0,
                        xe.forEach((function(t) {
                            return t.scroller === ke.scroller && (s = 1)
                        }
                        )),
                        s || yt || (ke.scroll.rec = 0),
                        n && (n.scrollTrigger = null,
                        t && n.revert({
                            kill: !1
                        }),
                        r || n.kill()),
                        u && [u, h, d, f].forEach((function(t) {
                            return t.parentNode && t.parentNode.removeChild(t)
                        }
                        )),
                        bt === ke && (bt = 0),
                        Rt && (i && (i.uncache = 1),
                        s = 0,
                        xe.forEach((function(t) {
                            return t.pin === Rt && s++
                        }
                        )),
                        s || (i.spacer = 0)),
                        e.onKill && e.onKill(ke)
                    }
                    ,
                    ke.enable(!1, !1),
                    st && st(ke),
                    n && n.add && !m ? H.delayedCall(.01, (function() {
                        return l || c || ke.refresh()
                    }
                    )) && (m = .01) && (l = c = 0) : ke.refresh(),
                    Rt && function() {
                        if (xt !== Ne) {
                            var t = xt = Ne;
                            requestAnimationFrame((function() {
                                return t === Ne && Fe(!0)
                            }
                            ))
                        }
                    }()
                } else
                    this.update = this.refresh = this.kill = Lt
            }
            ,
            t.register = function(e) {
                return V || (H = e || Dt(),
                Ct() && window.document && t.enable(),
                V = Et),
                V
            }
            ,
            t.defaults = function(t) {
                if (t)
                    for (var e in t)
                        me[e] = t[e];
                return me
            }
            ,
            t.disable = function(t, e) {
                Et = 0,
                xe.forEach((function(n) {
                    return n[e ? "kill" : "disable"](t)
                }
                )),
                de(W, "wheel", Me),
                de(X, "scroll", Me),
                clearInterval($),
                de(X, "touchcancel", Lt),
                de(Y, "touchstart", Lt),
                ue(de, X, "pointerdown,touchstart,mousedown", At),
                ue(de, X, "pointerup,touchend,mouseup", Rt),
                Z.kill(),
                Ot(de);
                for (var n = 0; n < x.length; n += 3)
                    fe(de, x[n], x[n + 1]),
                    fe(de, x[n], x[n + 2])
            }
            ,
            t.enable = function() {
                if (W = window,
                X = document,
                j = X.documentElement,
                Y = X.body,
                H && (K = H.utils.toArray,
                J = H.utils.clamp,
                mt = H.core.context || Lt,
                lt = H.core.suppressOverwrites || Lt,
                gt = W.history.scrollRestoration || "auto",
                H.core.globals("ScrollTrigger", t),
                Y)) {
                    Et = 1,
                    G.register(H),
                    t.isTouch = G.isTouch,
                    pt = G.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                    he(W, "wheel", Me),
                    q = [W, X, j, Y],
                    H.matchMedia ? (t.matchMedia = function(t) {
                        var e, n = H.matchMedia();
                        for (e in t)
                            n.add(e, t[e]);
                        return n
                    }
                    ,
                    H.addEventListener("matchMediaInit", (function() {
                        return De()
                    }
                    )),
                    H.addEventListener("matchMediaRevert", (function() {
                        return Ce()
                    }
                    )),
                    H.addEventListener("matchMedia", (function() {
                        Fe(0, 1),
                        Le("matchMedia")
                    }
                    )),
                    H.matchMedia("(orientation: portrait)", (function() {
                        return Te(),
                        Te
                    }
                    ))) : console.warn("Requires GSAP 3.11.0 or later"),
                    Te(),
                    he(X, "scroll", Me);
                    var e, n, r = Y.style, i = r.borderTopStyle, s = H.core.Animation.prototype;
                    for (s.revert || Object.defineProperty(s, "revert", {
                        value: function() {
                            return this.time(-.01, !0)
                        }
                    }),
                    r.borderTopStyle = "solid",
                    e = ae(Y),
                    I.m = Math.round(e.top + I.sc()) || 0,
                    D.m = Math.round(e.left + D.sc()) || 0,
                    i ? r.borderTopStyle = i : r.removeProperty("border-top-style"),
                    $ = setInterval(we, 250),
                    H.delayedCall(.5, (function() {
                        return wt = 0
                    }
                    )),
                    he(X, "touchcancel", Lt),
                    he(Y, "touchstart", Lt),
                    ue(he, X, "pointerdown,touchstart,mousedown", At),
                    ue(he, X, "pointerup,touchend,mouseup", Rt),
                    nt = H.utils.checkPrefix("transform"),
                    ke.push(nt),
                    V = Mt(),
                    Z = H.delayedCall(.2, Fe).pause(),
                    at = [X, "visibilitychange", function() {
                        var t = W.innerWidth
                          , e = W.innerHeight;
                        X.hidden ? (it = t,
                        st = e) : it === t && st === e || Se()
                    }
                    , X, "DOMContentLoaded", Fe, W, "load", Fe, W, "resize", Se],
                    Ot(he),
                    xe.forEach((function(t) {
                        return t.enable(0, 1)
                    }
                    )),
                    n = 0; n < x.length; n += 3)
                        fe(de, x[n], x[n + 1]),
                        fe(de, x[n], x[n + 2])
                }
            }
            ,
            t.config = function(e) {
                "limitCallbacks"in e && (vt = !!e.limitCallbacks);
                var n = e.syncInterval;
                n && clearInterval($) || ($ = n) && setInterval(we, n),
                "ignoreMobileResize"in e && (ht = 1 === t.isTouch && e.ignoreMobileResize),
                "autoRefreshEvents"in e && (Ot(de) || Ot(he, e.autoRefreshEvents || "none"),
                ct = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
            }
            ,
            t.scrollerProxy = function(t, e) {
                var n = N(t)
                  , r = x.indexOf(n)
                  , i = It(n);
                ~r && x.splice(r, i ? 6 : 2),
                e && (i ? b.unshift(W, e, Y, e, j, e) : b.unshift(n, e))
            }
            ,
            t.clearMatchMedia = function(t) {
                xe.forEach((function(e) {
                    return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0)
                }
                ))
            }
            ,
            t.isInViewport = function(t, e, n) {
                var r = (Ut(t) ? N(t) : t).getBoundingClientRect()
                  , i = r[n ? Yt : qt] * e || 0;
                return n ? r.right - i > 0 && r.left + i < W.innerWidth : r.bottom - i > 0 && r.top + i < W.innerHeight
            }
            ,
            t.positionInViewport = function(t, e, n) {
                Ut(t) && (t = N(t));
                var r = t.getBoundingClientRect()
                  , i = r[n ? Yt : qt]
                  , s = null == e ? i / 2 : e in ge ? ge[e] * i : ~e.indexOf("%") ? parseFloat(e) * i / 100 : parseFloat(e) || 0;
                return n ? (r.left + s) / W.innerWidth : (r.top + s) / W.innerHeight
            }
            ,
            t.killAll = function(t) {
                if (xe.slice(0).forEach((function(t) {
                    return "ScrollSmoother" !== t.vars.id && t.kill()
                }
                )),
                !0 !== t) {
                    var e = Ee.killAll || [];
                    Ee = {},
                    e.forEach((function(t) {
                        return t()
                    }
                    ))
                }
            }
            ,
            t
        }();
        Ke.version = "3.11.4",
        Ke.saveStyles = function(t) {
            return t ? K(t).forEach((function(t) {
                if (t && t.style) {
                    var e = Pe.indexOf(t);
                    e >= 0 && Pe.splice(e, 5),
                    Pe.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), H.core.getCache(t), mt())
                }
            }
            )) : Pe
        }
        ,
        Ke.revert = function(t, e) {
            return De(!t, e)
        }
        ,
        Ke.create = function(t, e) {
            return new Ke(t,e)
        }
        ,
        Ke.refresh = function(t) {
            return t ? Se() : (V || Ke.register()) && Fe(!0)
        }
        ,
        Ke.update = function(t) {
            return ++x.cache && ze(!0 === t ? 2 : 0)
        }
        ,
        Ke.clearScrollMemory = Ie,
        Ke.maxScroll = function(t, e) {
            return Ft(t, e ? D : I)
        }
        ,
        Ke.getScrollFunc = function(t, e) {
            return F(N(t), e ? D : I)
        }
        ,
        Ke.getById = function(t) {
            return be[t]
        }
        ,
        Ke.getAll = function() {
            return xe.filter((function(t) {
                return "ScrollSmoother" !== t.vars.id
            }
            ))
        }
        ,
        Ke.isScrolling = function() {
            return !!St
        }
        ,
        Ke.snapDirectional = ce,
        Ke.addEventListener = function(t, e) {
            var n = Ee[t] || (Ee[t] = []);
            ~n.indexOf(e) || n.push(e)
        }
        ,
        Ke.removeEventListener = function(t, e) {
            var n = Ee[t]
              , r = n && n.indexOf(e);
            r >= 0 && n.splice(r, 1)
        }
        ,
        Ke.batch = function(t, e) {
            var n, r = [], i = {}, s = e.interval || .016, a = e.batchMax || 1e9, o = function(t, e) {
                var n = []
                  , r = []
                  , i = H.delayedCall(s, (function() {
                    e(n, r),
                    n = [],
                    r = []
                }
                )).pause();
                return function(t) {
                    n.length || i.restart(!0),
                    n.push(t.trigger),
                    r.push(t),
                    a <= n.length && i.progress(1)
                }
            };
            for (n in e)
                i[n] = "on" === n.substr(0, 2) && zt(e[n]) && "onRefreshInit" !== n ? o(0, e[n]) : e[n];
            return zt(a) && (a = a(),
            he(Ke, "refresh", (function() {
                return a = e.batchMax()
            }
            ))),
            K(t).forEach((function(t) {
                var e = {};
                for (n in i)
                    e[n] = i[n];
                e.trigger = t,
                r.push(Ke.create(e))
            }
            )),
            r
        }
        ;
        var Je, Qe = function(t, e, n, r) {
            return e > r ? t(r) : e < 0 && t(0),
            n > r ? (r - e) / (n - e) : n < 0 ? e / (e - n) : 1
        }, $e = function t(e, n) {
            !0 === n ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (G.isTouch ? " pinch-zoom" : "") : "none",
            e === j && t(Y, n)
        }, tn = {
            auto: 1,
            scroll: 1
        }, en = function(t) {
            var e, n = t.event, r = t.target, i = t.axis, s = (n.changedTouches ? n.changedTouches[0] : n).target, a = s._gsap || H.core.getCache(s), o = Mt();
            if (!a._isScrollT || o - a._isScrollT > 2e3) {
                for (; s && s !== Y && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !tn[(e = ie(s)).overflowY] && !tn[e.overflowX]); )
                    s = s.parentNode;
                a._isScroll = s && s !== r && !It(s) && (tn[(e = ie(s)).overflowY] || tn[e.overflowX]),
                a._isScrollT = o
            }
            (a._isScroll || "x" === i) && (n.stopPropagation(),
            n._gsapAllow = !0)
        }, nn = function(t, e, n, r) {
            return G.create({
                target: t,
                capture: !0,
                debounce: !1,
                lockAxis: !0,
                type: e,
                onWheel: r = r && en,
                onPress: r,
                onDrag: r,
                onScroll: r,
                onEnable: function() {
                    return n && he(X, G.eventTypes[0], sn, !1, !0)
                },
                onDisable: function() {
                    return de(X, G.eventTypes[0], sn, !0)
                }
            })
        }, rn = /(input|label|select|textarea)/i, sn = function(t) {
            var e = rn.test(t.target.tagName);
            (e || Je) && (t._gsapAllow = !0,
            Je = e)
        }, an = function(t) {
            kt(t) || (t = {}),
            t.preventDefault = t.isNormalizer = t.allowClicks = !0,
            t.type || (t.type = "wheel,touch"),
            t.debounce = !!t.debounce,
            t.id = t.id || "normalizer";
            var e, n, r, i, s, a, o, l, c = t, u = c.normalizeScrollX, h = c.momentum, d = c.allowNestedScroll, f = N(t.target) || j, p = H.core.globals().ScrollSmoother, m = p && p.get(), g = pt && (t.content && N(t.content) || m && !1 !== t.content && !m.smooth() && m.content()), v = F(f, I), _ = F(f, D), y = 1, b = (G.isTouch && W.visualViewport ? W.visualViewport.scale * W.visualViewport.width : W.outerWidth) / W.innerWidth, w = 0, M = zt(h) ? function() {
                return h(e)
            }
            : function() {
                return h || 2.8
            }
            , T = nn(f, t.type, !0, d), S = function() {
                return i = !1
            }, E = Lt, A = Lt, R = function() {
                n = Ft(f, I),
                A = J(pt ? 1 : 0, n),
                u && (E = J(0, Ft(f, D))),
                r = Ne
            }, L = function() {
                g._gsap.y = Pt(parseFloat(g._gsap.y) + v.offset) + "px",
                g.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(g._gsap.y) + ", 0, 1)",
                v.offset = v.cacheID = 0
            }, P = function() {
                R(),
                s.isActive() && s.vars.scrollY > n && (v() > n ? s.progress(1) && v(n) : s.resetTo("scrollY", n))
            };
            return g && H.set(g, {
                y: "+=0"
            }),
            t.ignoreCheck = function(t) {
                return pt && "touchmove" === t.type && function() {
                    if (i) {
                        requestAnimationFrame(S);
                        var t = Pt(e.deltaY / 2)
                          , n = A(v.v - t);
                        if (g && n !== v.v + v.offset) {
                            v.offset = n - v.v;
                            var r = Pt((parseFloat(g && g._gsap.y) || 0) - v.offset);
                            g.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + r + ", 0, 1)",
                            g._gsap.y = r + "px",
                            v.cacheID = x.cache,
                            ze()
                        }
                        return !0
                    }
                    v.offset && L(),
                    i = !0
                }() || y > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1
            }
            ,
            t.onPress = function() {
                var t = y;
                y = Pt((W.visualViewport && W.visualViewport.scale || 1) / b),
                s.pause(),
                t !== y && $e(f, y > 1.01 || !u && "x"),
                a = _(),
                o = v(),
                R(),
                r = Ne
            }
            ,
            t.onRelease = t.onGestureStart = function(t, e) {
                if (v.offset && L(),
                e) {
                    x.cache++;
                    var r, i, a = M();
                    u && (i = (r = _()) + .05 * a * -t.velocityX / .227,
                    a *= Qe(_, r, i, Ft(f, D)),
                    s.vars.scrollX = E(i)),
                    i = (r = v()) + .05 * a * -t.velocityY / .227,
                    a *= Qe(v, r, i, Ft(f, I)),
                    s.vars.scrollY = A(i),
                    s.invalidate().duration(a).play(.01),
                    (pt && s.vars.scrollY >= n || r >= n - 1) && H.to({}, {
                        onUpdate: P,
                        duration: a
                    })
                } else
                    l.restart(!0)
            }
            ,
            t.onWheel = function() {
                s._ts && s.pause(),
                Mt() - w > 1e3 && (r = 0,
                w = Mt())
            }
            ,
            t.onChange = function(t, e, n, i, s) {
                if (Ne !== r && R(),
                e && u && _(E(i[2] === e ? a + (t.startX - t.x) : _() + e - i[1])),
                n) {
                    v.offset && L();
                    var l = s[2] === n
                      , c = l ? o + t.startY - t.y : v() + n - s[1]
                      , h = A(c);
                    l && c !== h && (o += h - c),
                    v(h)
                }
                (n || e) && ze()
            }
            ,
            t.onEnable = function() {
                $e(f, !u && "x"),
                Ke.addEventListener("refresh", P),
                he(W, "resize", P),
                v.smooth && (v.target.style.scrollBehavior = "auto",
                v.smooth = _.smooth = !1),
                T.enable()
            }
            ,
            t.onDisable = function() {
                $e(f, !0),
                de(W, "resize", P),
                Ke.removeEventListener("refresh", P),
                T.kill()
            }
            ,
            t.lockAxis = !1 !== t.lockAxis,
            (e = new G(t)).iOS = pt,
            pt && !v() && v(1),
            pt && H.ticker.add(Lt),
            l = e._dc,
            s = H.to(e, {
                ease: "power4",
                paused: !0,
                scrollX: u ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                onComplete: l.vars.onComplete
            }),
            e
        };
        Ke.sort = function(t) {
            return xe.sort(t || function(t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            }
            )
        }
        ,
        Ke.observe = function(t) {
            return new G(t)
        }
        ,
        Ke.normalizeScroll = function(t) {
            if (void 0 === t)
                return ut;
            if (!0 === t && ut)
                return ut.enable();
            if (!1 === t)
                return ut && ut.kill();
            var e = t instanceof G ? t : an(t);
            return ut && ut.target === e.target && ut.kill(),
            It(e.target) && (ut = e),
            e
        }
        ,
        Ke.core = {
            _getVelocityProp: O,
            _inputObserver: nn,
            _scrollers: x,
            _proxies: b,
            bridge: {
                ss: function() {
                    St || Le("scrollStart"),
                    St = Mt()
                },
                ref: function() {
                    return tt
                }
            }
        },
        Dt() && H.registerPlugin(Ke)
    },
    5553: function(t, e, n) {
        n.d(e, {
            ZP: function() {
                return s
            }
        });
        var r = n(5317)
          , i = n(9975)
          , s = r.ZP.registerPlugin(i.ZP) || r.ZP;
        s.core.Tween
    },
    5317: function(t, e, n) {
        function r(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }
        function i(t, e) {
            t.prototype = Object.create(e.prototype),
            t.prototype.constructor = t,
            t.__proto__ = e
        }
        n.d(e, {
            $i: function() {
                return at
            },
            DY: function() {
                return dt
            },
            Fc: function() {
                return x
            },
            Fo: function() {
                return fn
            },
            GN: function() {
                return Me
            },
            JV: function() {
                return dn
            },
            Ks: function() {
                return on
            },
            Ok: function() {
                return ft
            },
            Pr: function() {
                return mt
            },
            S5: function() {
                return rn
            },
            SI: function() {
                return G
            },
            UI: function() {
                return he
            },
            Wy: function() {
                return $t
            },
            ZP: function() {
                return Sn
            },
            bQ: function() {
                return W
            },
            cy: function() {
                return vt
            },
            d4: function() {
                return H
            },
            fS: function() {
                return pt
            },
            if: function() {
                return je
            },
            kr: function() {
                return Se
            },
            l1: function() {
                return Be
            },
            lC: function() {
                return K
            },
            m2: function() {
                return I
            },
            p8: function() {
                return Sn
            },
            r9: function() {
                return P
            },
            tQ: function() {
                return En
            },
            xr: function() {
                return Ee
            }
        });
        var s, a, o, l, c, u, h, d, f, p, m, g, v, _, y, x = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, b = {
            duration: .5,
            overwrite: !1,
            delay: 0
        }, w = 1e8, M = 1 / w, T = 2 * Math.PI, S = T / 4, E = 0, A = Math.sqrt, R = Math.cos, L = Math.sin, P = function(t) {
            return "string" == typeof t
        }, C = function(t) {
            return "function" == typeof t
        }, D = function(t) {
            return "number" == typeof t
        }, I = function(t) {
            return void 0 === t
        }, N = function(t) {
            return "object" == typeof t
        }, F = function(t) {
            return !1 !== t
        }, O = function() {
            return "undefined" != typeof window
        }, U = function(t) {
            return C(t) || P(t)
        }, z = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
        , B = Array.isArray, k = /(?:-?\.?\d|\.)+/gi, G = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, H = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, V = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, W = /[+-]=-?[.\d]+/, X = /[^,'"\[\]\s]+/gi, j = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Y = {}, q = {}, Z = function(t) {
            return (q = Tt(t, Y)) && Sn
        }, K = function(t, e) {
            return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
        }, J = function(t, e) {
            return !e && console.warn(t)
        }, Q = function(t, e) {
            return t && (Y[t] = e) && q && (q[t] = e) || Y
        }, $ = function() {
            return 0
        }, tt = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        }, et = {
            suppressEvents: !0,
            kill: !1
        }, nt = {
            suppressEvents: !0
        }, rt = {}, it = [], st = {}, at = {}, ot = {}, lt = 30, ct = [], ut = "", ht = function(t) {
            var e, n, r = t[0];
            if (N(r) || C(r) || (t = [t]),
            !(e = (r._gsap || {}).harness)) {
                for (n = ct.length; n-- && !ct[n].targetTest(r); )
                    ;
                e = ct[n]
            }
            for (n = t.length; n--; )
                t[n] && (t[n]._gsap || (t[n]._gsap = new Be(t[n],e))) || t.splice(n, 1);
            return t
        }, dt = function(t) {
            return t._gsap || ht(re(t))[0]._gsap
        }, ft = function(t, e, n) {
            return (n = t[e]) && C(n) ? t[e]() : I(n) && t.getAttribute && t.getAttribute(e) || n
        }, pt = function(t, e) {
            return (t = t.split(",")).forEach(e) || t
        }, mt = function(t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }, gt = function(t) {
            return Math.round(1e7 * t) / 1e7 || 0
        }, vt = function(t, e) {
            var n = e.charAt(0)
              , r = parseFloat(e.substr(2));
            return t = parseFloat(t),
            "+" === n ? t + r : "-" === n ? t - r : "*" === n ? t * r : t / r
        }, _t = function(t, e) {
            for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n; )
                ;
            return r < n
        }, yt = function() {
            var t, e, n = it.length, r = it.slice(0);
            for (st = {},
            it.length = 0,
            t = 0; t < n; t++)
                (e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        }, xt = function(t, e, n, r) {
            it.length && !a && yt(),
            t.render(e, n, r || a && e < 0 && (t._initted || t._startAt)),
            it.length && !a && yt()
        }, bt = function(t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(X).length < 2 ? e : P(t) ? t.trim() : t
        }, wt = function(t) {
            return t
        }, Mt = function(t, e) {
            for (var n in e)
                n in t || (t[n] = e[n]);
            return t
        }, Tt = function(t, e) {
            for (var n in e)
                t[n] = e[n];
            return t
        }, St = function t(e, n) {
            for (var r in n)
                "__proto__" !== r && "constructor" !== r && "prototype" !== r && (e[r] = N(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r]);
            return e
        }, Et = function(t, e) {
            var n, r = {};
            for (n in t)
                n in e || (r[n] = t[n]);
            return r
        }, At = function(t) {
            var e, n = t.parent || l, r = t.keyframes ? (e = B(t.keyframes),
            function(t, n) {
                for (var r in n)
                    r in t || "duration" === r && e || "ease" === r || (t[r] = n[r])
            }
            ) : Mt;
            if (F(t.inherit))
                for (; n; )
                    r(t, n.vars.defaults),
                    n = n.parent || n._dp;
            return t
        }, Rt = function(t, e, n, r, i) {
            void 0 === n && (n = "_first"),
            void 0 === r && (r = "_last");
            var s, a = t[r];
            if (i)
                for (s = e[i]; a && a[i] > s; )
                    a = a._prev;
            return a ? (e._next = a._next,
            a._next = e) : (e._next = t[n],
            t[n] = e),
            e._next ? e._next._prev = e : t[r] = e,
            e._prev = a,
            e.parent = e._dp = t,
            e
        }, Lt = function(t, e, n, r) {
            void 0 === n && (n = "_first"),
            void 0 === r && (r = "_last");
            var i = e._prev
              , s = e._next;
            i ? i._next = s : t[n] === e && (t[n] = s),
            s ? s._prev = i : t[r] === e && (t[r] = i),
            e._next = e._prev = e.parent = null
        }, Pt = function(t, e) {
            t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
            t._act = 0
        }, Ct = function(t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0))
                for (var n = t; n; )
                    n._dirty = 1,
                    n = n.parent;
            return t
        }, Dt = function(t) {
            for (var e = t.parent; e && e.parent; )
                e._dirty = 1,
                e.totalDuration(),
                e = e.parent;
            return t
        }, It = function(t, e, n, r) {
            return t._startAt && (a ? t._startAt.revert(et) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r))
        }, Nt = function t(e) {
            return !e || e._ts && t(e.parent)
        }, Ft = function(t) {
            return t._repeat ? Ot(t._tTime, t = t.duration() + t._rDelay) * t : 0
        }, Ot = function(t, e) {
            var n = Math.floor(t /= e);
            return t && n === t ? n - 1 : n
        }, Ut = function(t, e) {
            return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        }, zt = function(t) {
            return t._end = gt(t._start + (t._tDur / Math.abs(t._ts || t._rts || M) || 0))
        }, Bt = function(t, e) {
            var n = t._dp;
            return n && n.smoothChildTiming && t._ts && (t._start = gt(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
            zt(t),
            n._dirty || Ct(n, t)),
            t
        }, kt = function(t, e) {
            var n;
            if ((e._time || e._initted && !e._dur) && (n = Ut(t.rawTime(), e),
            (!e._dur || Qt(0, e.totalDuration(), n) - e._tTime > M) && e.render(n, !0)),
            Ct(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration())
                    for (n = t; n._dp; )
                        n.rawTime() >= 0 && n.totalTime(n._tTime),
                        n = n._dp;
                t._zTime = -M
            }
        }, Gt = function(t, e, n, r) {
            return e.parent && Pt(e),
            e._start = gt((D(n) ? n : n || t !== l ? Zt(t, n, e) : t._time) + e._delay),
            e._end = gt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
            Rt(t, e, "_first", "_last", t._sort ? "_start" : 0),
            Xt(e) || (t._recent = e),
            r || kt(t, e),
            t._ts < 0 && Bt(t, t._tTime),
            t
        }, Ht = function(t, e) {
            return (Y.ScrollTrigger || K("scrollTrigger", e)) && Y.ScrollTrigger.create(e, t)
        }, Vt = function(t, e, n, r, i) {
            return Ye(t, e, i),
            t._initted ? !n && t._pt && !a && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== Ee.frame ? (it.push(t),
            t._lazy = [i, r],
            1) : void 0 : 1
        }, Wt = function t(e) {
            var n = e.parent;
            return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
        }, Xt = function(t) {
            var e = t.data;
            return "isFromStart" === e || "isStart" === e
        }, jt = function(t, e, n, r) {
            var i = t._repeat
              , s = gt(e) || 0
              , a = t._tTime / t._tDur;
            return a && !r && (t._time *= s / t._dur),
            t._dur = s,
            t._tDur = i ? i < 0 ? 1e10 : gt(s * (i + 1) + t._rDelay * i) : s,
            a > 0 && !r && Bt(t, t._tTime = t._tDur * a),
            t.parent && zt(t),
            n || Ct(t.parent, t),
            t
        }, Yt = function(t) {
            return t instanceof Ge ? Ct(t) : jt(t, t._dur)
        }, qt = {
            _start: 0,
            endTime: $,
            totalDuration: $
        }, Zt = function t(e, n, r) {
            var i, s, a, o = e.labels, l = e._recent || qt, c = e.duration() >= w ? l.endTime(!1) : e._dur;
            return P(n) && (isNaN(n) || n in o) ? (s = n.charAt(0),
            a = "%" === n.substr(-1),
            i = n.indexOf("="),
            "<" === s || ">" === s ? (i >= 0 && (n = n.replace(/=/, "")),
            ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (i < 0 ? l : r).totalDuration() / 100 : 1)) : i < 0 ? (n in o || (o[n] = c),
            o[n]) : (s = parseFloat(n.charAt(i - 1) + n.substr(i + 1)),
            a && r && (s = s / 100 * (B(r) ? r[0] : r).totalDuration()),
            i > 1 ? t(e, n.substr(0, i - 1), r) + s : c + s)) : null == n ? c : +n
        }, Kt = function(t, e, n) {
            var r, i, s = D(e[1]), a = (s ? 2 : 1) + (t < 2 ? 0 : 1), o = e[a];
            if (s && (o.duration = e[1]),
            o.parent = n,
            t) {
                for (r = o,
                i = n; i && !("immediateRender"in r); )
                    r = i.vars.defaults || {},
                    i = F(i.vars.inherit) && i.parent;
                o.immediateRender = F(r.immediateRender),
                t < 2 ? o.runBackwards = 1 : o.startAt = e[a - 1]
            }
            return new Qe(e[0],o,e[a + 1])
        }, Jt = function(t, e) {
            return t || 0 === t ? e(t) : e
        }, Qt = function(t, e, n) {
            return n < t ? t : n > e ? e : n
        }, $t = function(t, e) {
            return P(t) && (e = j.exec(t)) ? e[1] : ""
        }, te = [].slice, ee = function(t, e) {
            return t && N(t) && "length"in t && (!e && !t.length || t.length - 1 in t && N(t[0])) && !t.nodeType && t !== c
        }, ne = function(t, e, n) {
            return void 0 === n && (n = []),
            t.forEach((function(t) {
                var r;
                return P(t) && !e || ee(t, 1) ? (r = n).push.apply(r, re(t)) : n.push(t)
            }
            )) || n
        }, re = function(t, e, n) {
            return o && !e && o.selector ? o.selector(t) : !P(t) || n || !u && Ae() ? B(t) ? ne(t, n) : ee(t) ? te.call(t, 0) : t ? [t] : [] : te.call((e || h).querySelectorAll(t), 0)
        }, ie = function(t) {
            return t = re(t)[0] || J("Invalid scope") || {},
            function(e) {
                var n = t.current || t.nativeElement || t;
                return re(e, n.querySelectorAll ? n : n === t ? J("Invalid scope") || h.createElement("div") : t)
            }
        }, se = function(t) {
            return t.sort((function() {
                return .5 - Math.random()
            }
            ))
        }, ae = function(t) {
            if (C(t))
                return t;
            var e = N(t) ? t : {
                each: t
            }
              , n = Ne(e.ease)
              , r = e.from || 0
              , i = parseFloat(e.base) || 0
              , s = {}
              , a = r > 0 && r < 1
              , o = isNaN(r) || a
              , l = e.axis
              , c = r
              , u = r;
            return P(r) ? c = u = {
                center: .5,
                edges: .5,
                end: 1
            }[r] || 0 : !a && o && (c = r[0],
            u = r[1]),
            function(t, a, h) {
                var d, f, p, m, g, v, _, y, x, b = (h || e).length, M = s[b];
                if (!M) {
                    if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, w])[1])) {
                        for (_ = -w; _ < (_ = h[x++].getBoundingClientRect().left) && x < b; )
                            ;
                        x--
                    }
                    for (M = s[b] = [],
                    d = o ? Math.min(x, b) * c - .5 : r % x,
                    f = x === w ? 0 : o ? b * u / x - .5 : r / x | 0,
                    _ = 0,
                    y = w,
                    v = 0; v < b; v++)
                        p = v % x - d,
                        m = f - (v / x | 0),
                        M[v] = g = l ? Math.abs("y" === l ? m : p) : A(p * p + m * m),
                        g > _ && (_ = g),
                        g < y && (y = g);
                    "random" === r && se(M),
                    M.max = _ - y,
                    M.min = y,
                    M.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === r ? -1 : 1),
                    M.b = b < 0 ? i - b : i,
                    M.u = $t(e.amount || e.each) || 0,
                    n = n && b < 0 ? De(n) : n
                }
                return b = (M[t] - M.min) / M.max || 0,
                gt(M.b + (n ? n(b) : b) * M.v) + M.u
            }
        }, oe = function(t) {
            var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
            return function(n) {
                var r = gt(Math.round(parseFloat(n) / t) * t * e);
                return (r - r % 1) / e + (D(n) ? 0 : $t(n))
            }
        }, le = function(t, e) {
            var n, r, i = B(t);
            return !i && N(t) && (n = i = t.radius || w,
            t.values ? (t = re(t.values),
            (r = !D(t[0])) && (n *= n)) : t = oe(t.increment)),
            Jt(e, i ? C(t) ? function(e) {
                return r = t(e),
                Math.abs(r - e) <= n ? r : e
            }
            : function(e) {
                for (var i, s, a = parseFloat(r ? e.x : e), o = parseFloat(r ? e.y : 0), l = w, c = 0, u = t.length; u--; )
                    (i = r ? (i = t[u].x - a) * i + (s = t[u].y - o) * s : Math.abs(t[u] - a)) < l && (l = i,
                    c = u);
                return c = !n || l <= n ? t[c] : e,
                r || c === e || D(e) ? c : c + $t(e)
            }
            : oe(t))
        }, ce = function(t, e, n, r) {
            return Jt(B(t) ? !e : !0 === n ? !!(n = 0) : !r, (function() {
                return B(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r
            }
            ))
        }, ue = function(t, e, n) {
            return Jt(n, (function(n) {
                return t[~~e(n)]
            }
            ))
        }, he = function(t) {
            for (var e, n, r, i, s = 0, a = ""; ~(e = t.indexOf("random(", s)); )
                r = t.indexOf(")", e),
                i = "[" === t.charAt(e + 7),
                n = t.substr(e + 7, r - e - 7).match(i ? X : k),
                a += t.substr(s, e - s) + ce(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5),
                s = r + 1;
            return a + t.substr(s, t.length - s)
        }, de = function(t, e, n, r, i) {
            var s = e - t
              , a = r - n;
            return Jt(i, (function(e) {
                return n + ((e - t) / s * a || 0)
            }
            ))
        }, fe = function(t, e, n) {
            var r, i, s, a = t.labels, o = w;
            for (r in a)
                (i = a[r] - e) < 0 == !!n && i && o > (i = Math.abs(i)) && (s = r,
                o = i);
            return s
        }, pe = function(t, e, n) {
            var r, i, s, a = t.vars, l = a[e], c = o, u = t._ctx;
            if (l)
                return r = a[e + "Params"],
                i = a.callbackScope || t,
                n && it.length && yt(),
                u && (o = u),
                s = r ? l.apply(i, r) : l.call(i),
                o = c,
                s
        }, me = function(t) {
            return Pt(t),
            t.scrollTrigger && t.scrollTrigger.kill(!!a),
            t.progress() < 1 && pe(t, "onInterrupt"),
            t
        }, ge = function(t) {
            var e = (t = !t.name && t.default || t).name
              , n = C(t)
              , r = e && !n && t.init ? function() {
                this._props = []
            }
            : t
              , i = {
                init: $,
                render: ln,
                add: Xe,
                kill: un,
                modifier: cn,
                rawVars: 0
            }
              , s = {
                targetTest: 0,
                get: 0,
                getSetter: rn,
                aliases: {},
                register: 0
            };
            if (Ae(),
            t !== r) {
                if (at[e])
                    return;
                Mt(r, Mt(Et(t, i), s)),
                Tt(r.prototype, Tt(i, Et(t, s))),
                at[r.prop = e] = r,
                t.targetTest && (ct.push(r),
                rt[e] = 1),
                e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
            }
            Q(e, r),
            t.register && t.register(Sn, r, fn)
        }, ve = 255, _e = {
            aqua: [0, ve, ve],
            lime: [0, ve, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, ve],
            navy: [0, 0, 128],
            white: [ve, ve, ve],
            olive: [128, 128, 0],
            yellow: [ve, ve, 0],
            orange: [ve, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [ve, 0, 0],
            pink: [ve, 192, 203],
            cyan: [0, ve, ve],
            transparent: [ve, ve, ve, 0]
        }, ye = function(t, e, n) {
            return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * ve + .5 | 0
        }, xe = function(t, e, n) {
            var r, i, s, a, o, l, c, u, h, d, f = t ? D(t) ? [t >> 16, t >> 8 & ve, t & ve] : 0 : _e.black;
            if (!f) {
                if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
                _e[t])
                    f = _e[t];
                else if ("#" === t.charAt(0)) {
                    if (t.length < 6 && (r = t.charAt(1),
                    i = t.charAt(2),
                    s = t.charAt(3),
                    t = "#" + r + r + i + i + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")),
                    9 === t.length)
                        return [(f = parseInt(t.substr(1, 6), 16)) >> 16, f >> 8 & ve, f & ve, parseInt(t.substr(7), 16) / 255];
                    f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & ve, t & ve]
                } else if ("hsl" === t.substr(0, 3))
                    if (f = d = t.match(k),
                    e) {
                        if (~t.indexOf("="))
                            return f = t.match(G),
                            n && f.length < 4 && (f[3] = 1),
                            f
                    } else
                        a = +f[0] % 360 / 360,
                        o = +f[1] / 100,
                        r = 2 * (l = +f[2] / 100) - (i = l <= .5 ? l * (o + 1) : l + o - l * o),
                        f.length > 3 && (f[3] *= 1),
                        f[0] = ye(a + 1 / 3, r, i),
                        f[1] = ye(a, r, i),
                        f[2] = ye(a - 1 / 3, r, i);
                else
                    f = t.match(k) || _e.transparent;
                f = f.map(Number)
            }
            return e && !d && (r = f[0] / ve,
            i = f[1] / ve,
            s = f[2] / ve,
            l = ((c = Math.max(r, i, s)) + (u = Math.min(r, i, s))) / 2,
            c === u ? a = o = 0 : (h = c - u,
            o = l > .5 ? h / (2 - c - u) : h / (c + u),
            a = c === r ? (i - s) / h + (i < s ? 6 : 0) : c === i ? (s - r) / h + 2 : (r - i) / h + 4,
            a *= 60),
            f[0] = ~~(a + .5),
            f[1] = ~~(100 * o + .5),
            f[2] = ~~(100 * l + .5)),
            n && f.length < 4 && (f[3] = 1),
            f
        }, be = function(t) {
            var e = []
              , n = []
              , r = -1;
            return t.split(Me).forEach((function(t) {
                var i = t.match(H) || [];
                e.push.apply(e, i),
                n.push(r += i.length + 1)
            }
            )),
            e.c = n,
            e
        }, we = function(t, e, n) {
            var r, i, s, a, o = "", l = (t + o).match(Me), c = e ? "hsla(" : "rgba(", u = 0;
            if (!l)
                return t;
            if (l = l.map((function(t) {
                return (t = xe(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
            }
            )),
            n && (s = be(t),
            (r = n.c).join(o) !== s.c.join(o)))
                for (a = (i = t.replace(Me, "1").split(H)).length - 1; u < a; u++)
                    o += i[u] + (~r.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
            if (!i)
                for (a = (i = t.split(Me)).length - 1; u < a; u++)
                    o += i[u] + l[u];
            return o + i[a]
        }, Me = function() {
            var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (t in _e)
                e += "|" + t + "\\b";
            return new RegExp(e + ")","gi")
        }(), Te = /hsl[a]?\(/, Se = function(t) {
            var e, n = t.join(" ");
            if (Me.lastIndex = 0,
            Me.test(n))
                return e = Te.test(n),
                t[1] = we(t[1], e),
                t[0] = we(t[0], e, be(t[1])),
                !0
        }, Ee = function() {
            var t, e, n, r, i, s, a = Date.now, o = 500, l = 33, f = a(), p = f, g = 1e3 / 240, v = g, _ = [], y = function n(c) {
                var u, h, d, m, y = a() - p, x = !0 === c;
                if (y > o && (f += y - l),
                ((u = (d = (p += y) - f) - v) > 0 || x) && (m = ++r.frame,
                i = d - 1e3 * r.time,
                r.time = d /= 1e3,
                v += u + (u >= g ? 4 : g - u),
                h = 1),
                x || (t = e(n)),
                h)
                    for (s = 0; s < _.length; s++)
                        _[s](d, i, m, c)
            };
            return r = {
                time: 0,
                frame: 0,
                tick: function() {
                    y(!0)
                },
                deltaRatio: function(t) {
                    return i / (1e3 / (t || 60))
                },
                wake: function() {
                    d && (!u && O() && (c = u = window,
                    h = c.document || {},
                    Y.gsap = Sn,
                    (c.gsapVersions || (c.gsapVersions = [])).push(Sn.version),
                    Z(q || c.GreenSockGlobals || !c.gsap && c || {}),
                    n = c.requestAnimationFrame),
                    t && r.sleep(),
                    e = n || function(t) {
                        return setTimeout(t, v - 1e3 * r.time + 1 | 0)
                    }
                    ,
                    m = 1,
                    y(2))
                },
                sleep: function() {
                    (n ? c.cancelAnimationFrame : clearTimeout)(t),
                    m = 0,
                    e = $
                },
                lagSmoothing: function(t, e) {
                    o = t || 1 / 0,
                    l = Math.min(e || 33, o)
                },
                fps: function(t) {
                    g = 1e3 / (t || 240),
                    v = 1e3 * r.time + g
                },
                add: function(t, e, n) {
                    var i = e ? function(e, n, s, a) {
                        t(e, n, s, a),
                        r.remove(i)
                    }
                    : t;
                    return r.remove(t),
                    _[n ? "unshift" : "push"](i),
                    Ae(),
                    i
                },
                remove: function(t, e) {
                    ~(e = _.indexOf(t)) && _.splice(e, 1) && s >= e && s--
                },
                _listeners: _
            }
        }(), Ae = function() {
            return !m && Ee.wake()
        }, Re = {}, Le = /^[\d.\-M][\d.\-,\s]/, Pe = /["']/g, Ce = function(t) {
            for (var e, n, r, i = {}, s = t.substr(1, t.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
                n = s[o],
                e = o !== l - 1 ? n.lastIndexOf(",") : n.length,
                r = n.substr(0, e),
                i[a] = isNaN(r) ? r.replace(Pe, "").trim() : +r,
                a = n.substr(e + 1).trim();
            return i
        }, De = function(t) {
            return function(e) {
                return 1 - t(1 - e)
            }
        }, Ie = function t(e, n) {
            for (var r, i = e._first; i; )
                i instanceof Ge ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease,
                i._ease = i._yEase,
                i._yEase = r,
                i._yoyo = n)),
                i = i._next
        }, Ne = function(t, e) {
            return t && (C(t) ? t : Re[t] || function(t) {
                var e, n, r, i, s = (t + "").split("("), a = Re[s[0]];
                return a && s.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [Ce(s[1])] : (e = t,
                n = e.indexOf("(") + 1,
                r = e.indexOf(")"),
                i = e.indexOf("(", n),
                e.substring(n, ~i && i < r ? e.indexOf(")", r + 1) : r)).split(",").map(bt)) : Re._CE && Le.test(t) ? Re._CE("", t) : a
            }(t)) || e
        }, Fe = function(t, e, n, r) {
            void 0 === n && (n = function(t) {
                return 1 - e(1 - t)
            }
            ),
            void 0 === r && (r = function(t) {
                return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            }
            );
            var i, s = {
                easeIn: e,
                easeOut: n,
                easeInOut: r
            };
            return pt(t, (function(t) {
                for (var e in Re[t] = Y[t] = s,
                Re[i = t.toLowerCase()] = n,
                s)
                    Re[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Re[t + "." + e] = s[e]
            }
            )),
            s
        }, Oe = function(t) {
            return function(e) {
                return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
            }
        }, Ue = function t(e, n, r) {
            var i = n >= 1 ? n : 1
              , s = (r || (e ? .3 : .45)) / (n < 1 ? n : 1)
              , a = s / T * (Math.asin(1 / i) || 0)
              , o = function(t) {
                return 1 === t ? 1 : i * Math.pow(2, -10 * t) * L((t - a) * s) + 1
            }
              , l = "out" === e ? o : "in" === e ? function(t) {
                return 1 - o(1 - t)
            }
            : Oe(o);
            return s = T / s,
            l.config = function(n, r) {
                return t(e, n, r)
            }
            ,
            l
        }, ze = function t(e, n) {
            void 0 === n && (n = 1.70158);
            var r = function(t) {
                return t ? --t * t * ((n + 1) * t + n) + 1 : 0
            }
              , i = "out" === e ? r : "in" === e ? function(t) {
                return 1 - r(1 - t)
            }
            : Oe(r);
            return i.config = function(n) {
                return t(e, n)
            }
            ,
            i
        };
        pt("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
            var n = e < 5 ? e + 1 : e;
            Fe(t + ",Power" + (n - 1), e ? function(t) {
                return Math.pow(t, n)
            }
            : function(t) {
                return t
            }
            , (function(t) {
                return 1 - Math.pow(1 - t, n)
            }
            ), (function(t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }
            ))
        }
        )),
        Re.Linear.easeNone = Re.none = Re.Linear.easeIn,
        Fe("Elastic", Ue("in"), Ue("out"), Ue()),
        g = 7.5625,
        _ = 1 / (v = 2.75),
        Fe("Bounce", (function(t) {
            return 1 - y(1 - t)
        }
        ), y = function(t) {
            return t < _ ? g * t * t : t < .7272727272727273 ? g * Math.pow(t - 1.5 / v, 2) + .75 : t < .9090909090909092 ? g * (t -= 2.25 / v) * t + .9375 : g * Math.pow(t - 2.625 / v, 2) + .984375
        }
        ),
        Fe("Expo", (function(t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        }
        )),
        Fe("Circ", (function(t) {
            return -(A(1 - t * t) - 1)
        }
        )),
        Fe("Sine", (function(t) {
            return 1 === t ? 1 : 1 - R(t * S)
        }
        )),
        Fe("Back", ze("in"), ze("out"), ze()),
        Re.SteppedEase = Re.steps = Y.SteppedEase = {
            config: function(t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t
                  , r = t + (e ? 0 : 1)
                  , i = e ? 1 : 0
                  , s = 1 - M;
                return function(t) {
                    return ((r * Qt(0, s, t) | 0) + i) * n
                }
            }
        },
        b.ease = Re["quad.out"],
        pt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
            return ut += t + "," + t + "Params,"
        }
        ));
        var Be = function(t, e) {
            this.id = E++,
            t._gsap = this,
            this.target = t,
            this.harness = e,
            this.get = e ? e.get : ft,
            this.set = e ? e.getSetter : rn
        }
          , ke = function() {
            function t(t) {
                this.vars = t,
                this._delay = +t.delay || 0,
                (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
                this._yoyo = !!t.yoyo || !!t.yoyoEase),
                this._ts = 1,
                jt(this, +t.duration, 1, 1),
                this.data = t.data,
                o && (this._ctx = o,
                o.data.push(this)),
                m || Ee.wake()
            }
            var e = t.prototype;
            return e.delay = function(t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
                this._delay = t,
                this) : this._delay
            }
            ,
            e.duration = function(t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }
            ,
            e.totalDuration = function(t) {
                return arguments.length ? (this._dirty = 0,
                jt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }
            ,
            e.totalTime = function(t, e) {
                if (Ae(),
                !arguments.length)
                    return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (Bt(this, t),
                    !n._dp || n.parent || kt(n, this); n && n.parent; )
                        n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                        n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Gt(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === M || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t),
                xt(this, t, e)),
                this
            }
            ,
            e.time = function(t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Ft(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
            }
            ,
            e.totalProgress = function(t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }
            ,
            e.progress = function(t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Ft(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }
            ,
            e.iteration = function(t, e) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Ot(this._tTime, n) + 1 : 1
            }
            ,
            e.timeScale = function(t) {
                if (!arguments.length)
                    return this._rts === -M ? 0 : this._rts;
                if (this._rts === t)
                    return this;
                var e = this.parent && this._ts ? Ut(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0,
                this._ts = this._ps || t === -M ? 0 : this._rts,
                this.totalTime(Qt(-this._delay, this._tDur, e), !0),
                zt(this),
                Dt(this)
            }
            ,
            e.paused = function(t) {
                return arguments.length ? (this._ps !== t && (this._ps = t,
                t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                this._ts = this._act = 0) : (Ae(),
                this._ts = this._rts,
                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== M && (this._tTime -= M)))),
                this) : this._ps
            }
            ,
            e.startTime = function(t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && Gt(e, this, t - this._delay),
                    this
                }
                return this._start
            }
            ,
            e.endTime = function(t) {
                return this._start + (F(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }
            ,
            e.rawTime = function(t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ut(e.rawTime(t), this) : this._tTime : this._tTime
            }
            ,
            e.revert = function(t) {
                void 0 === t && (t = nt);
                var e = a;
                return a = t,
                (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t),
                this.totalTime(-.01, t.suppressEvents)),
                "nested" !== this.data && !1 !== t.kill && this.kill(),
                a = e,
                this
            }
            ,
            e.globalTime = function(t) {
                for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
                    n = e._start + n / (e._ts || 1),
                    e = e._dp;
                return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(t) : n
            }
            ,
            e.repeat = function(t) {
                return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t,
                Yt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }
            ,
            e.repeatDelay = function(t) {
                if (arguments.length) {
                    var e = this._time;
                    return this._rDelay = t,
                    Yt(this),
                    e ? this.time(e) : this
                }
                return this._rDelay
            }
            ,
            e.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t,
                this) : this._yoyo
            }
            ,
            e.seek = function(t, e) {
                return this.totalTime(Zt(this, t), F(e))
            }
            ,
            e.restart = function(t, e) {
                return this.play().totalTime(t ? -this._delay : 0, F(e))
            }
            ,
            e.play = function(t, e) {
                return null != t && this.seek(t, e),
                this.reversed(!1).paused(!1)
            }
            ,
            e.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e),
                this.reversed(!0).paused(!1)
            }
            ,
            e.pause = function(t, e) {
                return null != t && this.seek(t, e),
                this.paused(!0)
            }
            ,
            e.resume = function() {
                return this.paused(!1)
            }
            ,
            e.reversed = function(t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -M : 0)),
                this) : this._rts < 0
            }
            ,
            e.invalidate = function() {
                return this._initted = this._act = 0,
                this._zTime = -M,
                this
            }
            ,
            e.isActive = function() {
                var t, e = this.parent || this._dp, n = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - M))
            }
            ,
            e.eventCallback = function(t, e, n) {
                var r = this.vars;
                return arguments.length > 1 ? (e ? (r[t] = e,
                n && (r[t + "Params"] = n),
                "onUpdate" === t && (this._onUpdate = e)) : delete r[t],
                this) : r[t]
            }
            ,
            e.then = function(t) {
                var e = this;
                return new Promise((function(n) {
                    var r = C(t) ? t : wt
                      , i = function() {
                        var t = e.then;
                        e.then = null,
                        C(r) && (r = r(e)) && (r.then || r === e) && (e.then = t),
                        n(r),
                        e.then = t
                    };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i
                }
                ))
            }
            ,
            e.kill = function() {
                me(this)
            }
            ,
            t
        }();
        Mt(ke.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -M,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Ge = function(t) {
            function e(e, n) {
                var i;
                return void 0 === e && (e = {}),
                (i = t.call(this, e) || this).labels = {},
                i.smoothChildTiming = !!e.smoothChildTiming,
                i.autoRemoveChildren = !!e.autoRemoveChildren,
                i._sort = F(e.sortChildren),
                l && Gt(e.parent || l, r(i), n),
                e.reversed && i.reverse(),
                e.paused && i.paused(!0),
                e.scrollTrigger && Ht(r(i), e.scrollTrigger),
                i
            }
            i(e, t);
            var n = e.prototype;
            return n.to = function(t, e, n) {
                return Kt(0, arguments, this),
                this
            }
            ,
            n.from = function(t, e, n) {
                return Kt(1, arguments, this),
                this
            }
            ,
            n.fromTo = function(t, e, n, r) {
                return Kt(2, arguments, this),
                this
            }
            ,
            n.set = function(t, e, n) {
                return e.duration = 0,
                e.parent = this,
                At(e).repeatDelay || (e.repeat = 0),
                e.immediateRender = !!e.immediateRender,
                new Qe(t,e,Zt(this, n),1),
                this
            }
            ,
            n.call = function(t, e, n) {
                return Gt(this, Qe.delayedCall(0, t, e), n)
            }
            ,
            n.staggerTo = function(t, e, n, r, i, s, a) {
                return n.duration = e,
                n.stagger = n.stagger || r,
                n.onComplete = s,
                n.onCompleteParams = a,
                n.parent = this,
                new Qe(t,n,Zt(this, i)),
                this
            }
            ,
            n.staggerFrom = function(t, e, n, r, i, s, a) {
                return n.runBackwards = 1,
                At(n).immediateRender = F(n.immediateRender),
                this.staggerTo(t, e, n, r, i, s, a)
            }
            ,
            n.staggerFromTo = function(t, e, n, r, i, s, a, o) {
                return r.startAt = n,
                At(r).immediateRender = F(r.immediateRender),
                this.staggerTo(t, e, r, i, s, a, o)
            }
            ,
            n.render = function(t, e, n) {
                var r, i, s, o, c, u, h, d, f, p, m, g, v = this._time, _ = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = t <= 0 ? 0 : gt(t), b = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (this !== l && x > _ && t >= 0 && (x = _),
                x !== this._tTime || n || b) {
                    if (v !== this._time && y && (x += this._time - v,
                    t += this._time - v),
                    r = x,
                    f = this._start,
                    u = !(d = this._ts),
                    b && (y || (v = this._zTime),
                    (t || !e) && (this._zTime = t)),
                    this._repeat) {
                        if (m = this._yoyo,
                        c = y + this._rDelay,
                        this._repeat < -1 && t < 0)
                            return this.totalTime(100 * c + t, e, n);
                        if (r = gt(x % c),
                        x === _ ? (o = this._repeat,
                        r = y) : ((o = ~~(x / c)) && o === x / c && (r = y,
                        o--),
                        r > y && (r = y)),
                        p = Ot(this._tTime, c),
                        !v && this._tTime && p !== o && (p = o),
                        m && 1 & o && (r = y - r,
                        g = 1),
                        o !== p && !this._lock) {
                            var w = m && 1 & p
                              , T = w === (m && 1 & o);
                            if (o < p && (w = !w),
                            v = w ? 0 : y,
                            this._lock = 1,
                            this.render(v || (g ? 0 : gt(o * c)), e, !y)._lock = 0,
                            this._tTime = x,
                            !e && this.parent && pe(this, "onRepeat"),
                            this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1),
                            v && v !== this._time || u !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                return this;
                            if (y = this._dur,
                            _ = this._tDur,
                            T && (this._lock = 2,
                            v = w ? y : -1e-4,
                            this.render(v, !0),
                            this.vars.repeatRefresh && !g && this.invalidate()),
                            this._lock = 0,
                            !this._ts && !u)
                                return this;
                            Ie(this, g)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(t, e, n) {
                        var r;
                        if (n > e)
                            for (r = t._first; r && r._start <= n; ) {
                                if ("isPause" === r.data && r._start > e)
                                    return r;
                                r = r._next
                            }
                        else
                            for (r = t._last; r && r._start >= n; ) {
                                if ("isPause" === r.data && r._start < e)
                                    return r;
                                r = r._prev
                            }
                    }(this, gt(v), gt(r)),
                    h && (x -= r - (r = h._start))),
                    this._tTime = x,
                    this._time = r,
                    this._act = !d,
                    this._initted || (this._onUpdate = this.vars.onUpdate,
                    this._initted = 1,
                    this._zTime = t,
                    v = 0),
                    !v && r && !e && (pe(this, "onStart"),
                    this._tTime !== x))
                        return this;
                    if (r >= v && t >= 0)
                        for (i = this._first; i; ) {
                            if (s = i._next,
                            (i._act || r >= i._start) && i._ts && h !== i) {
                                if (i.parent !== this)
                                    return this.render(t, e, n);
                                if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n),
                                r !== this._time || !this._ts && !u) {
                                    h = 0,
                                    s && (x += this._zTime = -M);
                                    break
                                }
                            }
                            i = s
                        }
                    else {
                        i = this._last;
                        for (var S = t < 0 ? t : r; i; ) {
                            if (s = i._prev,
                            (i._act || S <= i._end) && i._ts && h !== i) {
                                if (i.parent !== this)
                                    return this.render(t, e, n);
                                if (i.render(i._ts > 0 ? (S - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (S - i._start) * i._ts, e, n || a && (i._initted || i._startAt)),
                                r !== this._time || !this._ts && !u) {
                                    h = 0,
                                    s && (x += this._zTime = S ? -M : M);
                                    break
                                }
                            }
                            i = s
                        }
                    }
                    if (h && !e && (this.pause(),
                    h.render(r >= v ? 0 : -M)._zTime = r >= v ? 1 : -1,
                    this._ts))
                        return this._start = f,
                        zt(this),
                        this.render(t, e, n);
                    this._onUpdate && !e && pe(this, "onUpdate", !0),
                    (x === _ && this._tTime >= this.totalDuration() || !x && v) && (f !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((t || !y) && (x === _ && this._ts > 0 || !x && this._ts < 0) && Pt(this, 1),
                    e || t < 0 && !v || !x && !v && _ || (pe(this, x === _ && t >= 0 ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(x < _ && this.timeScale() > 0) && this._prom())))
                }
                return this
            }
            ,
            n.add = function(t, e) {
                var n = this;
                if (D(e) || (e = Zt(this, e, t)),
                !(t instanceof ke)) {
                    if (B(t))
                        return t.forEach((function(t) {
                            return n.add(t, e)
                        }
                        )),
                        this;
                    if (P(t))
                        return this.addLabel(t, e);
                    if (!C(t))
                        return this;
                    t = Qe.delayedCall(0, t)
                }
                return this !== t ? Gt(this, t, e) : this
            }
            ,
            n.getChildren = function(t, e, n, r) {
                void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                void 0 === n && (n = !0),
                void 0 === r && (r = -w);
                for (var i = [], s = this._first; s; )
                    s._start >= r && (s instanceof Qe ? e && i.push(s) : (n && i.push(s),
                    t && i.push.apply(i, s.getChildren(!0, e, n)))),
                    s = s._next;
                return i
            }
            ,
            n.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
                    if (e[n].vars.id === t)
                        return e[n]
            }
            ,
            n.remove = function(t) {
                return P(t) ? this.removeLabel(t) : C(t) ? this.killTweensOf(t) : (Lt(this, t),
                t === this._recent && (this._recent = this._last),
                Ct(this))
            }
            ,
            n.totalTime = function(e, n) {
                return arguments.length ? (this._forcing = 1,
                !this._dp && this._ts && (this._start = gt(Ee.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))),
                t.prototype.totalTime.call(this, e, n),
                this._forcing = 0,
                this) : this._tTime
            }
            ,
            n.addLabel = function(t, e) {
                return this.labels[t] = Zt(this, e),
                this
            }
            ,
            n.removeLabel = function(t) {
                return delete this.labels[t],
                this
            }
            ,
            n.addPause = function(t, e, n) {
                var r = Qe.delayedCall(0, e || $, n);
                return r.data = "isPause",
                this._hasPause = 1,
                Gt(this, r, Zt(this, t))
            }
            ,
            n.removePause = function(t) {
                var e = this._first;
                for (t = Zt(this, t); e; )
                    e._start === t && "isPause" === e.data && Pt(e),
                    e = e._next
            }
            ,
            n.killTweensOf = function(t, e, n) {
                for (var r = this.getTweensOf(t, n), i = r.length; i--; )
                    He !== r[i] && r[i].kill(t, e);
                return this
            }
            ,
            n.getTweensOf = function(t, e) {
                for (var n, r = [], i = re(t), s = this._first, a = D(e); s; )
                    s instanceof Qe ? _t(s._targets, i) && (a ? (!He || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && r.push(s) : (n = s.getTweensOf(i, e)).length && r.push.apply(r, n),
                    s = s._next;
                return r
            }
            ,
            n.tweenTo = function(t, e) {
                e = e || {};
                var n, r = this, i = Zt(r, t), s = e, a = s.startAt, o = s.onStart, l = s.onStartParams, c = s.immediateRender, u = Qe.to(r, Mt({
                    ease: e.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: i,
                    overwrite: "auto",
                    duration: e.duration || Math.abs((i - (a && "time"in a ? a.time : r._time)) / r.timeScale()) || M,
                    onStart: function() {
                        if (r.pause(),
                        !n) {
                            var t = e.duration || Math.abs((i - (a && "time"in a ? a.time : r._time)) / r.timeScale());
                            u._dur !== t && jt(u, t, 0, 1).render(u._time, !0, !0),
                            n = 1
                        }
                        o && o.apply(u, l || [])
                    }
                }, e));
                return c ? u.render(0) : u
            }
            ,
            n.tweenFromTo = function(t, e, n) {
                return this.tweenTo(e, Mt({
                    startAt: {
                        time: Zt(this, t)
                    }
                }, n))
            }
            ,
            n.recent = function() {
                return this._recent
            }
            ,
            n.nextLabel = function(t) {
                return void 0 === t && (t = this._time),
                fe(this, Zt(this, t))
            }
            ,
            n.previousLabel = function(t) {
                return void 0 === t && (t = this._time),
                fe(this, Zt(this, t), 1)
            }
            ,
            n.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + M)
            }
            ,
            n.shiftChildren = function(t, e, n) {
                void 0 === n && (n = 0);
                for (var r, i = this._first, s = this.labels; i; )
                    i._start >= n && (i._start += t,
                    i._end += t),
                    i = i._next;
                if (e)
                    for (r in s)
                        s[r] >= n && (s[r] += t);
                return Ct(this)
            }
            ,
            n.invalidate = function(e) {
                var n = this._first;
                for (this._lock = 0; n; )
                    n.invalidate(e),
                    n = n._next;
                return t.prototype.invalidate.call(this, e)
            }
            ,
            n.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n; )
                    e = n._next,
                    this.remove(n),
                    n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0),
                t && (this.labels = {}),
                Ct(this)
            }
            ,
            n.totalDuration = function(t) {
                var e, n, r, i = 0, s = this, a = s._last, o = w;
                if (arguments.length)
                    return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
                if (s._dirty) {
                    for (r = s.parent; a; )
                        e = a._prev,
                        a._dirty && a.totalDuration(),
                        (n = a._start) > o && s._sort && a._ts && !s._lock ? (s._lock = 1,
                        Gt(s, a, n - a._delay, 1)._lock = 0) : o = n,
                        n < 0 && a._ts && (i -= n,
                        (!r && !s._dp || r && r.smoothChildTiming) && (s._start += n / s._ts,
                        s._time -= n,
                        s._tTime -= n),
                        s.shiftChildren(-n, !1, -Infinity),
                        o = 0),
                        a._end > i && a._ts && (i = a._end),
                        a = e;
                    jt(s, s === l && s._time > i ? s._time : i, 1, 1),
                    s._dirty = 0
                }
                return s._tDur
            }
            ,
            e.updateRoot = function(t) {
                if (l._ts && (xt(l, Ut(t, l)),
                f = Ee.frame),
                Ee.frame >= lt) {
                    lt += x.autoSleep || 120;
                    var e = l._first;
                    if ((!e || !e._ts) && x.autoSleep && Ee._listeners.length < 2) {
                        for (; e && !e._ts; )
                            e = e._next;
                        e || Ee.sleep()
                    }
                }
            }
            ,
            e
        }(ke);
        Mt(Ge.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var He, Ve, We = function(t, e, n, r, i, s, a) {
            var o, l, c, u, h, d, f, p, m = new fn(this._pt,t,e,0,1,on,null,i), g = 0, v = 0;
            for (m.b = n,
            m.e = r,
            n += "",
            (f = ~(r += "").indexOf("random(")) && (r = he(r)),
            s && (s(p = [n, r], t, e),
            n = p[0],
            r = p[1]),
            l = n.match(V) || []; o = V.exec(r); )
                u = o[0],
                h = r.substring(g, o.index),
                c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1),
                u !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
                m._pt = {
                    _next: m._pt,
                    p: h || 1 === v ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? vt(d, u) - d : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                },
                g = V.lastIndex);
            return m.c = g < r.length ? r.substring(g, r.length) : "",
            m.fp = a,
            (W.test(r) || f) && (m.e = 0),
            this._pt = m,
            m
        }, Xe = function(t, e, n, r, i, s, a, o, l, c) {
            C(r) && (r = r(i || 0, t, s));
            var u, h = t[e], d = "get" !== n ? n : C(h) ? l ? t[e.indexOf("set") || !C(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h, f = C(h) ? l ? en : tn : $e;
            if (P(r) && (~r.indexOf("random(") && (r = he(r)),
            "=" === r.charAt(1) && ((u = vt(d, r) + ($t(d) || 0)) || 0 === u) && (r = u)),
            !c || d !== r || Ve)
                return isNaN(d * r) || "" === r ? (!h && !(e in t) && K(e, r),
                We.call(this, t, e, d, r, f, o || x.stringFilter, l)) : (u = new fn(this._pt,t,e,+d || 0,r - (d || 0),"boolean" == typeof h ? an : sn,0,f),
                l && (u.fp = l),
                a && u.modifier(a, this, t),
                this._pt = u)
        }, je = function(t, e, n, r, i, s) {
            var a, o, l, c;
            if (at[t] && !1 !== (a = new at[t]).init(i, a.rawVars ? e[t] : function(t, e, n, r, i) {
                if (C(t) && (t = Ze(t, i, e, n, r)),
                !N(t) || t.style && t.nodeType || B(t) || z(t))
                    return P(t) ? Ze(t, i, e, n, r) : t;
                var s, a = {};
                for (s in t)
                    a[s] = Ze(t[s], i, e, n, r);
                return a
            }(e[t], r, i, s, n), n, r, s) && (n._pt = o = new fn(n._pt,i,t,0,1,a.render,a,0,a.priority),
            n !== p))
                for (l = n._ptLookup[n._targets.indexOf(i)],
                c = a._props.length; c--; )
                    l[a._props[c]] = o;
            return a
        }, Ye = function t(e, n, r) {
            var i, o, c, u, h, d, f, p, m, g, v, _, y, x = e.vars, T = x.ease, S = x.startAt, E = x.immediateRender, A = x.lazy, R = x.onUpdate, L = x.onUpdateParams, P = x.callbackScope, C = x.runBackwards, D = x.yoyoEase, I = x.keyframes, N = x.autoRevert, O = e._dur, U = e._startAt, z = e._targets, B = e.parent, k = B && "nested" === B.data ? B.vars.targets : z, G = "auto" === e._overwrite && !s, H = e.timeline;
            if (H && (!I || !T) && (T = "none"),
            e._ease = Ne(T, b.ease),
            e._yEase = D ? De(Ne(!0 === D ? T : D, b.ease)) : 0,
            D && e._yoyo && !e._repeat && (D = e._yEase,
            e._yEase = e._ease,
            e._ease = D),
            e._from = !H && !!x.runBackwards,
            !H || I && !x.stagger) {
                if (_ = (p = z[0] ? dt(z[0]).harness : 0) && x[p.prop],
                i = Et(x, rt),
                U && (U._zTime < 0 && U.progress(1),
                n < 0 && C && E && !N ? U.render(-1, !0) : U.revert(C && O ? et : tt),
                U._lazy = 0),
                S) {
                    if (Pt(e._startAt = Qe.set(z, Mt({
                        data: "isStart",
                        overwrite: !1,
                        parent: B,
                        immediateRender: !0,
                        lazy: !U && F(A),
                        startAt: null,
                        delay: 0,
                        onUpdate: R,
                        onUpdateParams: L,
                        callbackScope: P,
                        stagger: 0
                    }, S))),
                    e._startAt._dp = 0,
                    e._startAt._sat = e,
                    n < 0 && (a || !E && !N) && e._startAt.revert(et),
                    E && O && n <= 0 && r <= 0)
                        return void (n && (e._zTime = n))
                } else if (C && O && !U)
                    if (n && (E = !1),
                    c = Mt({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: E && !U && F(A),
                        immediateRender: E,
                        stagger: 0,
                        parent: B
                    }, i),
                    _ && (c[p.prop] = _),
                    Pt(e._startAt = Qe.set(z, c)),
                    e._startAt._dp = 0,
                    e._startAt._sat = e,
                    n < 0 && (a ? e._startAt.revert(et) : e._startAt.render(-1, !0)),
                    e._zTime = n,
                    E) {
                        if (!n)
                            return
                    } else
                        t(e._startAt, M, M);
                for (e._pt = e._ptCache = 0,
                A = O && F(A) || A && !O,
                o = 0; o < z.length; o++) {
                    if (f = (h = z[o])._gsap || ht(z)[o]._gsap,
                    e._ptLookup[o] = g = {},
                    st[f.id] && it.length && yt(),
                    v = k === z ? o : k.indexOf(h),
                    p && !1 !== (m = new p).init(h, _ || i, e, v, k) && (e._pt = u = new fn(e._pt,h,m.name,0,1,m.render,m,0,m.priority),
                    m._props.forEach((function(t) {
                        g[t] = u
                    }
                    )),
                    m.priority && (d = 1)),
                    !p || _)
                        for (c in i)
                            at[c] && (m = je(c, i, e, v, h, k)) ? m.priority && (d = 1) : g[c] = u = Xe.call(e, h, c, "get", i[c], v, k, 0, x.stringFilter);
                    e._op && e._op[o] && e.kill(h, e._op[o]),
                    G && e._pt && (He = e,
                    l.killTweensOf(h, g, e.globalTime(n)),
                    y = !e.parent,
                    He = 0),
                    e._pt && A && (st[f.id] = 1)
                }
                d && dn(e),
                e._onInit && e._onInit(e)
            }
            e._onUpdate = R,
            e._initted = (!e._op || e._pt) && !y,
            I && n <= 0 && H.render(w, !0, !0)
        }, qe = function(t, e, n, r) {
            var i, s, a = e.ease || r || "power1.inOut";
            if (B(e))
                s = n[t] || (n[t] = []),
                e.forEach((function(t, n) {
                    return s.push({
                        t: n / (e.length - 1) * 100,
                        v: t,
                        e: a
                    })
                }
                ));
            else
                for (i in e)
                    s = n[i] || (n[i] = []),
                    "ease" === i || s.push({
                        t: parseFloat(t),
                        v: e[i],
                        e: a
                    })
        }, Ze = function(t, e, n, r, i) {
            return C(t) ? t.call(e, n, r, i) : P(t) && ~t.indexOf("random(") ? he(t) : t
        }, Ke = ut + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Je = {};
        pt(Ke + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
            return Je[t] = 1
        }
        ));
        var Qe = function(t) {
            function e(e, n, i, a) {
                var o;
                "number" == typeof n && (i.duration = n,
                n = i,
                i = null);
                var c, u, h, d, f, p, m, g, v = (o = t.call(this, a ? n : At(n)) || this).vars, _ = v.duration, y = v.delay, b = v.immediateRender, w = v.stagger, T = v.overwrite, S = v.keyframes, E = v.defaults, A = v.scrollTrigger, R = v.yoyoEase, L = n.parent || l, P = (B(e) || z(e) ? D(e[0]) : "length"in n) ? [e] : re(e);
                if (o._targets = P.length ? ht(P) : J("GSAP target " + e + " not found. https://greensock.com", !x.nullTargetWarn) || [],
                o._ptLookup = [],
                o._overwrite = T,
                S || w || U(_) || U(y)) {
                    if (n = o.vars,
                    (c = o.timeline = new Ge({
                        data: "nested",
                        defaults: E || {},
                        targets: L && "nested" === L.data ? L.vars.targets : P
                    })).kill(),
                    c.parent = c._dp = r(o),
                    c._start = 0,
                    w || U(_) || U(y)) {
                        if (d = P.length,
                        m = w && ae(w),
                        N(w))
                            for (f in w)
                                ~Ke.indexOf(f) && (g || (g = {}),
                                g[f] = w[f]);
                        for (u = 0; u < d; u++)
                            (h = Et(n, Je)).stagger = 0,
                            R && (h.yoyoEase = R),
                            g && Tt(h, g),
                            p = P[u],
                            h.duration = +Ze(_, r(o), u, p, P),
                            h.delay = (+Ze(y, r(o), u, p, P) || 0) - o._delay,
                            !w && 1 === d && h.delay && (o._delay = y = h.delay,
                            o._start += y,
                            h.delay = 0),
                            c.to(p, h, m ? m(u, p, P) : 0),
                            c._ease = Re.none;
                        c.duration() ? _ = y = 0 : o.timeline = 0
                    } else if (S) {
                        At(Mt(c.vars.defaults, {
                            ease: "none"
                        })),
                        c._ease = Ne(S.ease || n.ease || "none");
                        var C, I, O, k = 0;
                        if (B(S))
                            S.forEach((function(t) {
                                return c.to(P, t, ">")
                            }
                            )),
                            c.duration();
                        else {
                            for (f in h = {},
                            S)
                                "ease" === f || "easeEach" === f || qe(f, S[f], h, S.easeEach);
                            for (f in h)
                                for (C = h[f].sort((function(t, e) {
                                    return t.t - e.t
                                }
                                )),
                                k = 0,
                                u = 0; u < C.length; u++)
                                    (O = {
                                        ease: (I = C[u]).e,
                                        duration: (I.t - (u ? C[u - 1].t : 0)) / 100 * _
                                    })[f] = I.v,
                                    c.to(P, O, k),
                                    k += O.duration;
                            c.duration() < _ && c.to({}, {
                                duration: _ - c.duration()
                            })
                        }
                    }
                    _ || o.duration(_ = c.duration())
                } else
                    o.timeline = 0;
                return !0 !== T || s || (He = r(o),
                l.killTweensOf(P),
                He = 0),
                Gt(L, r(o), i),
                n.reversed && o.reverse(),
                n.paused && o.paused(!0),
                (b || !_ && !S && o._start === gt(L._time) && F(b) && Nt(r(o)) && "nested" !== L.data) && (o._tTime = -M,
                o.render(Math.max(0, -y) || 0)),
                A && Ht(r(o), A),
                o
            }
            i(e, t);
            var n = e.prototype;
            return n.render = function(t, e, n) {
                var r, i, s, o, l, c, u, h, d, f = this._time, p = this._tDur, m = this._dur, g = t < 0, v = t > p - M && !g ? p : t < M ? 0 : t;
                if (m) {
                    if (v !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                        if (r = v,
                        h = this.timeline,
                        this._repeat) {
                            if (o = m + this._rDelay,
                            this._repeat < -1 && g)
                                return this.totalTime(100 * o + t, e, n);
                            if (r = gt(v % o),
                            v === p ? (s = this._repeat,
                            r = m) : ((s = ~~(v / o)) && s === v / o && (r = m,
                            s--),
                            r > m && (r = m)),
                            (c = this._yoyo && 1 & s) && (d = this._yEase,
                            r = m - r),
                            l = Ot(this._tTime, o),
                            r === f && !n && this._initted)
                                return this._tTime = v,
                                this;
                            s !== l && (h && this._yEase && Ie(h, c),
                            !this.vars.repeatRefresh || c || this._lock || (this._lock = n = 1,
                            this.render(gt(o * s), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (Vt(this, g ? t : r, n, e, v))
                                return this._tTime = 0,
                                this;
                            if (f !== this._time)
                                return this;
                            if (m !== this._dur)
                                return this.render(t, e, n)
                        }
                        if (this._tTime = v,
                        this._time = r,
                        !this._act && this._ts && (this._act = 1,
                        this._lazy = 0),
                        this.ratio = u = (d || this._ease)(r / m),
                        this._from && (this.ratio = u = 1 - u),
                        r && !f && !e && (pe(this, "onStart"),
                        this._tTime !== v))
                            return this;
                        for (i = this._pt; i; )
                            i.r(u, i.d),
                            i = i._next;
                        h && h.render(t < 0 ? t : !r && c ? -M : h._dur * h._ease(r / this._dur), e, n) || this._startAt && (this._zTime = t),
                        this._onUpdate && !e && (g && It(this, t, 0, n),
                        pe(this, "onUpdate")),
                        this._repeat && s !== l && this.vars.onRepeat && !e && this.parent && pe(this, "onRepeat"),
                        v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && It(this, t, 0, !0),
                        (t || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Pt(this, 1),
                        e || g && !f || !(v || f || c) || (pe(this, v === p ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(v < p && this.timeScale() > 0) && this._prom()))
                    }
                } else
                    !function(t, e, n, r) {
                        var i, s, o, l = t.ratio, c = e < 0 || !e && (!t._start && Wt(t) && (t._initted || !Xt(t)) || (t._ts < 0 || t._dp._ts < 0) && !Xt(t)) ? 0 : 1, u = t._rDelay, h = 0;
                        if (u && t._repeat && (h = Qt(0, t._tDur, e),
                        s = Ot(h, u),
                        t._yoyo && 1 & s && (c = 1 - c),
                        s !== Ot(t._tTime, u) && (l = 1 - c,
                        t.vars.repeatRefresh && t._initted && t.invalidate())),
                        c !== l || a || r || t._zTime === M || !e && t._zTime) {
                            if (!t._initted && Vt(t, e, r, n, h))
                                return;
                            for (o = t._zTime,
                            t._zTime = e || (n ? M : 0),
                            n || (n = e && !o),
                            t.ratio = c,
                            t._from && (c = 1 - c),
                            t._time = 0,
                            t._tTime = h,
                            i = t._pt; i; )
                                i.r(c, i.d),
                                i = i._next;
                            e < 0 && It(t, e, 0, !0),
                            t._onUpdate && !n && pe(t, "onUpdate"),
                            h && t._repeat && !n && t.parent && pe(t, "onRepeat"),
                            (e >= t._tDur || e < 0) && t.ratio === c && (c && Pt(t, 1),
                            n || a || (pe(t, c ? "onComplete" : "onReverseComplete", !0),
                            t._prom && t._prom()))
                        } else
                            t._zTime || (t._zTime = e)
                    }(this, t, e, n);
                return this
            }
            ,
            n.targets = function() {
                return this._targets
            }
            ,
            n.invalidate = function(e) {
                return (!e || !this.vars.runBackwards) && (this._startAt = 0),
                this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
                this._ptLookup = [],
                this.timeline && this.timeline.invalidate(e),
                t.prototype.invalidate.call(this, e)
            }
            ,
            n.resetTo = function(t, e, n, r) {
                m || Ee.wake(),
                this._ts || this.play();
                var i = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || Ye(this, i),
                function(t, e, n, r, i, s, a) {
                    var o, l, c, u, h = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                    if (!h)
                        for (h = t._ptCache[e] = [],
                        c = t._ptLookup,
                        u = t._targets.length; u--; ) {
                            if ((o = c[u][e]) && o.d && o.d._pt)
                                for (o = o.d._pt; o && o.p !== e && o.fp !== e; )
                                    o = o._next;
                            if (!o)
                                return Ve = 1,
                                t.vars[e] = "+=0",
                                Ye(t, a),
                                Ve = 0,
                                1;
                            h.push(o)
                        }
                    for (u = h.length; u--; )
                        (o = (l = h[u])._pt || l).s = !r && 0 !== r || i ? o.s + (r || 0) + s * o.c : r,
                        o.c = n - o.s,
                        l.e && (l.e = mt(n) + $t(l.e)),
                        l.b && (l.b = o.s + $t(l.b))
                }(this, t, e, n, r, this._ease(i / this._dur), i) ? this.resetTo(t, e, n, r) : (Bt(this, 0),
                this.parent || Rt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                this.render(0))
            }
            ,
            n.kill = function(t, e) {
                if (void 0 === e && (e = "all"),
                !(t || e && "all" !== e))
                    return this._lazy = this._pt = 0,
                    this.parent ? me(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, He && !0 !== He.vars.overwrite)._first || me(this),
                    this.parent && n !== this.timeline.totalDuration() && jt(this, this._dur * this.timeline._tDur / n, 0, 1),
                    this
                }
                var r, i, s, a, o, l, c, u = this._targets, h = t ? re(t) : u, d = this._ptLookup, f = this._pt;
                if ((!e || "all" === e) && function(t, e) {
                    for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n]; )
                        ;
                    return n < 0
                }(u, h))
                    return "all" === e && (this._pt = 0),
                    me(this);
                for (r = this._op = this._op || [],
                "all" !== e && (P(e) && (o = {},
                pt(e, (function(t) {
                    return o[t] = 1
                }
                )),
                e = o),
                e = function(t, e) {
                    var n, r, i, s, a = t[0] ? dt(t[0]).harness : 0, o = a && a.aliases;
                    if (!o)
                        return e;
                    for (r in n = Tt({}, e),
                    o)
                        if (r in n)
                            for (i = (s = o[r].split(",")).length; i--; )
                                n[s[i]] = n[r];
                    return n
                }(u, e)),
                c = u.length; c--; )
                    if (~h.indexOf(u[c]))
                        for (o in i = d[c],
                        "all" === e ? (r[c] = e,
                        a = i,
                        s = {}) : (s = r[c] = r[c] || {},
                        a = e),
                        a)
                            (l = i && i[o]) && ("kill"in l.d && !0 !== l.d.kill(o) || Lt(this, l, "_pt"),
                            delete i[o]),
                            "all" !== s && (s[o] = 1);
                return this._initted && !this._pt && f && me(this),
                this
            }
            ,
            e.to = function(t, n) {
                return new e(t,n,arguments[2])
            }
            ,
            e.from = function(t, e) {
                return Kt(1, arguments)
            }
            ,
            e.delayedCall = function(t, n, r, i) {
                return new e(n,0,{
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: r,
                    onReverseCompleteParams: r,
                    callbackScope: i
                })
            }
            ,
            e.fromTo = function(t, e, n) {
                return Kt(2, arguments)
            }
            ,
            e.set = function(t, n) {
                return n.duration = 0,
                n.repeatDelay || (n.repeat = 0),
                new e(t,n)
            }
            ,
            e.killTweensOf = function(t, e, n) {
                return l.killTweensOf(t, e, n)
            }
            ,
            e
        }(ke);
        Mt(Qe.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }),
        pt("staggerTo,staggerFrom,staggerFromTo", (function(t) {
            Qe[t] = function() {
                var e = new Ge
                  , n = te.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
                e[t].apply(e, n)
            }
        }
        ));
        var $e = function(t, e, n) {
            return t[e] = n
        }
          , tn = function(t, e, n) {
            return t[e](n)
        }
          , en = function(t, e, n, r) {
            return t[e](r.fp, n)
        }
          , nn = function(t, e, n) {
            return t.setAttribute(e, n)
        }
          , rn = function(t, e) {
            return C(t[e]) ? tn : I(t[e]) && t.setAttribute ? nn : $e
        }
          , sn = function(t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        }
          , an = function(t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        }
          , on = function(t, e) {
            var n = e._pt
              , r = "";
            if (!t && e.b)
                r = e.b;
            else if (1 === t && e.e)
                r = e.e;
            else {
                for (; n; )
                    r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r,
                    n = n._next;
                r += e.c
            }
            e.set(e.t, e.p, r, e)
        }
          , ln = function(t, e) {
            for (var n = e._pt; n; )
                n.r(t, n.d),
                n = n._next
        }
          , cn = function(t, e, n, r) {
            for (var i, s = this._pt; s; )
                i = s._next,
                s.p === r && s.modifier(t, e, n),
                s = i
        }
          , un = function(t) {
            for (var e, n, r = this._pt; r; )
                n = r._next,
                r.p === t && !r.op || r.op === t ? Lt(this, r, "_pt") : r.dep || (e = 1),
                r = n;
            return !e
        }
          , hn = function(t, e, n, r) {
            r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
        }
          , dn = function(t) {
            for (var e, n, r, i, s = t._pt; s; ) {
                for (e = s._next,
                n = r; n && n.pr > s.pr; )
                    n = n._next;
                (s._prev = n ? n._prev : i) ? s._prev._next = s : r = s,
                (s._next = n) ? n._prev = s : i = s,
                s = e
            }
            t._pt = r
        }
          , fn = function() {
            function t(t, e, n, r, i, s, a, o, l) {
                this.t = e,
                this.s = r,
                this.c = i,
                this.p = n,
                this.r = s || sn,
                this.d = a || this,
                this.set = o || $e,
                this.pr = l || 0,
                this._next = t,
                t && (t._prev = this)
            }
            return t.prototype.modifier = function(t, e, n) {
                this.mSet = this.mSet || this.set,
                this.set = hn,
                this.m = t,
                this.mt = n,
                this.tween = e
            }
            ,
            t
        }();
        pt(ut + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
            return rt[t] = 1
        }
        )),
        Y.TweenMax = Y.TweenLite = Qe,
        Y.TimelineLite = Y.TimelineMax = Ge,
        l = new Ge({
            sortChildren: !1,
            defaults: b,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }),
        x.stringFilter = Se;
        var pn = []
          , mn = {}
          , gn = []
          , vn = 0
          , _n = function(t) {
            return (mn[t] || gn).map((function(t) {
                return t()
            }
            ))
        }
          , yn = function() {
            var t = Date.now()
              , e = [];
            t - vn > 2 && (_n("matchMediaInit"),
            pn.forEach((function(t) {
                var n, r, i, s, a = t.queries, o = t.conditions;
                for (r in a)
                    (n = c.matchMedia(a[r]).matches) && (i = 1),
                    n !== o[r] && (o[r] = n,
                    s = 1);
                s && (t.revert(),
                i && e.push(t))
            }
            )),
            _n("matchMediaRevert"),
            e.forEach((function(t) {
                return t.onMatch(t)
            }
            )),
            vn = t,
            _n("matchMedia"))
        }
          , xn = function() {
            function t(t, e) {
                this.selector = e && ie(e),
                this.data = [],
                this._r = [],
                this.isReverted = !1,
                t && this.add(t)
            }
            var e = t.prototype;
            return e.add = function(t, e, n) {
                C(t) && (n = e,
                e = t,
                t = C);
                var r = this
                  , i = function() {
                    var t, i = o, s = r.selector;
                    return i && i !== r && i.data.push(r),
                    n && (r.selector = ie(n)),
                    o = r,
                    t = e.apply(r, arguments),
                    C(t) && r._r.push(t),
                    o = i,
                    r.selector = s,
                    r.isReverted = !1,
                    t
                };
                return r.last = i,
                t === C ? i(r) : t ? r[t] = i : i
            }
            ,
            e.ignore = function(t) {
                var e = o;
                o = null,
                t(this),
                o = e
            }
            ,
            e.getTweens = function() {
                var e = [];
                return this.data.forEach((function(n) {
                    return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof Qe && !(n.parent && "nested" === n.parent.data) && e.push(n)
                }
                )),
                e
            }
            ,
            e.clear = function() {
                this._r.length = this.data.length = 0
            }
            ,
            e.kill = function(t, e) {
                var n = this;
                if (t) {
                    var r = this.getTweens();
                    this.data.forEach((function(t) {
                        "isFlip" === t.data && (t.revert(),
                        t.getChildren(!0, !0, !1).forEach((function(t) {
                            return r.splice(r.indexOf(t), 1)
                        }
                        )))
                    }
                    )),
                    r.map((function(t) {
                        return {
                            g: t.globalTime(0),
                            t: t
                        }
                    }
                    )).sort((function(t, e) {
                        return e.g - t.g || -1
                    }
                    )).forEach((function(e) {
                        return e.t.revert(t)
                    }
                    )),
                    this.data.forEach((function(e) {
                        return !(e instanceof ke) && e.revert && e.revert(t)
                    }
                    )),
                    this._r.forEach((function(e) {
                        return e(t, n)
                    }
                    )),
                    this.isReverted = !0
                } else
                    this.data.forEach((function(t) {
                        return t.kill && t.kill()
                    }
                    ));
                if (this.clear(),
                e) {
                    var i = pn.indexOf(this);
                    ~i && pn.splice(i, 1)
                }
            }
            ,
            e.revert = function(t) {
                this.kill(t || {})
            }
            ,
            t
        }()
          , bn = function() {
            function t(t) {
                this.contexts = [],
                this.scope = t
            }
            var e = t.prototype;
            return e.add = function(t, e, n) {
                N(t) || (t = {
                    matches: t
                });
                var r, i, s, a = new xn(0,n || this.scope), o = a.conditions = {};
                for (i in this.contexts.push(a),
                e = a.add("onMatch", e),
                a.queries = t,
                t)
                    "all" === i ? s = 1 : (r = c.matchMedia(t[i])) && (pn.indexOf(a) < 0 && pn.push(a),
                    (o[i] = r.matches) && (s = 1),
                    r.addListener ? r.addListener(yn) : r.addEventListener("change", yn));
                return s && e(a),
                this
            }
            ,
            e.revert = function(t) {
                this.kill(t || {})
            }
            ,
            e.kill = function(t) {
                this.contexts.forEach((function(e) {
                    return e.kill(t, !0)
                }
                ))
            }
            ,
            t
        }()
          , wn = {
            registerPlugin: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                e.forEach((function(t) {
                    return ge(t)
                }
                ))
            },
            timeline: function(t) {
                return new Ge(t)
            },
            getTweensOf: function(t, e) {
                return l.getTweensOf(t, e)
            },
            getProperty: function(t, e, n, r) {
                P(t) && (t = re(t)[0]);
                var i = dt(t || {}).get
                  , s = n ? wt : bt;
                return "native" === n && (n = ""),
                t ? e ? s((at[e] && at[e].get || i)(t, e, n, r)) : function(e, n, r) {
                    return s((at[e] && at[e].get || i)(t, e, n, r))
                }
                : t
            },
            quickSetter: function(t, e, n) {
                if ((t = re(t)).length > 1) {
                    var r = t.map((function(t) {
                        return Sn.quickSetter(t, e, n)
                    }
                    ))
                      , i = r.length;
                    return function(t) {
                        for (var e = i; e--; )
                            r[e](t)
                    }
                }
                t = t[0] || {};
                var s = at[e]
                  , a = dt(t)
                  , o = a.harness && (a.harness.aliases || {})[e] || e
                  , l = s ? function(e) {
                    var r = new s;
                    p._pt = 0,
                    r.init(t, n ? e + n : e, p, 0, [t]),
                    r.render(1, r),
                    p._pt && ln(1, p)
                }
                : a.set(t, o);
                return s ? l : function(e) {
                    return l(t, o, n ? e + n : e, a, 1)
                }
            },
            quickTo: function(t, e, n) {
                var r, i = Sn.to(t, Tt(((r = {})[e] = "+=0.1",
                r.paused = !0,
                r), n || {})), s = function(t, n, r) {
                    return i.resetTo(e, t, n, r)
                };
                return s.tween = i,
                s
            },
            isTweening: function(t) {
                return l.getTweensOf(t, !0).length > 0
            },
            defaults: function(t) {
                return t && t.ease && (t.ease = Ne(t.ease, b.ease)),
                St(b, t || {})
            },
            config: function(t) {
                return St(x, t || {})
            },
            registerEffect: function(t) {
                var e = t.name
                  , n = t.effect
                  , r = t.plugins
                  , i = t.defaults
                  , s = t.extendTimeline;
                (r || "").split(",").forEach((function(t) {
                    return t && !at[t] && !Y[t] && J(e + " effect requires " + t + " plugin.")
                }
                )),
                ot[e] = function(t, e, r) {
                    return n(re(t), Mt(e || {}, i), r)
                }
                ,
                s && (Ge.prototype[e] = function(t, n, r) {
                    return this.add(ot[e](t, N(n) ? n : (r = n) && {}, this), r)
                }
                )
            },
            registerEase: function(t, e) {
                Re[t] = Ne(e)
            },
            parseEase: function(t, e) {
                return arguments.length ? Ne(t, e) : Re
            },
            getById: function(t) {
                return l.getById(t)
            },
            exportRoot: function(t, e) {
                void 0 === t && (t = {});
                var n, r, i = new Ge(t);
                for (i.smoothChildTiming = F(t.smoothChildTiming),
                l.remove(i),
                i._dp = 0,
                i._time = i._tTime = l._time,
                n = l._first; n; )
                    r = n._next,
                    !e && !n._dur && n instanceof Qe && n.vars.onComplete === n._targets[0] || Gt(i, n, n._start - n._delay),
                    n = r;
                return Gt(l, i, 0),
                i
            },
            context: function(t, e) {
                return t ? new xn(t,e) : o
            },
            matchMedia: function(t) {
                return new bn(t)
            },
            matchMediaRefresh: function() {
                return pn.forEach((function(t) {
                    var e, n, r = t.conditions;
                    for (n in r)
                        r[n] && (r[n] = !1,
                        e = 1);
                    e && t.revert()
                }
                )) || yn()
            },
            addEventListener: function(t, e) {
                var n = mn[t] || (mn[t] = []);
                ~n.indexOf(e) || n.push(e)
            },
            removeEventListener: function(t, e) {
                var n = mn[t]
                  , r = n && n.indexOf(e);
                r >= 0 && n.splice(r, 1)
            },
            utils: {
                wrap: function t(e, n, r) {
                    var i = n - e;
                    return B(e) ? ue(e, t(0, e.length), n) : Jt(r, (function(t) {
                        return (i + (t - e) % i) % i + e
                    }
                    ))
                },
                wrapYoyo: function t(e, n, r) {
                    var i = n - e
                      , s = 2 * i;
                    return B(e) ? ue(e, t(0, e.length - 1), n) : Jt(r, (function(t) {
                        return e + ((t = (s + (t - e) % s) % s || 0) > i ? s - t : t)
                    }
                    ))
                },
                distribute: ae,
                random: ce,
                snap: le,
                normalize: function(t, e, n) {
                    return de(t, e, 0, 1, n)
                },
                getUnit: $t,
                clamp: function(t, e, n) {
                    return Jt(n, (function(n) {
                        return Qt(t, e, n)
                    }
                    ))
                },
                splitColor: xe,
                toArray: re,
                selector: ie,
                mapRange: de,
                pipe: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                        e[n] = arguments[n];
                    return function(t) {
                        return e.reduce((function(t, e) {
                            return e(t)
                        }
                        ), t)
                    }
                },
                unitize: function(t, e) {
                    return function(n) {
                        return t(parseFloat(n)) + (e || $t(n))
                    }
                },
                interpolate: function t(e, n, r, i) {
                    var s = isNaN(e + n) ? 0 : function(t) {
                        return (1 - t) * e + t * n
                    }
                    ;
                    if (!s) {
                        var a, o, l, c, u, h = P(e), d = {};
                        if (!0 === r && (i = 1) && (r = null),
                        h)
                            e = {
                                p: e
                            },
                            n = {
                                p: n
                            };
                        else if (B(e) && !B(n)) {
                            for (l = [],
                            c = e.length,
                            u = c - 2,
                            o = 1; o < c; o++)
                                l.push(t(e[o - 1], e[o]));
                            c--,
                            s = function(t) {
                                t *= c;
                                var e = Math.min(u, ~~t);
                                return l[e](t - e)
                            }
                            ,
                            r = n
                        } else
                            i || (e = Tt(B(e) ? [] : {}, e));
                        if (!l) {
                            for (a in n)
                                Xe.call(d, e, a, "get", n[a]);
                            s = function(t) {
                                return ln(t, d) || (h ? e.p : e)
                            }
                        }
                    }
                    return Jt(r, s)
                },
                shuffle: se
            },
            install: Z,
            effects: ot,
            ticker: Ee,
            updateRoot: Ge.updateRoot,
            plugins: at,
            globalTimeline: l,
            core: {
                PropTween: fn,
                globals: Q,
                Tween: Qe,
                Timeline: Ge,
                Animation: ke,
                getCache: dt,
                _removeLinkedListItem: Lt,
                reverting: function() {
                    return a
                },
                context: function(t) {
                    return t && o && (o.data.push(t),
                    t._ctx = o),
                    o
                },
                suppressOverwrites: function(t) {
                    return s = t
                }
            }
        };
        pt("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
            return wn[t] = Qe[t]
        }
        )),
        Ee.add(Ge.updateRoot),
        p = wn.to({}, {
            duration: 0
        });
        var Mn = function(t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
                n = n._next;
            return n
        }
          , Tn = function(t, e) {
            return {
                name: t,
                rawVars: 1,
                init: function(t, n, r) {
                    r._onInit = function(t) {
                        var r, i;
                        if (P(n) && (r = {},
                        pt(n, (function(t) {
                            return r[t] = 1
                        }
                        )),
                        n = r),
                        e) {
                            for (i in r = {},
                            n)
                                r[i] = e(n[i]);
                            n = r
                        }
                        !function(t, e) {
                            var n, r, i, s = t._targets;
                            for (n in e)
                                for (r = s.length; r--; )
                                    (i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = Mn(i, n)),
                                    i && i.modifier && i.modifier(e[n], t, s[r], n))
                        }(t, n)
                    }
                }
            }
        }
          , Sn = wn.registerPlugin({
            name: "attr",
            init: function(t, e, n, r, i) {
                var s, a, o;
                for (s in this.tween = n,
                e)
                    o = t.getAttribute(s) || "",
                    (a = this.add(t, "setAttribute", (o || 0) + "", e[s], r, i, 0, 0, s)).op = s,
                    a.b = o,
                    this._props.push(s)
            },
            render: function(t, e) {
                for (var n = e._pt; n; )
                    a ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d),
                    n = n._next
            }
        }, {
            name: "endArray",
            init: function(t, e) {
                for (var n = e.length; n--; )
                    this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
            }
        }, Tn("roundProps", oe), Tn("modifiers"), Tn("snap", le)) || wn;
        Qe.version = Ge.version = Sn.version = "3.11.4",
        d = 1,
        O() && Ae();
        Re.Power0,
        Re.Power1,
        Re.Power2,
        Re.Power3,
        Re.Power4,
        Re.Linear,
        Re.Quad,
        Re.Cubic,
        Re.Quart,
        Re.Quint,
        Re.Strong;
        var En = Re.Elastic;
        Re.Back,
        Re.SteppedEase,
        Re.Bounce,
        Re.Sine,
        Re.Expo,
        Re.Circ
    },
    2642: function(t, e, n) {
        n.d(e, {
            ZP: function() {
                return s
            },
            p8: function() {
                return s
            }
        });
        var r = n(5317)
          , i = n(9975)
          , s = r.p8.registerPlugin(i._Z) || r.p8;
        s.core.Tween
    },
    1929: function(t, e, n) {
        n.d(e, {
            V: function() {
                return s
            }
        });
        var r = n(9203)
          , i = n(4291);
        class s extends i.T {
            constructor() {
                super(),
                this.type = "Camera",
                this.matrixWorldInverse = new r.y,
                this.projectionMatrix = new r.y,
                this.projectionMatrixInverse = new r.y
            }
            copy(t, e) {
                return super.copy(t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        s.prototype.isCamera = !0
    },
    3131: function(t, e, n) {
        n.d(e, {
            i: function() {
                return i
            }
        });
        var r = n(1929);
        class i extends r.V {
            constructor(t=-1, e=1, n=1, r=-1, i=.1, s=2e3) {
                super(),
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = n,
                this.bottom = r,
                this.near = i,
                this.far = s,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this
            }
            setViewOffset(t, e, n, r, i, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = r,
                this.view.width = i,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                  , e = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , r = (this.top + this.bottom) / 2;
                let i = n - t
                  , s = n + t
                  , a = r + e
                  , o = r - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    i += t * this.view.offsetX,
                    s = i + t * this.view.width,
                    a -= e * this.view.offsetY,
                    o = a - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(i, s, a, o, this.near, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e
            }
        }
        i.prototype.isOrthographicCamera = !0
    },
    1051: function(t, e, n) {
        n.d(e, {
            c: function() {
                return s
            }
        });
        var r = n(1929)
          , i = n(2043);
        class s extends r.V {
            constructor(t=50, e=1, n=.1, r=2e3) {
                super(),
                this.type = "PerspectiveCamera",
                this.fov = t,
                this.zoom = 1,
                this.near = n,
                this.far = r,
                this.focus = 10,
                this.aspect = e,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.fov = t.fov,
                this.zoom = t.zoom,
                this.near = t.near,
                this.far = t.far,
                this.focus = t.focus,
                this.aspect = t.aspect,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this.filmGauge = t.filmGauge,
                this.filmOffset = t.filmOffset,
                this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * i.I3 * Math.atan(e),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * i.qW * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * i.I3 * Math.atan(Math.tan(.5 * i.qW * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, r, i, s) {
                this.aspect = t / e,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = r,
                this.view.width = i,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * i.qW * this.fov) / this.zoom
                  , n = 2 * e
                  , r = this.aspect * n
                  , s = -.5 * r;
                const a = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = a.fullWidth
                      , i = a.fullHeight;
                    s += a.offsetX * r / t,
                    e -= a.offsetY * n / i,
                    r *= a.width / t,
                    n *= a.height / i
                }
                const o = this.filmOffset;
                0 !== o && (s += t * o / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(s, s + r, e, e - n, t, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov,
                e.object.zoom = this.zoom,
                e.object.near = this.near,
                e.object.far = this.far,
                e.object.focus = this.focus,
                e.object.aspect = this.aspect,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e.object.filmGauge = this.filmGauge,
                e.object.filmOffset = this.filmOffset,
                e
            }
        }
        s.prototype.isPerspectiveCamera = !0
    },
    1661: function(t, e, n) {
        n.d(e, {
            APR: function() {
                return de
            },
            Abz: function() {
                return fe
            },
            BFQ: function() {
                return Gt
            },
            BG$: function() {
                return ne
            },
            BVF: function() {
                return F
            },
            Bf4: function() {
                return nt
            },
            CaW: function() {
                return Yt
            },
            CdI: function() {
                return q
            },
            CtA: function() {
                return Ut
            },
            D1R: function() {
                return ft
            },
            D9w: function() {
                return Ft
            },
            Djp: function() {
                return ee
            },
            E2K: function() {
                return Bt
            },
            EoG: function() {
                return Y
            },
            F5G: function() {
                return zt
            },
            FUD: function() {
                return le
            },
            GG6: function() {
                return ae
            },
            Gih: function() {
                return oe
            },
            HBG: function() {
                return Se
            },
            Hy8: function() {
                return C
            },
            I0h: function() {
                return we
            },
            IFH: function() {
                return De
            },
            ILR: function() {
                return Vt
            },
            IOt: function() {
                return je
            },
            Inb: function() {
                return He
            },
            JQ4: function() {
                return yt
            },
            KC9: function() {
                return Be
            },
            KhW: function() {
                return E
            },
            Kz5: function() {
                return _t
            },
            LSk: function() {
                return Je
            },
            LY2: function() {
                return K
            },
            LgE: function() {
                return Ge
            },
            LgZ: function() {
                return L
            },
            LsT: function() {
                return vt
            },
            M5h: function() {
                return v
            },
            M6c: function() {
                return ke
            },
            M6v: function() {
                return H
            },
            N4l: function() {
                return g
            },
            NDo: function() {
                return X
            },
            NMF: function() {
                return Ae
            },
            NYV: function() {
                return re
            },
            Ns1: function() {
                return V
            },
            OS$: function() {
                return ge
            },
            OTo: function() {
                return Et
            },
            OoA: function() {
                return ot
            },
            PA7: function() {
                return Ye
            },
            PeU: function() {
                return r
            },
            Pnf: function() {
                return Le
            },
            RlZ: function() {
                return N
            },
            S2y: function() {
                return s
            },
            SVc: function() {
                return it
            },
            Se2: function() {
                return O
            },
            Sm8: function() {
                return M
            },
            SvJ: function() {
                return ue
            },
            Syv: function() {
                return Ee
            },
            T95: function() {
                return mt
            },
            TyD: function() {
                return lt
            },
            UCm: function() {
                return At
            },
            UlW: function() {
                return Ne
            },
            Vdb: function() {
                return D
            },
            VzW: function() {
                return xt
            },
            W2J: function() {
                return Ke
            },
            WMw: function() {
                return m
            },
            Wbm: function() {
                return x
            },
            Wl3: function() {
                return c
            },
            Wpd: function() {
                return I
            },
            Wso: function() {
                return xe
            },
            XNv: function() {
                return Tt
            },
            Xaj: function() {
                return _
            },
            Y5S: function() {
                return ye
            },
            Y8D: function() {
                return Lt
            },
            YGz: function() {
                return Z
            },
            YLQ: function() {
                return ct
            },
            Yjz: function() {
                return Me
            },
            Zr5: function() {
                return U
            },
            _AM: function() {
                return Wt
            },
            _Li: function() {
                return u
            },
            _iA: function() {
                return a
            },
            _lf: function() {
                return Pe
            },
            _sL: function() {
                return Ce
            },
            _wO: function() {
                return ve
            },
            aH4: function() {
                return ut
            },
            aoB: function() {
                return Ct
            },
            av9: function() {
                return Ot
            },
            bGH: function() {
                return y
            },
            bcs: function() {
                return _e
            },
            bdR: function() {
                return p
            },
            brP: function() {
                return It
            },
            bsb: function() {
                return he
            },
            c8b: function() {
                return T
            },
            cLu: function() {
                return bt
            },
            cRx: function() {
                return Pt
            },
            cum: function() {
                return Ze
            },
            dSO: function() {
                return et
            },
            dZ3: function() {
                return J
            },
            dwk: function() {
                return l
            },
            eD: function() {
                return B
            },
            ePn: function() {
                return Te
            },
            eaV: function() {
                return jt
            },
            ehD: function() {
                return h
            },
            ekQ: function() {
                return Kt
            },
            esl: function() {
                return d
            },
            fSK: function() {
                return P
            },
            fY$: function() {
                return $
            },
            fto: function() {
                return qt
            },
            g8_: function() {
                return rt
            },
            gMp: function() {
                return Ve
            },
            gSk: function() {
                return Ie
            },
            ghN: function() {
                return S
            },
            gi4: function() {
                return te
            },
            hEm: function() {
                return Nt
            },
            iAb: function() {
                return gt
            },
            iWC: function() {
                return A
            },
            iiP: function() {
                return ce
            },
            irR: function() {
                return Mt
            },
            jFi: function() {
                return f
            },
            jZA: function() {
                return Qt
            },
            k0A: function() {
                return wt
            },
            k74: function() {
                return R
            },
            knz: function() {
                return Ue
            },
            ksN: function() {
                return k
            },
            l0P: function() {
                return Zt
            },
            mSO: function() {
                return Xe
            },
            ntZ: function() {
                return o
            },
            p1$: function() {
                return be
            },
            pIN: function() {
                return Re
            },
            pKu: function() {
                return se
            },
            pMV: function() {
                return ze
            },
            pnl: function() {
                return me
            },
            ptH: function() {
                return Jt
            },
            qhX: function() {
                return W
            },
            qkB: function() {
                return Dt
            },
            qyh: function() {
                return dt
            },
            rOj: function() {
                return b
            },
            r_: function() {
                return w
            },
            rnI: function() {
                return Oe
            },
            rpg: function() {
                return st
            },
            tm_: function() {
                return i
            },
            uL9: function() {
                return j
            },
            uWy: function() {
                return at
            },
            v3W: function() {
                return Ht
            },
            v6B: function() {
                return pe
            },
            vCF: function() {
                return z
            },
            vCx: function() {
                return Xt
            },
            vxC: function() {
                return tt
            },
            w$m: function() {
                return G
            },
            wJv: function() {
                return St
            },
            wem: function() {
                return ht
            },
            wk1: function() {
                return Rt
            },
            wuA: function() {
                return kt
            },
            x5V: function() {
                return qe
            },
            xJs: function() {
                return ie
            },
            xfE: function() {
                return Q
            },
            y2t: function() {
                return $t
            },
            ywz: function() {
                return pt
            },
            z$h: function() {
                return Fe
            },
            z81: function() {
                return We
            }
        });
        const r = 0
          , i = 1
          , s = 2
          , a = 1
          , o = 2
          , l = 3
          , c = 0
          , u = 1
          , h = 2
          , d = 1
          , f = 0
          , p = 1
          , m = 2
          , g = 3
          , v = 4
          , _ = 5
          , y = 100
          , x = 101
          , b = 102
          , w = 103
          , M = 104
          , T = 200
          , S = 201
          , E = 202
          , A = 203
          , R = 204
          , L = 205
          , P = 206
          , C = 207
          , D = 208
          , I = 209
          , N = 210
          , F = 0
          , O = 1
          , U = 2
          , z = 3
          , B = 4
          , k = 5
          , G = 6
          , H = 7
          , V = 0
          , W = 1
          , X = 2
          , j = 0
          , Y = 1
          , q = 2
          , Z = 3
          , K = 4
          , J = 5
          , Q = 300
          , $ = 301
          , tt = 302
          , et = 303
          , nt = 304
          , rt = 306
          , it = 307
          , st = 1e3
          , at = 1001
          , ot = 1002
          , lt = 1003
          , ct = 1004
          , ut = 1005
          , ht = 1006
          , dt = 1007
          , ft = 1008
          , pt = 1009
          , mt = 1010
          , gt = 1011
          , vt = 1012
          , _t = 1013
          , yt = 1014
          , xt = 1015
          , bt = 1016
          , wt = 1017
          , Mt = 1018
          , Tt = 1019
          , St = 1020
          , Et = 1021
          , At = 1022
          , Rt = 1023
          , Lt = 1024
          , Pt = 1025
          , Ct = Rt
          , Dt = 1026
          , It = 1027
          , Nt = 1028
          , Ft = 1029
          , Ot = 1030
          , Ut = 1031
          , zt = 1032
          , Bt = 1033
          , kt = 33776
          , Gt = 33777
          , Ht = 33778
          , Vt = 33779
          , Wt = 35840
          , Xt = 35841
          , jt = 35842
          , Yt = 35843
          , qt = 36196
          , Zt = 37492
          , Kt = 37496
          , Jt = 37808
          , Qt = 37809
          , $t = 37810
          , te = 37811
          , ee = 37812
          , ne = 37813
          , re = 37814
          , ie = 37815
          , se = 37816
          , ae = 37817
          , oe = 37818
          , le = 37819
          , ce = 37820
          , ue = 37821
          , he = 36492
          , de = 37840
          , fe = 37841
          , pe = 37842
          , me = 37843
          , ge = 37844
          , ve = 37845
          , _e = 37846
          , ye = 37847
          , xe = 37848
          , be = 37849
          , we = 37850
          , Me = 37851
          , Te = 37852
          , Se = 37853
          , Ee = 2300
          , Ae = 2301
          , Re = 2302
          , Le = 2400
          , Pe = 2401
          , Ce = 2402
          , De = 2500
          , Ie = 2501
          , Ne = 1
          , Fe = 2
          , Oe = 3e3
          , Ue = 3001
          , ze = 3007
          , Be = 3002
          , ke = 3003
          , Ge = 3004
          , He = 3005
          , Ve = 3006
          , We = 3200
          , Xe = 3201
          , je = 0
          , Ye = 1
          , qe = 7680
          , Ze = 519
          , Ke = 35044
          , Je = "300 es"
    },
    140: function(t, e, n) {
        n.d(e, {
            Tl: function() {
                return u
            },
            a$: function() {
                return f
            },
            lC: function() {
                return d
            },
            ql: function() {
                return h
            }
        });
        var r = n(223)
          , i = n(6881)
          , s = n(1138)
          , a = n(3662)
          , o = n(1661);
        const l = new i.P
          , c = new s.F;
        class u {
            constructor(t, e, n) {
                if (Array.isArray(t))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "",
                this.array = t,
                this.itemSize = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.normalized = !0 === n,
                this.usage = o.W2J,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.name = t.name,
                this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.count = t.count,
                this.normalized = t.normalized,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.itemSize,
                n *= e.itemSize;
                for (let r = 0, i = this.itemSize; r < i; r++)
                    this.array[t + r] = e.array[n + r];
                return this
            }
            copyArray(t) {
                return this.array.set(t),
                this
            }
            copyColorsArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, i = t.length; r < i; r++) {
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r),
                    i = new a.I),
                    e[n++] = i.r,
                    e[n++] = i.g,
                    e[n++] = i.b
                }
                return this
            }
            copyVector2sArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, i = t.length; r < i; r++) {
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r),
                    i = new s.F),
                    e[n++] = i.x,
                    e[n++] = i.y
                }
                return this
            }
            copyVector3sArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, s = t.length; r < s; r++) {
                    let s = t[r];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r),
                    s = new i.P),
                    e[n++] = s.x,
                    e[n++] = s.y,
                    e[n++] = s.z
                }
                return this
            }
            copyVector4sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, s = t.length; i < s; i++) {
                    let s = t[i];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                    s = new r.L),
                    e[n++] = s.x,
                    e[n++] = s.y,
                    e[n++] = s.z,
                    e[n++] = s.w
                }
                return this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        c.fromBufferAttribute(this, e),
                        c.applyMatrix3(t),
                        this.setXY(e, c.x, c.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        l.fromBufferAttribute(this, e),
                        l.applyMatrix3(t),
                        this.setXYZ(e, l.x, l.y, l.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    l.x = this.getX(e),
                    l.y = this.getY(e),
                    l.z = this.getZ(e),
                    l.applyMatrix4(t),
                    this.setXYZ(e, l.x, l.y, l.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    l.x = this.getX(e),
                    l.y = this.getY(e),
                    l.z = this.getZ(e),
                    l.applyNormalMatrix(t),
                    this.setXYZ(e, l.x, l.y, l.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    l.x = this.getX(e),
                    l.y = this.getY(e),
                    l.z = this.getZ(e),
                    l.transformDirection(t),
                    this.setXYZ(e, l.x, l.y, l.z);
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            getX(t) {
                return this.array[t * this.itemSize]
            }
            setX(t, e) {
                return this.array[t * this.itemSize] = e,
                this
            }
            getY(t) {
                return this.array[t * this.itemSize + 1]
            }
            setY(t, e) {
                return this.array[t * this.itemSize + 1] = e,
                this
            }
            getZ(t) {
                return this.array[t * this.itemSize + 2]
            }
            setZ(t, e) {
                return this.array[t * this.itemSize + 2] = e,
                this
            }
            getW(t) {
                return this.array[t * this.itemSize + 3]
            }
            setW(t, e) {
                return this.array[t * this.itemSize + 3] = e,
                this
            }
            setXY(t, e, n) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, r) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = r,
                this
            }
            setXYZW(t, e, n, r, i) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = r,
                this.array[t + 3] = i,
                this
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name),
                this.usage !== o.W2J && (t.usage = this.usage),
                0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
                t
            }
        }
        u.prototype.isBufferAttribute = !0;
        class h extends u {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class d extends u {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        (class extends u {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        ).prototype.isFloat16BufferAttribute = !0;
        class f extends u {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
    },
    9046: function(t, e, n) {
        n.d(e, {
            u: function() {
                return b
            }
        });
        var r = n(6881)
          , i = n(1138)
          , s = n(1898)
          , a = n(7406)
          , o = n(140)
          , l = n(4699)
          , c = n(4291)
          , u = n(9203)
          , h = n(1273)
          , d = n(2043)
          , f = n(392);
        let p = 0;
        const m = new u.y
          , g = new c.T
          , v = new r.P
          , _ = new s.Z
          , y = new s.Z
          , x = new r.P;
        class b extends a.p {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: p++
                }),
                this.uuid = d.DO(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new ((0,
                f.uH)(t) > 65535 ? o.lC : o.ql)(t,1) : this.index = t,
                this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e,
                this
            }
            deleteAttribute(t) {
                return delete this.attributes[t],
                this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n=0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new h.V).getNormalMatrix(t);
                    n.applyNormalMatrix(e),
                    n.needsUpdate = !0
                }
                const r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(t),
                r.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(t) {
                return m.makeRotationFromQuaternion(t),
                this.applyMatrix4(m),
                this
            }
            rotateX(t) {
                return m.makeRotationX(t),
                this.applyMatrix4(m),
                this
            }
            rotateY(t) {
                return m.makeRotationY(t),
                this.applyMatrix4(m),
                this
            }
            rotateZ(t) {
                return m.makeRotationZ(t),
                this.applyMatrix4(m),
                this
            }
            translate(t, e, n) {
                return m.makeTranslation(t, e, n),
                this.applyMatrix4(m),
                this
            }
            scale(t, e, n) {
                return m.makeScale(t, e, n),
                this.applyMatrix4(m),
                this
            }
            lookAt(t) {
                return g.lookAt(t),
                g.updateMatrix(),
                this.applyMatrix4(g.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(v).negate(),
                this.translate(v.x, v.y, v.z),
                this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new o.a$(e,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new s.Z);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new r.P(-1 / 0,-1 / 0,-1 / 0), new r.P(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            _.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (x.addVectors(this.boundingBox.min, _.min),
                            this.boundingBox.expandByPoint(x),
                            x.addVectors(this.boundingBox.max, _.max),
                            this.boundingBox.expandByPoint(x)) : (this.boundingBox.expandByPoint(_.min),
                            this.boundingBox.expandByPoint(_.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new l.a);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new r.P, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (_.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            y.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (x.addVectors(_.min, y.min),
                            _.expandByPoint(x),
                            x.addVectors(_.max, y.max),
                            _.expandByPoint(x)) : (_.expandByPoint(y.min),
                            _.expandByPoint(y.max))
                        }
                    _.getCenter(n);
                    let r = 0;
                    for (let e = 0, i = t.count; e < i; e++)
                        x.fromBufferAttribute(t, e),
                        r = Math.max(r, n.distanceToSquared(x));
                    if (e)
                        for (let i = 0, s = e.length; i < s; i++) {
                            const s = e[i]
                              , a = this.morphTargetsRelative;
                            for (let e = 0, i = s.count; e < i; e++)
                                x.fromBufferAttribute(s, e),
                                a && (v.fromBufferAttribute(t, e),
                                x.add(v)),
                                r = Math.max(r, n.distanceToSquared(x))
                        }
                    this.boundingSphere.radius = Math.sqrt(r),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index
                  , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array
                  , s = e.position.array
                  , a = e.normal.array
                  , l = e.uv.array
                  , c = s.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new o.Tl(new Float32Array(4 * c),4));
                const u = e.tangent.array
                  , h = []
                  , d = [];
                for (let t = 0; t < c; t++)
                    h[t] = new r.P,
                    d[t] = new r.P;
                const f = new r.P
                  , p = new r.P
                  , m = new r.P
                  , g = new i.F
                  , v = new i.F
                  , _ = new i.F
                  , y = new r.P
                  , x = new r.P;
                function b(t, e, n) {
                    f.fromArray(s, 3 * t),
                    p.fromArray(s, 3 * e),
                    m.fromArray(s, 3 * n),
                    g.fromArray(l, 2 * t),
                    v.fromArray(l, 2 * e),
                    _.fromArray(l, 2 * n),
                    p.sub(f),
                    m.sub(f),
                    v.sub(g),
                    _.sub(g);
                    const r = 1 / (v.x * _.y - _.x * v.y);
                    isFinite(r) && (y.copy(p).multiplyScalar(_.y).addScaledVector(m, -v.y).multiplyScalar(r),
                    x.copy(m).multiplyScalar(v.x).addScaledVector(p, -_.x).multiplyScalar(r),
                    h[t].add(y),
                    h[e].add(y),
                    h[n].add(y),
                    d[t].add(x),
                    d[e].add(x),
                    d[n].add(x))
                }
                let w = this.groups;
                0 === w.length && (w = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = w.length; t < e; ++t) {
                    const e = w[t]
                      , r = e.start;
                    for (let t = r, i = r + e.count; t < i; t += 3)
                        b(n[t + 0], n[t + 1], n[t + 2])
                }
                const M = new r.P
                  , T = new r.P
                  , S = new r.P
                  , E = new r.P;
                function A(t) {
                    S.fromArray(a, 3 * t),
                    E.copy(S);
                    const e = h[t];
                    M.copy(e),
                    M.sub(S.multiplyScalar(S.dot(e))).normalize(),
                    T.crossVectors(E, e);
                    const n = T.dot(d[t]) < 0 ? -1 : 1;
                    u[4 * t] = M.x,
                    u[4 * t + 1] = M.y,
                    u[4 * t + 2] = M.z,
                    u[4 * t + 3] = n
                }
                for (let t = 0, e = w.length; t < e; ++t) {
                    const e = w[t]
                      , r = e.start;
                    for (let t = r, i = r + e.count; t < i; t += 3)
                        A(n[t + 0]),
                        A(n[t + 1]),
                        A(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index
                  , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new o.Tl(new Float32Array(3 * e.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++)
                            n.setXYZ(t, 0, 0, 0);
                    const i = new r.P
                      , s = new r.P
                      , a = new r.P
                      , l = new r.P
                      , c = new r.P
                      , u = new r.P
                      , h = new r.P
                      , d = new r.P;
                    if (t)
                        for (let r = 0, o = t.count; r < o; r += 3) {
                            const o = t.getX(r + 0)
                              , f = t.getX(r + 1)
                              , p = t.getX(r + 2);
                            i.fromBufferAttribute(e, o),
                            s.fromBufferAttribute(e, f),
                            a.fromBufferAttribute(e, p),
                            h.subVectors(a, s),
                            d.subVectors(i, s),
                            h.cross(d),
                            l.fromBufferAttribute(n, o),
                            c.fromBufferAttribute(n, f),
                            u.fromBufferAttribute(n, p),
                            l.add(h),
                            c.add(h),
                            u.add(h),
                            n.setXYZ(o, l.x, l.y, l.z),
                            n.setXYZ(f, c.x, c.y, c.z),
                            n.setXYZ(p, u.x, u.y, u.z)
                        }
                    else
                        for (let t = 0, r = e.count; t < r; t += 3)
                            i.fromBufferAttribute(e, t + 0),
                            s.fromBufferAttribute(e, t + 1),
                            a.fromBufferAttribute(e, t + 2),
                            h.subVectors(a, s),
                            d.subVectors(i, s),
                            h.cross(d),
                            n.setXYZ(t + 0, h.x, h.y, h.z),
                            n.setXYZ(t + 1, h.x, h.y, h.z),
                            n.setXYZ(t + 2, h.x, h.y, h.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            merge(t, e) {
                if (!t || !t.isBufferGeometry)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const r in n) {
                    if (void 0 === t.attributes[r])
                        continue;
                    const i = n[r].array
                      , s = t.attributes[r]
                      , a = s.array
                      , o = s.itemSize * e
                      , l = Math.min(a.length, i.length - o);
                    for (let t = 0, e = o; t < l; t++,
                    e++)
                        i[e] = a[t]
                }
                return this
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++)
                    x.fromBufferAttribute(t, e),
                    x.normalize(),
                    t.setXYZ(e, x.x, x.y, x.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array
                      , r = t.itemSize
                      , i = t.normalized
                      , s = new n.constructor(e.length * r);
                    let a = 0
                      , l = 0;
                    for (let i = 0, o = e.length; i < o; i++) {
                        a = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
                        for (let t = 0; t < r; t++)
                            s[l++] = n[a++]
                    }
                    return new o.Tl(s,r,i)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const e = new b
                  , n = this.index.array
                  , r = this.attributes;
                for (const i in r) {
                    const s = t(r[i], n);
                    e.setAttribute(i, s)
                }
                const i = this.morphAttributes;
                for (const r in i) {
                    const s = []
                      , a = i[r];
                    for (let e = 0, r = a.length; e < r; e++) {
                        const r = t(a[e], n);
                        s.push(r)
                    }
                    e.morphAttributes[r] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e)
                        void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const r = n[e];
                    t.data.attributes[e] = r.toJSON(t.data)
                }
                const r = {};
                let i = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e]
                      , s = [];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        s.push(r.toJSON(t.data))
                    }
                    s.length > 0 && (r[e] = s,
                    i = !0)
                }
                i && (t.data.morphAttributes = r,
                t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const a = this.boundingSphere;
                return null !== a && (t.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }),
                t
            }
            clone() {
                return (new b).copy(this)
            }
            copy(t) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const r = t.attributes;
                for (const t in r) {
                    const n = r[t];
                    this.setAttribute(t, n.clone(e))
                }
                const i = t.morphAttributes;
                for (const t in i) {
                    const n = []
                      , r = i[t];
                    for (let t = 0, i = r.length; t < i; t++)
                        n.push(r[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = t.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const o = t.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this.userData = t.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        b.prototype.isBufferGeometry = !0
    },
    7406: function(t, e, n) {
        n.d(e, {
            p: function() {
                return r
            }
        });
        class r {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e);
                    -1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, r = n.length; e < r; e++)
                        n[e].call(this, t);
                    t.target = null
                }
            }
        }
    },
    612: function(t, e, n) {
        n.d(e, {
            l: function() {
                return i
            }
        });
        var r = n(140);
        class i extends r.Tl {
            constructor(t, e, n, r=1) {
                "number" == typeof n && (r = n,
                n = !1,
                console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
                super(t, e, n),
                this.meshPerAttribute = r
            }
            copy(t) {
                return super.copy(t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute,
                t.isInstancedBufferAttribute = !0,
                t
            }
        }
        i.prototype.isInstancedBufferAttribute = !0
    },
    4291: function(t, e, n) {
        n.d(e, {
            T: function() {
                return E
            }
        });
        var r = n(7092)
          , i = n(6881)
          , s = n(9203)
          , a = n(7406)
          , o = n(2043);
        const l = new s.y
          , c = new r._;
        class u {
            constructor(t=0, e=0, n=0, r=u.DefaultOrder) {
                this._x = t,
                this._y = e,
                this._z = n,
                this._order = r
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                this._onChangeCallback()
            }
            set(t, e, n, r=this._order) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._order = r,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t, e=this._order, n=!0) {
                const r = t.elements
                  , i = r[0]
                  , s = r[4]
                  , a = r[8]
                  , l = r[1]
                  , c = r[5]
                  , u = r[9]
                  , h = r[2]
                  , d = r[6]
                  , f = r[10];
                switch (e) {
                case "XYZ":
                    this._y = Math.asin((0,
                    o.uZ)(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f),
                    this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(d, c),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-(0,
                    o.uZ)(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f),
                    this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, i),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin((0,
                    o.uZ)(d, -1, 1)),
                    Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, f),
                    this._z = Math.atan2(-s, c)) : (this._y = 0,
                    this._z = Math.atan2(l, i));
                    break;
                case "ZYX":
                    this._y = Math.asin(-(0,
                    o.uZ)(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, f),
                    this._z = Math.atan2(l, i)) : (this._x = 0,
                    this._z = Math.atan2(-s, c));
                    break;
                case "YZX":
                    this._z = Math.asin((0,
                    o.uZ)(l, -1, 1)),
                    Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
                    this._y = Math.atan2(-h, i)) : (this._x = 0,
                    this._y = Math.atan2(a, f));
                    break;
                case "XZY":
                    this._z = Math.asin(-(0,
                    o.uZ)(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(d, c),
                    this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-u, f),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(t, e, n) {
                return l.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(l, e, n)
            }
            setFromVector3(t, e=this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return c.setFromEuler(this),
                this.setFromQuaternion(c, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new i.P(this._x,this._y,this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        u.prototype.isEuler = !0,
        u.DefaultOrder = "XYZ",
        u.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class h {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t | 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
        }
        var d = n(1273);
        let f = 0;
        const p = new i.P
          , m = new r._
          , g = new s.y
          , v = new i.P
          , _ = new i.P
          , y = new i.P
          , x = new r._
          , b = new i.P(1,0,0)
          , w = new i.P(0,1,0)
          , M = new i.P(0,0,1)
          , T = {
            type: "added"
        }
          , S = {
            type: "removed"
        };
        class E extends a.p {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: f++
                }),
                this.uuid = o.DO(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = E.DefaultUp.clone();
                const t = new i.P
                  , e = new u
                  , n = new r._
                  , a = new i.P(1,1,1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                }
                )),
                n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: a
                    },
                    modelViewMatrix: {
                        value: new s.y
                    },
                    normalMatrix: {
                        value: new d.V
                    }
                }),
                this.matrix = new s.y,
                this.matrixWorld = new s.y,
                this.matrixAutoUpdate = E.DefaultMatrixAutoUpdate,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new h,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t),
                this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return m.setFromAxisAngle(t, e),
                this.quaternion.multiply(m),
                this
            }
            rotateOnWorldAxis(t, e) {
                return m.setFromAxisAngle(t, e),
                this.quaternion.premultiply(m),
                this
            }
            rotateX(t) {
                return this.rotateOnAxis(b, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(w, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(M, t)
            }
            translateOnAxis(t, e) {
                return p.copy(t).applyQuaternion(this.quaternion),
                this.position.add(p.multiplyScalar(e)),
                this
            }
            translateX(t) {
                return this.translateOnAxis(b, t)
            }
            translateY(t) {
                return this.translateOnAxis(w, t)
            }
            translateZ(t) {
                return this.translateOnAxis(M, t)
            }
            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return t.applyMatrix4(g.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? v.copy(t) : v.set(t, e, n);
                const r = this.parent;
                this.updateWorldMatrix(!0, !1),
                _.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? g.lookAt(_, v, this.up) : g.lookAt(v, _, this.up),
                this.quaternion.setFromRotationMatrix(g),
                r && (g.extractRotation(r.matrixWorld),
                m.setFromRotationMatrix(g),
                this.quaternion.premultiply(m.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                t.parent = this,
                this.children.push(t),
                t.dispatchEvent(T)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null,
                this.children.splice(e, 1),
                t.dispatchEvent(S)),
                this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this),
                this
            }
            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null,
                    e.dispatchEvent(S)
                }
                return this.children.length = 0,
                this
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1),
                g.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                g.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(g),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e)
                    return this;
                for (let n = 0, r = this.children.length; n < r; n++) {
                    const r = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== r)
                        return r
                }
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(_, t, y),
                t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(_, x, t),
                t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++)
                    e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible)
                    return;
                t(this);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++)
                    e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++)
                    e[n].updateMatrixWorld(t)
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++)
                        t[e].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t
                  , n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                },
                n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const r = {};
                function i(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }
                if (r.uuid = this.uuid,
                r.type = this.type,
                "" !== this.name && (r.name = this.name),
                !0 === this.castShadow && (r.castShadow = !0),
                !0 === this.receiveShadow && (r.receiveShadow = !0),
                !1 === this.visible && (r.visible = !1),
                !1 === this.frustumCulled && (r.frustumCulled = !1),
                0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
                "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
                r.layers = this.layers.mask,
                r.matrix = this.matrix.toArray(),
                !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                this.isInstancedMesh && (r.type = "InstancedMesh",
                r.count = this.count,
                r.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())),
                this.isScene)
                    this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)),
                    this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = i(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                i(t.shapes, r)
                            }
                        else
                            i(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
                r.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (i(t.skeletons, this.skeleton),
                r.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, r = this.material.length; n < r; n++)
                            e.push(i(t.materials, this.material[n]));
                        r.material = e
                    } else
                        r.material = i(t.materials, this.material);
                if (this.children.length > 0) {
                    r.children = [];
                    for (let e = 0; e < this.children.length; e++)
                        r.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    r.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        r.animations.push(i(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries)
                      , r = s(t.materials)
                      , i = s(t.textures)
                      , a = s(t.images)
                      , o = s(t.shapes)
                      , l = s(t.skeletons)
                      , c = s(t.animations);
                    e.length > 0 && (n.geometries = e),
                    r.length > 0 && (n.materials = r),
                    i.length > 0 && (n.textures = i),
                    a.length > 0 && (n.images = a),
                    o.length > 0 && (n.shapes = o),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c)
                }
                return n.object = r,
                n;
                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        delete r.metadata,
                        e.push(r)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e=!0) {
                if (this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.rotation.order = t.rotation.order,
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.layers.mask = t.layers.mask,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        E.DefaultUp = new i.P(0,1,0),
        E.DefaultMatrixAutoUpdate = !0,
        E.prototype.isObject3D = !0
    },
    4970: function(t, e, n) {
        n.d(e, {
            b: function() {
                return L
            }
        });
        var r = {};
        n.r(r),
        n.d(r, {
            ArcCurve: function() {
                return h
            },
            CatmullRomCurve3: function() {
                return v
            },
            CubicBezierCurve: function() {
                return b
            },
            CubicBezierCurve3: function() {
                return w
            },
            EllipseCurve: function() {
                return u
            },
            LineCurve: function() {
                return c
            },
            LineCurve3: function() {
                return M
            },
            QuadraticBezierCurve: function() {
                return T
            },
            QuadraticBezierCurve3: function() {
                return S
            },
            SplineCurve: function() {
                return E
            }
        });
        var i = n(1138)
          , s = n(2043)
          , a = n(6881)
          , o = n(9203);
        class l {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getPoint(n, e)
            }
            getPoints(t=5) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return e
            }
            getSpacedPoints(t=5) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPointAt(n / t));
                return e
            }
            getLength() {
                const t = this.getLengths();
                return t[t.length - 1]
            }
            getLengths(t=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, r = this.getPoint(0), i = 0;
                e.push(0);
                for (let s = 1; s <= t; s++)
                    n = this.getPoint(s / t),
                    i += n.distanceTo(r),
                    e.push(i),
                    r = n;
                return this.cacheArcLengths = e,
                e
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(t, e) {
                const n = this.getLengths();
                let r = 0;
                const i = n.length;
                let s;
                s = e || t * n[i - 1];
                let a, o = 0, l = i - 1;
                for (; o <= l; )
                    if (r = Math.floor(o + (l - o) / 2),
                    a = n[r] - s,
                    a < 0)
                        o = r + 1;
                    else {
                        if (!(a > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    }
                if (r = l,
                n[r] === s)
                    return r / (i - 1);
                const c = n[r];
                return (r + (s - c) / (n[r + 1] - c)) / (i - 1)
            }
            getTangent(t, e) {
                const n = 1e-4;
                let r = t - n
                  , s = t + n;
                r < 0 && (r = 0),
                s > 1 && (s = 1);
                const o = this.getPoint(r)
                  , l = this.getPoint(s)
                  , c = e || (o.isVector2 ? new i.F : new a.P);
                return c.copy(l).sub(o).normalize(),
                c
            }
            getTangentAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getTangent(n, e)
            }
            computeFrenetFrames(t, e) {
                const n = new a.P
                  , r = []
                  , i = []
                  , l = []
                  , c = new a.P
                  , u = new o.y;
                for (let e = 0; e <= t; e++) {
                    const n = e / t;
                    r[e] = this.getTangentAt(n, new a.P),
                    r[e].normalize()
                }
                i[0] = new a.P,
                l[0] = new a.P;
                let h = Number.MAX_VALUE;
                const d = Math.abs(r[0].x)
                  , f = Math.abs(r[0].y)
                  , p = Math.abs(r[0].z);
                d <= h && (h = d,
                n.set(1, 0, 0)),
                f <= h && (h = f,
                n.set(0, 1, 0)),
                p <= h && n.set(0, 0, 1),
                c.crossVectors(r[0], n).normalize(),
                i[0].crossVectors(r[0], c),
                l[0].crossVectors(r[0], i[0]);
                for (let e = 1; e <= t; e++) {
                    if (i[e] = i[e - 1].clone(),
                    l[e] = l[e - 1].clone(),
                    c.crossVectors(r[e - 1], r[e]),
                    c.length() > Number.EPSILON) {
                        c.normalize();
                        const t = Math.acos(s.uZ(r[e - 1].dot(r[e]), -1, 1));
                        i[e].applyMatrix4(u.makeRotationAxis(c, t))
                    }
                    l[e].crossVectors(r[e], i[e])
                }
                if (!0 === e) {
                    let e = Math.acos(s.uZ(i[0].dot(i[t]), -1, 1));
                    e /= t,
                    r[0].dot(c.crossVectors(i[0], i[t])) > 0 && (e = -e);
                    for (let n = 1; n <= t; n++)
                        i[n].applyMatrix4(u.makeRotationAxis(r[n], e * n)),
                        l[n].crossVectors(r[n], i[n])
                }
                return {
                    tangents: r,
                    normals: i,
                    binormals: l
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions,
                t.type = this.type,
                t
            }
            fromJSON(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
        }
        class c extends l {
            constructor(t=new i.F, e=new i.F) {
                super(),
                this.type = "LineCurve",
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new i.F) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
                n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            getTangent(t, e) {
                const n = e || new i.F;
                return n.copy(this.v2).sub(this.v1).normalize(),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        c.prototype.isLineCurve = !0;
        class u extends l {
            constructor(t=0, e=0, n=1, r=1, i=0, s=2 * Math.PI, a=!1, o=0) {
                super(),
                this.type = "EllipseCurve",
                this.aX = t,
                this.aY = e,
                this.xRadius = n,
                this.yRadius = r,
                this.aStartAngle = i,
                this.aEndAngle = s,
                this.aClockwise = a,
                this.aRotation = o
            }
            getPoint(t, e) {
                const n = e || new i.F
                  , r = 2 * Math.PI;
                let s = this.aEndAngle - this.aStartAngle;
                const a = Math.abs(s) < Number.EPSILON;
                for (; s < 0; )
                    s += r;
                for (; s > r; )
                    s -= r;
                s < Number.EPSILON && (s = a ? 0 : r),
                !0 !== this.aClockwise || a || (s === r ? s = -r : s -= r);
                const o = this.aStartAngle + t * s;
                let l = this.aX + this.xRadius * Math.cos(o)
                  , c = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation)
                      , e = Math.sin(this.aRotation)
                      , n = l - this.aX
                      , r = c - this.aY;
                    l = n * t - r * e + this.aX,
                    c = n * e + r * t + this.aY
                }
                return n.set(l, c)
            }
            copy(t) {
                return super.copy(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX,
                t.aY = this.aY,
                t.xRadius = this.xRadius,
                t.yRadius = this.yRadius,
                t.aStartAngle = this.aStartAngle,
                t.aEndAngle = this.aEndAngle,
                t.aClockwise = this.aClockwise,
                t.aRotation = this.aRotation,
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
        }
        u.prototype.isEllipseCurve = !0;
        class h extends u {
            constructor(t, e, n, r, i, s) {
                super(t, e, n, n, r, i, s),
                this.type = "ArcCurve"
            }
        }
        function d() {
            let t = 0
              , e = 0
              , n = 0
              , r = 0;
            function i(i, s, a, o) {
                t = i,
                e = a,
                n = -3 * i + 3 * s - 2 * a - o,
                r = 2 * i - 2 * s + a + o
            }
            return {
                initCatmullRom: function(t, e, n, r, s) {
                    i(e, n, s * (n - t), s * (r - e))
                },
                initNonuniformCatmullRom: function(t, e, n, r, s, a, o) {
                    let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a
                      , c = (n - e) / a - (r - e) / (a + o) + (r - n) / o;
                    l *= a,
                    c *= a,
                    i(e, n, l, c)
                },
                calc: function(i) {
                    const s = i * i;
                    return t + e * i + n * s + r * (s * i)
                }
            }
        }
        h.prototype.isArcCurve = !0;
        const f = new a.P
          , p = new d
          , m = new d
          , g = new d;
        class v extends l {
            constructor(t=[], e=!1, n="centripetal", r=.5) {
                super(),
                this.type = "CatmullRomCurve3",
                this.points = t,
                this.closed = e,
                this.curveType = n,
                this.tension = r
            }
            getPoint(t, e=new a.P) {
                const n = e
                  , r = this.points
                  , i = r.length
                  , s = (i - (this.closed ? 0 : 1)) * t;
                let o, l, c = Math.floor(s), u = s - c;
                this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / i) + 1) * i : 0 === u && c === i - 1 && (c = i - 2,
                u = 1),
                this.closed || c > 0 ? o = r[(c - 1) % i] : (f.subVectors(r[0], r[1]).add(r[0]),
                o = f);
                const h = r[c % i]
                  , d = r[(c + 1) % i];
                if (this.closed || c + 2 < i ? l = r[(c + 2) % i] : (f.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]),
                l = f),
                "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(o.distanceToSquared(h), t)
                      , n = Math.pow(h.distanceToSquared(d), t)
                      , r = Math.pow(d.distanceToSquared(l), t);
                    n < 1e-4 && (n = 1),
                    e < 1e-4 && (e = n),
                    r < 1e-4 && (r = n),
                    p.initNonuniformCatmullRom(o.x, h.x, d.x, l.x, e, n, r),
                    m.initNonuniformCatmullRom(o.y, h.y, d.y, l.y, e, n, r),
                    g.initNonuniformCatmullRom(o.z, h.z, d.z, l.z, e, n, r)
                } else
                    "catmullrom" === this.curveType && (p.initCatmullRom(o.x, h.x, d.x, l.x, this.tension),
                    m.initCatmullRom(o.y, h.y, d.y, l.y, this.tension),
                    g.initCatmullRom(o.z, h.z, d.z, l.z, this.tension));
                return n.set(p.calc(u), m.calc(u), g.calc(u)),
                n
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed,
                t.curveType = this.curveType,
                t.tension = this.tension,
                t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new a.P).fromArray(n))
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
        }
        function _(t, e, n, r, i) {
            const s = .5 * (r - e)
              , a = .5 * (i - n)
              , o = t * t;
            return (2 * n - 2 * r + s + a) * (t * o) + (-3 * n + 3 * r - 2 * s - a) * o + s * t + n
        }
        function y(t, e, n, r) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * e
            }(t, e) + function(t, e) {
                return 2 * (1 - t) * t * e
            }(t, n) + function(t, e) {
                return t * t * e
            }(t, r)
        }
        function x(t, e, n, r, i) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * n * e
            }(t, e) + function(t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }(t, n) + function(t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, r) + function(t, e) {
                return t * t * t * e
            }(t, i)
        }
        v.prototype.isCatmullRomCurve3 = !0;
        class b extends l {
            constructor(t=new i.F, e=new i.F, n=new i.F, r=new i.F) {
                super(),
                this.type = "CubicBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n,
                this.v3 = r
            }
            getPoint(t, e=new i.F) {
                const n = e
                  , r = this.v0
                  , s = this.v1
                  , a = this.v2
                  , o = this.v3;
                return n.set(x(t, r.x, s.x, a.x, o.x), x(t, r.y, s.y, a.y, o.y)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        b.prototype.isCubicBezierCurve = !0;
        class w extends l {
            constructor(t=new a.P, e=new a.P, n=new a.P, r=new a.P) {
                super(),
                this.type = "CubicBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n,
                this.v3 = r
            }
            getPoint(t, e=new a.P) {
                const n = e
                  , r = this.v0
                  , i = this.v1
                  , s = this.v2
                  , o = this.v3;
                return n.set(x(t, r.x, i.x, s.x, o.x), x(t, r.y, i.y, s.y, o.y), x(t, r.z, i.z, s.z, o.z)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        w.prototype.isCubicBezierCurve3 = !0;
        class M extends l {
            constructor(t=new a.P, e=new a.P) {
                super(),
                this.type = "LineCurve3",
                this.isLineCurve3 = !0,
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new a.P) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
                n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        class T extends l {
            constructor(t=new i.F, e=new i.F, n=new i.F) {
                super(),
                this.type = "QuadraticBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n
            }
            getPoint(t, e=new i.F) {
                const n = e
                  , r = this.v0
                  , s = this.v1
                  , a = this.v2;
                return n.set(y(t, r.x, s.x, a.x), y(t, r.y, s.y, a.y)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        T.prototype.isQuadraticBezierCurve = !0;
        class S extends l {
            constructor(t=new a.P, e=new a.P, n=new a.P) {
                super(),
                this.type = "QuadraticBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n
            }
            getPoint(t, e=new a.P) {
                const n = e
                  , r = this.v0
                  , i = this.v1
                  , s = this.v2;
                return n.set(y(t, r.x, i.x, s.x), y(t, r.y, i.y, s.y), y(t, r.z, i.z, s.z)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        S.prototype.isQuadraticBezierCurve3 = !0;
        class E extends l {
            constructor(t=[]) {
                super(),
                this.type = "SplineCurve",
                this.points = t
            }
            getPoint(t, e=new i.F) {
                const n = e
                  , r = this.points
                  , s = (r.length - 1) * t
                  , a = Math.floor(s)
                  , o = s - a
                  , l = r[0 === a ? a : a - 1]
                  , c = r[a]
                  , u = r[a > r.length - 2 ? r.length - 1 : a + 1]
                  , h = r[a > r.length - 3 ? r.length - 1 : a + 2];
                return n.set(_(o, l.x, c.x, u.x, h.x), _(o, l.y, c.y, u.y, h.y)),
                n
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new i.F).fromArray(n))
                }
                return this
            }
        }
        E.prototype.isSplineCurve = !0;
        class A extends l {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0)
                  , e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new c(e,t))
            }
            getPoint(t) {
                const e = t * this.getLength()
                  , n = this.getCurveLengths();
                let r = 0;
                for (; r < n.length; ) {
                    if (n[r] >= e) {
                        const t = n[r] - e
                          , i = this.curves[r]
                          , s = i.getLength()
                          , a = 0 === s ? 0 : 1 - t / s;
                        return i.getPointAt(a)
                    }
                    r++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, r = this.curves.length; n < r; n++)
                    e += this.curves[n].getLength(),
                    t.push(e);
                return this.cacheLengths = t,
                t
            }
            getSpacedPoints(t=40) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]),
                e
            }
            getPoints(t=12) {
                const e = [];
                let n;
                for (let r = 0, i = this.curves; r < i.length; r++) {
                    const s = i[r]
                      , a = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
                      , o = s.getPoints(a);
                    for (let t = 0; t < o.length; t++) {
                        const r = o[t];
                        n && n.equals(r) || (e.push(r),
                        n = r)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
                e
            }
            copy(t) {
                super.copy(t),
                this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose,
                t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.autoClose = t.autoClose,
                this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new r[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class R extends A {
            constructor(t) {
                super(),
                this.type = "Path",
                this.currentPoint = new i.F,
                t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++)
                    this.lineTo(t[e].x, t[e].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e),
                this
            }
            lineTo(t, e) {
                const n = new c(this.currentPoint.clone(),new i.F(t,e));
                return this.curves.push(n),
                this.currentPoint.set(t, e),
                this
            }
            quadraticCurveTo(t, e, n, r) {
                const s = new T(this.currentPoint.clone(),new i.F(t,e),new i.F(n,r));
                return this.curves.push(s),
                this.currentPoint.set(n, r),
                this
            }
            bezierCurveTo(t, e, n, r, s, a) {
                const o = new b(this.currentPoint.clone(),new i.F(t,e),new i.F(n,r),new i.F(s,a));
                return this.curves.push(o),
                this.currentPoint.set(s, a),
                this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t)
                  , n = new E(e);
                return this.curves.push(n),
                this.currentPoint.copy(t[t.length - 1]),
                this
            }
            arc(t, e, n, r, i, s) {
                const a = this.currentPoint.x
                  , o = this.currentPoint.y;
                return this.absarc(t + a, e + o, n, r, i, s),
                this
            }
            absarc(t, e, n, r, i, s) {
                return this.absellipse(t, e, n, n, r, i, s),
                this
            }
            ellipse(t, e, n, r, i, s, a, o) {
                const l = this.currentPoint.x
                  , c = this.currentPoint.y;
                return this.absellipse(t + l, e + c, n, r, i, s, a, o),
                this
            }
            absellipse(t, e, n, r, i, s, a, o) {
                const l = new u(t,e,n,r,i,s,a,o);
                if (this.curves.length > 0) {
                    const t = l.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c),
                this
            }
            copy(t) {
                return super.copy(t),
                this.currentPoint.copy(t.currentPoint),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.currentPoint.fromArray(t.currentPoint),
                this
            }
        }
        class L extends R {
            constructor(t) {
                super(t),
                this.uuid = s.DO(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let n = 0, r = this.holes.length; n < r; n++)
                    e[n] = this.holes[n].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(t) {
                super.copy(t),
                this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid,
                t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.uuid = t.uuid,
                this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new R).fromJSON(n))
                }
                return this
            }
        }
    },
    1516: function(t, e, n) {
        n.d(e, {
            T: function() {
                return d
            }
        });
        var r = n(9046)
          , i = n(140)
          , s = n(2043)
          , a = n(8121)
          , o = n(6881);
        const l = new o.P
          , c = new o.P
          , u = new o.P
          , h = new a.C;
        class d extends r.u {
            constructor(t, e) {
                if (super(),
                this.type = "EdgesGeometry",
                this.parameters = {
                    thresholdAngle: e
                },
                e = void 0 !== e ? e : 1,
                !0 === t.isGeometry)
                    return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                const n = Math.pow(10, 4)
                  , r = Math.cos(s.qW * e)
                  , a = t.getIndex()
                  , o = t.getAttribute("position")
                  , d = a ? a.count : o.count
                  , f = [0, 0, 0]
                  , p = ["a", "b", "c"]
                  , m = new Array(3)
                  , g = {}
                  , v = [];
                for (let t = 0; t < d; t += 3) {
                    a ? (f[0] = a.getX(t),
                    f[1] = a.getX(t + 1),
                    f[2] = a.getX(t + 2)) : (f[0] = t,
                    f[1] = t + 1,
                    f[2] = t + 2);
                    const {a: e, b: i, c: s} = h;
                    if (e.fromBufferAttribute(o, f[0]),
                    i.fromBufferAttribute(o, f[1]),
                    s.fromBufferAttribute(o, f[2]),
                    h.getNormal(u),
                    m[0] = `${Math.round(e.x * n)},${Math.round(e.y * n)},${Math.round(e.z * n)}`,
                    m[1] = `${Math.round(i.x * n)},${Math.round(i.y * n)},${Math.round(i.z * n)}`,
                    m[2] = `${Math.round(s.x * n)},${Math.round(s.y * n)},${Math.round(s.z * n)}`,
                    m[0] !== m[1] && m[1] !== m[2] && m[2] !== m[0])
                        for (let t = 0; t < 3; t++) {
                            const e = (t + 1) % 3
                              , n = m[t]
                              , i = m[e]
                              , s = h[p[t]]
                              , a = h[p[e]]
                              , o = `${n}_ ${i}`
                              , l = `${i}_ ${n}`;
                            l in g && g[l] ? (u.dot(g[l].normal) <= r && (v.push(s.x, s.y, s.z),
                            v.push(a.x, a.y, a.z)),
                            g[l] = null) : o in g || (g[o] = {
                                index0: f[t],
                                index1: f[e],
                                normal: u.clone()
                            })
                        }
                }
                for (const t in g)
                    if (g[t]) {
                        const {index0: e, index1: n} = g[t];
                        l.fromBufferAttribute(o, e),
                        c.fromBufferAttribute(o, n),
                        v.push(l.x, l.y, l.z),
                        v.push(c.x, c.y, c.z)
                    }
                this.setAttribute("position", new i.a$(v,3))
            }
        }
    },
    4078: function(t, e, n) {
        n.d(e, {
            B: function() {
                return s
            },
            _: function() {
                return s
            }
        });
        var r = n(9046)
          , i = n(140);
        class s extends r.u {
            constructor(t=1, e=1, n=1, r=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r
                };
                const s = t / 2
                  , a = e / 2
                  , o = Math.floor(n)
                  , l = Math.floor(r)
                  , c = o + 1
                  , u = l + 1
                  , h = t / o
                  , d = e / l
                  , f = []
                  , p = []
                  , m = []
                  , g = [];
                for (let t = 0; t < u; t++) {
                    const e = t * d - a;
                    for (let n = 0; n < c; n++) {
                        const r = n * h - s;
                        p.push(r, -e, 0),
                        m.push(0, 0, 1),
                        g.push(n / o),
                        g.push(1 - t / l)
                    }
                }
                for (let t = 0; t < l; t++)
                    for (let e = 0; e < o; e++) {
                        const n = e + c * t
                          , r = e + c * (t + 1)
                          , i = e + 1 + c * (t + 1)
                          , s = e + 1 + c * t;
                        f.push(n, r, s),
                        f.push(r, i, s)
                    }
                this.setIndex(f),
                this.setAttribute("position", new i.a$(p,3)),
                this.setAttribute("normal", new i.a$(m,3)),
                this.setAttribute("uv", new i.a$(g,2))
            }
            static fromJSON(t) {
                return new s(t.width,t.height,t.widthSegments,t.heightSegments)
            }
        }
    },
    7010: function(t, e, n) {
        n.d(e, {
            o: function() {
                return I
            }
        });
        var r = n(9046)
          , i = n(140);
        const s = function(t, e, n=2) {
            const r = e && e.length
              , i = r ? e[0] * n : t.length;
            let s = a(t, 0, i, n, !0);
            const c = [];
            if (!s || s.next === s.prev)
                return c;
            let u, h, d, m, g, _, y;
            if (r && (s = function(t, e, n, r) {
                const i = [];
                let s, l, c, u, h;
                for (s = 0,
                l = e.length; s < l; s++)
                    c = e[s] * r,
                    u = s < l - 1 ? e[s + 1] * r : t.length,
                    h = a(t, c, u, r, !1),
                    h === h.next && (h.steiner = !0),
                    i.push(v(h));
                for (i.sort(f),
                s = 0; s < i.length; s++)
                    p(i[s], n),
                    n = o(n, n.next);
                return n
            }(t, e, s, n)),
            t.length > 80 * n) {
                u = d = t[0],
                h = m = t[1];
                for (let e = n; e < i; e += n)
                    g = t[e],
                    _ = t[e + 1],
                    g < u && (u = g),
                    _ < h && (h = _),
                    g > d && (d = g),
                    _ > m && (m = _);
                y = Math.max(d - u, m - h),
                y = 0 !== y ? 1 / y : 0
            }
            return l(s, c, n, u, h, y),
            c
        };
        function a(t, e, n, r, i) {
            let s, a;
            if (i === function(t, e, n, r) {
                let i = 0;
                for (let s = e, a = n - r; s < n; s += r)
                    i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]),
                    a = s;
                return i
            }(t, e, n, r) > 0)
                for (s = e; s < n; s += r)
                    a = A(s, t[s], t[s + 1], a);
            else
                for (s = n - r; s >= e; s -= r)
                    a = A(s, t[s], t[s + 1], a);
            return a && b(a, a.next) && (R(a),
            a = a.next),
            a
        }
        function o(t, e) {
            if (!t)
                return t;
            e || (e = t);
            let n, r = t;
            do {
                if (n = !1,
                r.steiner || !b(r, r.next) && 0 !== x(r.prev, r, r.next))
                    r = r.next;
                else {
                    if (R(r),
                    r = e = r.prev,
                    r === r.next)
                        break;
                    n = !0
                }
            } while (n || r !== e);
            return e
        }
        function l(t, e, n, r, i, s, a) {
            if (!t)
                return;
            !a && s && function(t, e, n, r) {
                let i = t;
                do {
                    null === i.z && (i.z = g(i.x, i.y, e, n, r)),
                    i.prevZ = i.prev,
                    i.nextZ = i.next,
                    i = i.next
                } while (i !== t);
                i.prevZ.nextZ = null,
                i.prevZ = null,
                function(t) {
                    let e, n, r, i, s, a, o, l, c = 1;
                    do {
                        for (n = t,
                        t = null,
                        s = null,
                        a = 0; n; ) {
                            for (a++,
                            r = n,
                            o = 0,
                            e = 0; e < c && (o++,
                            r = r.nextZ,
                            r); e++)
                                ;
                            for (l = c; o > 0 || l > 0 && r; )
                                0 !== o && (0 === l || !r || n.z <= r.z) ? (i = n,
                                n = n.nextZ,
                                o--) : (i = r,
                                r = r.nextZ,
                                l--),
                                s ? s.nextZ = i : t = i,
                                i.prevZ = s,
                                s = i;
                            n = r
                        }
                        s.nextZ = null,
                        c *= 2
                    } while (a > 1)
                }(i)
            }(t, r, i, s);
            let f, p, m = t;
            for (; t.prev !== t.next; )
                if (f = t.prev,
                p = t.next,
                s ? u(t, r, i, s) : c(t))
                    e.push(f.i / n),
                    e.push(t.i / n),
                    e.push(p.i / n),
                    R(t),
                    t = p.next,
                    m = p.next;
                else if ((t = p) === m) {
                    a ? 1 === a ? l(t = h(o(t), e, n), e, n, r, i, s, 2) : 2 === a && d(t, e, n, r, i, s) : l(o(t), e, n, r, i, s, 1);
                    break
                }
        }
        function c(t) {
            const e = t.prev
              , n = t
              , r = t.next;
            if (x(e, n, r) >= 0)
                return !1;
            let i = t.next.next;
            for (; i !== t.prev; ) {
                if (_(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && x(i.prev, i, i.next) >= 0)
                    return !1;
                i = i.next
            }
            return !0
        }
        function u(t, e, n, r) {
            const i = t.prev
              , s = t
              , a = t.next;
            if (x(i, s, a) >= 0)
                return !1;
            const o = i.x < s.x ? i.x < a.x ? i.x : a.x : s.x < a.x ? s.x : a.x
              , l = i.y < s.y ? i.y < a.y ? i.y : a.y : s.y < a.y ? s.y : a.y
              , c = i.x > s.x ? i.x > a.x ? i.x : a.x : s.x > a.x ? s.x : a.x
              , u = i.y > s.y ? i.y > a.y ? i.y : a.y : s.y > a.y ? s.y : a.y
              , h = g(o, l, e, n, r)
              , d = g(c, u, e, n, r);
            let f = t.prevZ
              , p = t.nextZ;
            for (; f && f.z >= h && p && p.z <= d; ) {
                if (f !== t.prev && f !== t.next && _(i.x, i.y, s.x, s.y, a.x, a.y, f.x, f.y) && x(f.prev, f, f.next) >= 0)
                    return !1;
                if (f = f.prevZ,
                p !== t.prev && p !== t.next && _(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && x(p.prev, p, p.next) >= 0)
                    return !1;
                p = p.nextZ
            }
            for (; f && f.z >= h; ) {
                if (f !== t.prev && f !== t.next && _(i.x, i.y, s.x, s.y, a.x, a.y, f.x, f.y) && x(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.prevZ
            }
            for (; p && p.z <= d; ) {
                if (p !== t.prev && p !== t.next && _(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && x(p.prev, p, p.next) >= 0)
                    return !1;
                p = p.nextZ
            }
            return !0
        }
        function h(t, e, n) {
            let r = t;
            do {
                const i = r.prev
                  , s = r.next.next;
                !b(i, s) && w(i, r, r.next, s) && S(i, s) && S(s, i) && (e.push(i.i / n),
                e.push(r.i / n),
                e.push(s.i / n),
                R(r),
                R(r.next),
                r = t = s),
                r = r.next
            } while (r !== t);
            return o(r)
        }
        function d(t, e, n, r, i, s) {
            let a = t;
            do {
                let t = a.next.next;
                for (; t !== a.prev; ) {
                    if (a.i !== t.i && y(a, t)) {
                        let c = E(a, t);
                        return a = o(a, a.next),
                        c = o(c, c.next),
                        l(a, e, n, r, i, s),
                        void l(c, e, n, r, i, s)
                    }
                    t = t.next
                }
                a = a.next
            } while (a !== t)
        }
        function f(t, e) {
            return t.x - e.x
        }
        function p(t, e) {
            if (e = function(t, e) {
                let n = e;
                const r = t.x
                  , i = t.y;
                let s, a = -1 / 0;
                do {
                    if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                        const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (t <= r && t > a) {
                            if (a = t,
                            t === r) {
                                if (i === n.y)
                                    return n;
                                if (i === n.next.y)
                                    return n.next
                            }
                            s = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!s)
                    return null;
                if (r === a)
                    return s;
                const o = s
                  , l = s.x
                  , c = s.y;
                let u, h = 1 / 0;
                n = s;
                do {
                    r >= n.x && n.x >= l && r !== n.x && _(i < c ? r : a, i, l, c, i < c ? a : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x),
                    S(n, t) && (u < h || u === h && (n.x > s.x || n.x === s.x && m(s, n))) && (s = n,
                    h = u)),
                    n = n.next
                } while (n !== o);
                return s
            }(t, e),
            e) {
                const n = E(e, t);
                o(e, e.next),
                o(n, n.next)
            }
        }
        function m(t, e) {
            return x(t.prev, t, e.prev) < 0 && x(e.next, t, t.next) < 0
        }
        function g(t, e, n, r, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function v(t) {
            let e = t
              , n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
                e = e.next
            } while (e !== t);
            return n
        }
        function _(t, e, n, r, i, s, a, o) {
            return (i - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (r - o) - (n - a) * (e - o) >= 0 && (n - a) * (s - o) - (i - a) * (r - o) >= 0
        }
        function y(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && w(n, n.next, t, e))
                        return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }(t, e) && (S(t, e) && S(e, t) && function(t, e) {
                let n = t
                  , r = !1;
                const i = (t.x + e.x) / 2
                  , s = (t.y + e.y) / 2;
                do {
                    n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r),
                    n = n.next
                } while (n !== t);
                return r
            }(t, e) && (x(t.prev, t, e.prev) || x(t, e.prev, e)) || b(t, e) && x(t.prev, t, t.next) > 0 && x(e.prev, e, e.next) > 0)
        }
        function x(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }
        function b(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function w(t, e, n, r) {
            const i = T(x(t, e, n))
              , s = T(x(t, e, r))
              , a = T(x(n, r, t))
              , o = T(x(n, r, e));
            return i !== s && a !== o || (!(0 !== i || !M(t, n, e)) || (!(0 !== s || !M(t, r, e)) || (!(0 !== a || !M(n, t, r)) || !(0 !== o || !M(n, e, r)))))
        }
        function M(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }
        function T(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function S(t, e) {
            return x(t.prev, t, t.next) < 0 ? x(t, e, t.next) >= 0 && x(t, t.prev, e) >= 0 : x(t, e, t.prev) < 0 || x(t, t.next, e) < 0
        }
        function E(t, e) {
            const n = new L(t.i,t.x,t.y)
              , r = new L(e.i,e.x,e.y)
              , i = t.next
              , s = e.prev;
            return t.next = e,
            e.prev = t,
            n.next = i,
            i.prev = n,
            r.next = n,
            n.prev = r,
            s.next = r,
            r.prev = s,
            r
        }
        function A(t, e, n, r) {
            const i = new L(t,e,n);
            return r ? (i.next = r.next,
            i.prev = r,
            r.next.prev = i,
            r.next = i) : (i.prev = i,
            i.next = i),
            i
        }
        function R(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function L(t, e, n) {
            this.i = t,
            this.x = e,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = null,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class P {
            static area(t) {
                const e = t.length;
                let n = 0;
                for (let r = e - 1, i = 0; i < e; r = i++)
                    n += t[r].x * t[i].y - t[i].x * t[r].y;
                return .5 * n
            }
            static isClockWise(t) {
                return P.area(t) < 0
            }
            static triangulateShape(t, e) {
                const n = []
                  , r = []
                  , i = [];
                C(t),
                D(n, t);
                let a = t.length;
                e.forEach(C);
                for (let t = 0; t < e.length; t++)
                    r.push(a),
                    a += e[t].length,
                    D(n, e[t]);
                const o = s(n, r);
                for (let t = 0; t < o.length; t += 3)
                    i.push(o.slice(t, t + 3));
                return i
            }
        }
        function C(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }
        function D(t, e) {
            for (let n = 0; n < e.length; n++)
                t.push(e[n].x),
                t.push(e[n].y)
        }
        class I extends r.u {
            constructor(t, e=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const n = []
                  , r = []
                  , s = []
                  , a = [];
                let o = 0
                  , l = 0;
                if (!1 === Array.isArray(t))
                    c(t);
                else
                    for (let e = 0; e < t.length; e++)
                        c(t[e]),
                        this.addGroup(o, l, e),
                        o += l,
                        l = 0;
                function c(t) {
                    const i = r.length / 3
                      , o = t.extractPoints(e);
                    let c = o.shape;
                    const u = o.holes;
                    !1 === P.isClockWise(c) && (c = c.reverse());
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        !0 === P.isClockWise(e) && (u[t] = e.reverse())
                    }
                    const h = P.triangulateShape(c, u);
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        c = c.concat(e)
                    }
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        r.push(e.x, e.y, 0),
                        s.push(0, 0, 1),
                        a.push(e.x, e.y)
                    }
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t]
                          , r = e[0] + i
                          , s = e[1] + i
                          , a = e[2] + i;
                        n.push(r, s, a),
                        l += 3
                    }
                }
                this.setIndex(n),
                this.setAttribute("position", new i.a$(r,3)),
                this.setAttribute("normal", new i.a$(s,3)),
                this.setAttribute("uv", new i.a$(a,2))
            }
            toJSON() {
                const t = super.toJSON();
                return function(t, e) {
                    if (e.shapes = [],
                    Array.isArray(t))
                        for (let n = 0, r = t.length; n < r; n++) {
                            const r = t[n];
                            e.shapes.push(r.uuid)
                        }
                    else
                        e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
            static fromJSON(t, e) {
                const n = [];
                for (let r = 0, i = t.shapes.length; r < i; r++) {
                    const i = e[t.shapes[r]];
                    n.push(i)
                }
                return new I(n,t.curveSegments)
            }
        }
    },
    2626: function(t, e, n) {
        n.d(e, {
            C: function() {
                return r
            }
        });
        const r = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        }
    },
    3460: function(t, e, n) {
        n.d(e, {
            c: function() {
                return a
            }
        });
        var r = n(5824)
          , i = n(3882)
          , s = n(5183);
        class a extends s.a {
            constructor(t) {
                super(t)
            }
            load(t, e, n, s) {
                const a = new i.B
                  , o = new r.S(this.manager);
                o.setCrossOrigin(this.crossOrigin),
                o.setPath(this.path);
                let l = 0;
                function c(n) {
                    o.load(t[n], (function(t) {
                        a.images[n] = t,
                        l++,
                        6 === l && (a.needsUpdate = !0,
                        e && e(a))
                    }
                    ), void 0, s)
                }
                for (let e = 0; e < t.length; ++e)
                    c(e);
                return a
            }
        }
    },
    5092: function(t, e, n) {
        n.d(e, {
            h: function() {
                return a
            }
        });
        var r = n(2626)
          , i = n(5183);
        const s = {};
        class a extends i.a {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const a = this
                  , o = r.C.get(t);
                if (void 0 !== o)
                    return a.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(o),
                        a.manager.itemEnd(t)
                    }
                    ), 0),
                    o;
                if (void 0 !== s[t])
                    return void s[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                const l = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                let c;
                if (l) {
                    const n = l[1]
                      , r = !!l[2];
                    let s = l[3];
                    s = decodeURIComponent(s),
                    r && (s = atob(s));
                    try {
                        let r;
                        const i = (this.responseType || "").toLowerCase();
                        switch (i) {
                        case "arraybuffer":
                        case "blob":
                            const t = new Uint8Array(s.length);
                            for (let e = 0; e < s.length; e++)
                                t[e] = s.charCodeAt(e);
                            r = "blob" === i ? new Blob([t.buffer],{
                                type: n
                            }) : t.buffer;
                            break;
                        case "document":
                            const e = new DOMParser;
                            r = e.parseFromString(s, n);
                            break;
                        case "json":
                            r = JSON.parse(s);
                            break;
                        default:
                            r = s
                        }
                        setTimeout((function() {
                            e && e(r),
                            a.manager.itemEnd(t)
                        }
                        ), 0)
                    } catch (e) {
                        setTimeout((function() {
                            i && i(e),
                            a.manager.itemError(t),
                            a.manager.itemEnd(t)
                        }
                        ), 0)
                    }
                } else {
                    s[t] = [],
                    s[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    }),
                    c = new XMLHttpRequest,
                    c.open("GET", t, !0),
                    c.addEventListener("load", (function(e) {
                        const n = this.response
                          , i = s[t];
                        if (delete s[t],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            r.C.add(t, n);
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t];
                                e.onLoad && e.onLoad(n)
                            }
                            a.manager.itemEnd(t)
                        } else {
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = i[t];
                                n.onError && n.onError(e)
                            }
                            a.manager.itemError(t),
                            a.manager.itemEnd(t)
                        }
                    }
                    ), !1),
                    c.addEventListener("progress", (function(e) {
                        const n = s[t];
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            r.onProgress && r.onProgress(e)
                        }
                    }
                    ), !1),
                    c.addEventListener("error", (function(e) {
                        const n = s[t];
                        delete s[t];
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            r.onError && r.onError(e)
                        }
                        a.manager.itemError(t),
                        a.manager.itemEnd(t)
                    }
                    ), !1),
                    c.addEventListener("abort", (function(e) {
                        const n = s[t];
                        delete s[t];
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            r.onError && r.onError(e)
                        }
                        a.manager.itemError(t),
                        a.manager.itemEnd(t)
                    }
                    ), !1),
                    void 0 !== this.responseType && (c.responseType = this.responseType),
                    void 0 !== this.withCredentials && (c.withCredentials = this.withCredentials),
                    c.overrideMimeType && c.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (const t in this.requestHeader)
                        c.setRequestHeader(t, this.requestHeader[t]);
                    c.send(null)
                }
                return a.manager.itemStart(t),
                c
            }
            setResponseType(t) {
                return this.responseType = t,
                this
            }
            setMimeType(t) {
                return this.mimeType = t,
                this
            }
        }
    },
    5824: function(t, e, n) {
        n.d(e, {
            S: function() {
                return s
            }
        });
        var r = n(2626)
          , i = n(5183);
        class s extends i.a {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const s = this
                  , a = r.C.get(t);
                if (void 0 !== a)
                    return s.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(a),
                        s.manager.itemEnd(t)
                    }
                    ), 0),
                    a;
                const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                function l() {
                    o.removeEventListener("load", l, !1),
                    o.removeEventListener("error", c, !1),
                    r.C.add(t, this),
                    e && e(this),
                    s.manager.itemEnd(t)
                }
                function c(e) {
                    o.removeEventListener("load", l, !1),
                    o.removeEventListener("error", c, !1),
                    i && i(e),
                    s.manager.itemError(t),
                    s.manager.itemEnd(t)
                }
                return o.addEventListener("load", l, !1),
                o.addEventListener("error", c, !1),
                "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
                s.manager.itemStart(t),
                o.src = t,
                o
            }
        }
    },
    5183: function(t, e, n) {
        n.d(e, {
            a: function() {
                return i
            }
        });
        const r = new class {
            constructor(t, e, n) {
                const r = this;
                let i, s = !1, a = 0, o = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = n,
                this.itemStart = function(t) {
                    o++,
                    !1 === s && void 0 !== r.onStart && r.onStart(t, a, o),
                    s = !0
                }
                ,
                this.itemEnd = function(t) {
                    a++,
                    void 0 !== r.onProgress && r.onProgress(t, a, o),
                    a === o && (s = !1,
                    void 0 !== r.onLoad && r.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== r.onError && r.onError(t)
                }
                ,
                this.resolveURL = function(t) {
                    return i ? i(t) : t
                }
                ,
                this.setURLModifier = function(t) {
                    return i = t,
                    this
                }
                ,
                this.addHandler = function(t, e) {
                    return l.push(t, e),
                    this
                }
                ,
                this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2),
                    this
                }
                ,
                this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e]
                          , r = l[e + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(t))
                            return r
                    }
                    return null
                }
            }
        }
        ;
        class i {
            constructor(t) {
                this.manager = void 0 !== t ? t : r,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(r, i) {
                    n.load(t, r, e, i)
                }
                ))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t,
                this
            }
            setWithCredentials(t) {
                return this.withCredentials = t,
                this
            }
            setPath(t) {
                return this.path = t,
                this
            }
            setResourcePath(t) {
                return this.resourcePath = t,
                this
            }
            setRequestHeader(t) {
                return this.requestHeader = t,
                this
            }
        }
    },
    3278: function(t, e, n) {
        n.d(e, {
            d: function() {
                return o
            }
        });
        var r = n(1661)
          , i = n(5824)
          , s = n(1244)
          , a = n(5183);
        class o extends a.a {
            constructor(t) {
                super(t)
            }
            load(t, e, n, a) {
                const o = new s.x
                  , l = new i.S(this.manager);
                return l.setCrossOrigin(this.crossOrigin),
                l.setPath(this.path),
                l.load(t, (function(n) {
                    o.image = n;
                    const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    o.format = i ? r.UCm : r.wk1,
                    o.needsUpdate = !0,
                    void 0 !== e && e(o)
                }
                ), n, a),
                o
            }
        }
    },
    5785: function(t, e, n) {
        n.d(e, {
            n: function() {
                return s
            }
        });
        var r = n(4164)
          , i = n(3662);
        class s extends r.F {
            constructor(t) {
                super(),
                this.type = "LineBasicMaterial",
                this.color = new i.I(16777215),
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this
            }
        }
        s.prototype.isLineBasicMaterial = !0
    },
    4164: function(t, e, n) {
        n.d(e, {
            F: function() {
                return o
            }
        });
        var r = n(7406)
          , i = n(1661)
          , s = n(2043);
        let a = 0;
        class o extends r.p {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: a++
                }),
                this.uuid = s.DO(),
                this.name = "",
                this.type = "Material",
                this.fog = !0,
                this.blending = i.bdR,
                this.side = i.Wl3,
                this.vertexColors = !1,
                this.opacity = 1,
                this.format = i.wk1,
                this.transparent = !1,
                this.blendSrc = i.k74,
                this.blendDst = i.LgZ,
                this.blendEquation = i.bGH,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = i.vCF,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = i.cum,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = i.x5V,
                this.stencilZFail = i.x5V,
                this.stencilZPass = i.x5V,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++,
                this._alphaTest = t
            }
            onBuild() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = n === i.esl;
                            continue
                        }
                        const r = this[e];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function r(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        delete r.metadata,
                        e.push(r)
                    }
                    return e
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                this.blending !== i.bdR && (n.blending = this.blending),
                this.side !== i.Wl3 && (n.side = this.side),
                this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                this.format !== i.wk1 && (n.format = this.format),
                !0 === this.transparent && (n.transparent = this.transparent),
                n.depthFunc = this.depthFunc,
                n.depthTest = this.depthTest,
                n.depthWrite = this.depthWrite,
                n.colorWrite = this.colorWrite,
                n.stencilWrite = this.stencilWrite,
                n.stencilWriteMask = this.stencilWriteMask,
                n.stencilFunc = this.stencilFunc,
                n.stencilRef = this.stencilRef,
                n.stencilFuncMask = this.stencilFuncMask,
                n.stencilFail = this.stencilFail,
                n.stencilZFail = this.stencilZFail,
                n.stencilZPass = this.stencilZPass,
                this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                !0 === this.wireframe && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = this.flatShading),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                e) {
                    const e = r(t.textures)
                      , i = r(t.images);
                    e.length > 0 && (n.textures = e),
                    i.length > 0 && (n.images = i)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name,
                this.fog = t.fog,
                this.blending = t.blending,
                this.side = t.side,
                this.vertexColors = t.vertexColors,
                this.opacity = t.opacity,
                this.format = t.format,
                this.transparent = t.transparent,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.stencilWriteMask = t.stencilWriteMask,
                this.stencilFunc = t.stencilFunc,
                this.stencilRef = t.stencilRef,
                this.stencilFuncMask = t.stencilFuncMask,
                this.stencilFail = t.stencilFail,
                this.stencilZFail = t.stencilZFail,
                this.stencilZPass = t.stencilZPass,
                this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let r = 0; r !== t; ++r)
                        n[r] = e[r].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = t.clipIntersection,
                this.clipShadows = t.clipShadows,
                this.shadowSide = t.shadowSide,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.dithering = t.dithering,
                this.alphaTest = t.alphaTest,
                this.alphaToCoverage = t.alphaToCoverage,
                this.premultipliedAlpha = t.premultipliedAlpha,
                this.visible = t.visible,
                this.toneMapped = t.toneMapped,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        o.prototype.isMaterial = !0
    },
    6173: function(t, e, n) {
        n.d(e, {
            v: function() {
                return a
            }
        });
        var r = n(4164)
          , i = n(1661)
          , s = n(3662);
        class a extends r.F {
            constructor(t) {
                super(),
                this.type = "MeshBasicMaterial",
                this.color = new s.I(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = i.Ns1,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this
            }
        }
        a.prototype.isMeshBasicMaterial = !0
    },
    2114: function(t, e, n) {
        n.d(e, {
            l: function() {
                return s
            }
        });
        var r = n(4164)
          , i = n(1661);
        class s extends r.F {
            constructor(t) {
                super(),
                this.type = "MeshDepthMaterial",
                this.depthPacking = i.z81,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.depthPacking = t.depthPacking,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
        }
        s.prototype.isMeshDepthMaterial = !0
    },
    8549: function(t, e, n) {
        n.d(e, {
            F: function() {
                return i
            }
        });
        var r = n(876);
        class i extends r.j {
            constructor(t) {
                super(t),
                this.type = "RawShaderMaterial"
            }
        }
        i.prototype.isRawShaderMaterial = !0
    },
    876: function(t, e, n) {
        n.d(e, {
            j: function() {
                return s
            }
        });
        var r = n(4164)
          , i = n(6682);
        class s extends r.F {
            constructor(t) {
                super(),
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.vertexShader = "\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",
                this.fragmentShader = "\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                this.setValues(t))
            }
            copy(t) {
                return super.copy(t),
                this.fragmentShader = t.fragmentShader,
                this.vertexShader = t.vertexShader,
                this.uniforms = (0,
                i.dw)(t.uniforms),
                this.defines = Object.assign({}, t.defines),
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.lights = t.lights,
                this.clipping = t.clipping,
                this.extensions = Object.assign({}, t.extensions),
                this.glslVersion = t.glslVersion,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion,
                e.uniforms = {};
                for (const n in this.uniforms) {
                    const r = this.uniforms[n].value;
                    r && r.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[n] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                e.vertexShader = this.vertexShader,
                e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions)
                    !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n),
                e
            }
        }
        s.prototype.isShaderMaterial = !0
    },
    1898: function(t, e, n) {
        n.d(e, {
            Z: function() {
                return i
            }
        });
        var r = n(6881);
        class i {
            constructor(t=new r.P(1 / 0,1 / 0,1 / 0), e=new r.P(-1 / 0,-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromArray(t) {
                let e = 1 / 0
                  , n = 1 / 0
                  , r = 1 / 0
                  , i = -1 / 0
                  , s = -1 / 0
                  , a = -1 / 0;
                for (let o = 0, l = t.length; o < l; o += 3) {
                    const l = t[o]
                      , c = t[o + 1]
                      , u = t[o + 2];
                    l < e && (e = l),
                    c < n && (n = c),
                    u < r && (r = u),
                    l > i && (i = l),
                    c > s && (s = c),
                    u > a && (a = u)
                }
                return this.min.set(e, n, r),
                this.max.set(i, s, a),
                this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0
                  , n = 1 / 0
                  , r = 1 / 0
                  , i = -1 / 0
                  , s = -1 / 0
                  , a = -1 / 0;
                for (let o = 0, l = t.count; o < l; o++) {
                    const l = t.getX(o)
                      , c = t.getY(o)
                      , u = t.getZ(o);
                    l < e && (e = l),
                    c < n && (n = c),
                    u < r && (r = u),
                    l > i && (i = l),
                    c > s && (s = c),
                    u > a && (a = u)
                }
                return this.min.set(e, n, r),
                this.max.set(i, s, a),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = a.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            setFromObject(t) {
                return this.makeEmpty(),
                this.expandByObject(t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            expandByObject(t) {
                t.updateWorldMatrix(!1, !1);
                const e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
                o.copy(e.boundingBox),
                o.applyMatrix4(t.matrixWorld),
                this.union(o));
                const n = t.children;
                for (let t = 0, e = n.length; t < e; t++)
                    this.expandByObject(n[t]);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, a),
                a.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                n = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                n += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                n += t.normal.z * this.min.z),
                e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(p),
                m.subVectors(this.max, p),
                l.subVectors(t.a, p),
                c.subVectors(t.b, p),
                u.subVectors(t.c, p),
                h.subVectors(c, l),
                d.subVectors(u, c),
                f.subVectors(l, u);
                let e = [0, -h.z, h.y, 0, -d.z, d.y, 0, -f.z, f.y, h.z, 0, -h.x, d.z, 0, -d.x, f.z, 0, -f.x, -h.y, h.x, 0, -d.y, d.x, 0, -f.y, f.x, 0];
                return !!_(e, l, c, u, m) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!_(e, l, c, u, m) && (g.crossVectors(h, d),
                e = [g.x, g.y, g.z],
                _(e, l, c, u, m)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return a.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return this.getCenter(t.center),
                t.radius = .5 * this.getSize(a).length(),
                t
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (s[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                s[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                s[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                s[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                s[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                s[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                s[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                s[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(s)),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        i.prototype.isBox3 = !0;
        const s = [new r.P, new r.P, new r.P, new r.P, new r.P, new r.P, new r.P, new r.P]
          , a = new r.P
          , o = new i
          , l = new r.P
          , c = new r.P
          , u = new r.P
          , h = new r.P
          , d = new r.P
          , f = new r.P
          , p = new r.P
          , m = new r.P
          , g = new r.P
          , v = new r.P;
        function _(t, e, n, r, i) {
            for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                v.fromArray(t, s);
                const a = i.x * Math.abs(v.x) + i.y * Math.abs(v.y) + i.z * Math.abs(v.z)
                  , o = e.dot(v)
                  , l = n.dot(v)
                  , c = r.dot(v);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a)
                    return !1
            }
            return !0
        }
    },
    3662: function(t, e, n) {
        n.d(e, {
            I: function() {
                return u
            }
        });
        var r = n(2043);
        const i = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , s = {
            h: 0,
            s: 0,
            l: 0
        }
          , a = {
            h: 0,
            s: 0,
            l: 0
        };
        function o(t, e, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        function l(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function c(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class u {
            constructor(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                this
            }
            setScalar(t) {
                return this.r = t,
                this.g = t,
                this.b = t,
                this
            }
            setHex(t) {
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                this
            }
            setRGB(t, e, n) {
                return this.r = t,
                this.g = e,
                this.b = n,
                this
            }
            setHSL(t, e, n) {
                if (t = r.kz(t, 1),
                e = r.uZ(e, 0, 1),
                n = r.uZ(n, 0, 1),
                0 === e)
                    this.r = this.g = this.b = n;
                else {
                    const r = n <= .5 ? n * (1 + e) : n + e - n * e
                      , i = 2 * n - r;
                    this.r = o(i, r, t + 1 / 3),
                    this.g = o(i, r, t),
                    this.b = o(i, r, t - 1 / 3)
                }
                return this
            }
            setStyle(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let n;
                if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const r = n[1]
                      , i = n[2];
                    switch (r) {
                    case "rgb":
                    case "rgba":
                        if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                            return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                            this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                            this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                            e(t[4]),
                            this;
                        if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                            return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                            this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                            this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                            e(t[4]),
                            this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                            const n = parseFloat(t[1]) / 360
                              , r = parseInt(t[2], 10) / 100
                              , i = parseInt(t[3], 10) / 100;
                            return e(t[4]),
                            this.setHSL(n, r, i)
                        }
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = n[1]
                      , e = t.length;
                    if (3 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                        this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                        this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                        this;
                    if (6 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                        this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                        this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                        this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }
            setColorName(t) {
                const e = i[t.toLowerCase()];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            }
            copyGammaToLinear(t, e=2) {
                return this.r = Math.pow(t.r, e),
                this.g = Math.pow(t.g, e),
                this.b = Math.pow(t.b, e),
                this
            }
            copyLinearToGamma(t, e=2) {
                const n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n),
                this.g = Math.pow(t.g, n),
                this.b = Math.pow(t.b, n),
                this
            }
            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t),
                this
            }
            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t),
                this
            }
            copySRGBToLinear(t) {
                return this.r = l(t.r),
                this.g = l(t.g),
                this.b = l(t.b),
                this
            }
            copyLinearToSRGB(t) {
                return this.r = c(t.r),
                this.g = c(t.g),
                this.b = c(t.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                const e = this.r
                  , n = this.g
                  , r = this.b
                  , i = Math.max(e, n, r)
                  , s = Math.min(e, n, r);
                let a, o;
                const l = (s + i) / 2;
                if (s === i)
                    a = 0,
                    o = 0;
                else {
                    const t = i - s;
                    switch (o = l <= .5 ? t / (i + s) : t / (2 - i - s),
                    i) {
                    case e:
                        a = (n - r) / t + (n < r ? 6 : 0);
                        break;
                    case n:
                        a = (r - e) / t + 2;
                        break;
                    case r:
                        a = (e - n) / t + 4
                    }
                    a /= 6
                }
                return t.h = a,
                t.s = o,
                t.l = l,
                t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, e, n) {
                return this.getHSL(s),
                s.h += t,
                s.s += e,
                s.l += n,
                this.setHSL(s.h, s.s, s.l),
                this
            }
            add(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            }
            addScalar(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                this.g = Math.max(0, this.g - t.g),
                this.b = Math.max(0, this.b - t.b),
                this
            }
            multiply(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            }
            multiplyScalar(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n,
                this.g = t.g + (e.g - t.g) * n,
                this.b = t.b + (e.b - t.b) * n,
                this
            }
            lerpHSL(t, e) {
                this.getHSL(s),
                t.getHSL(a);
                const n = r.t7(s.h, a.h, e)
                  , i = r.t7(s.s, a.s, e)
                  , o = r.t7(s.l, a.l, e);
                return this.setHSL(n, i, o),
                this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e=0) {
                return this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                this.g = t.getY(e),
                this.b = t.getZ(e),
                !0 === t.normalized && (this.r /= 255,
                this.g /= 255,
                this.b /= 255),
                this
            }
            toJSON() {
                return this.getHex()
            }
        }
        u.NAMES = i,
        u.prototype.isColor = !0,
        u.prototype.r = 1,
        u.prototype.g = 1,
        u.prototype.b = 1
    },
    4698: function(t, e, n) {
        n.d(e, {
            i: function() {
                return l
            }
        });
        var r = n(6881)
          , i = n(4699)
          , s = n(1158);
        const a = new i.a
          , o = new r.P;
        class l {
            constructor(t=new s.J, e=new s.J, n=new s.J, r=new s.J, i=new s.J, a=new s.J) {
                this.planes = [t, e, n, r, i, a]
            }
            set(t, e, n, r, i, s) {
                const a = this.planes;
                return a[0].copy(t),
                a[1].copy(e),
                a[2].copy(n),
                a[3].copy(r),
                a[4].copy(i),
                a[5].copy(s),
                this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes
                  , n = t.elements
                  , r = n[0]
                  , i = n[1]
                  , s = n[2]
                  , a = n[3]
                  , o = n[4]
                  , l = n[5]
                  , c = n[6]
                  , u = n[7]
                  , h = n[8]
                  , d = n[9]
                  , f = n[10]
                  , p = n[11]
                  , m = n[12]
                  , g = n[13]
                  , v = n[14]
                  , _ = n[15];
                return e[0].setComponents(a - r, u - o, p - h, _ - m).normalize(),
                e[1].setComponents(a + r, u + o, p + h, _ + m).normalize(),
                e[2].setComponents(a + i, u + l, p + d, _ + g).normalize(),
                e[3].setComponents(a - i, u - l, p - d, _ - g).normalize(),
                e[4].setComponents(a - s, u - c, p - f, _ - v).normalize(),
                e[5].setComponents(a + s, u + c, p + f, _ + v).normalize(),
                this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(),
                a.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                this.intersectsSphere(a)
            }
            intersectsSprite(t) {
                return a.center.set(0, 0, 0),
                a.radius = .7071067811865476,
                a.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(a)
            }
            intersectsSphere(t) {
                const e = this.planes
                  , n = t.center
                  , r = -t.radius;
                for (let t = 0; t < 6; t++) {
                    if (e[t].distanceToPoint(n) < r)
                        return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const r = e[n];
                    if (o.x = r.normal.x > 0 ? t.max.x : t.min.x,
                    o.y = r.normal.y > 0 ? t.max.y : t.min.y,
                    o.z = r.normal.z > 0 ? t.max.z : t.min.z,
                    r.distanceToPoint(o) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
    },
    2043: function(t, e, n) {
        n.d(e, {
            DO: function() {
                return a
            },
            I3: function() {
                return s
            },
            Id: function() {
                return f
            },
            Qy: function() {
                return d
            },
            ZY: function() {
                return p
            },
            ZZ: function() {
                return c
            },
            gy: function() {
                return v
            },
            h3: function() {
                return g
            },
            kz: function() {
                return l
            },
            qW: function() {
                return i
            },
            rO: function() {
                return h
            },
            t7: function() {
                return u
            },
            uZ: function() {
                return o
            },
            wt: function() {
                return m
            }
        });
        const r = [];
        for (let t = 0; t < 256; t++)
            r[t] = (t < 16 ? "0" : "") + t.toString(16);
        const i = Math.PI / 180
          , s = 180 / Math.PI;
        function a() {
            const t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (r[255 & t] + r[t >> 8 & 255] + r[t >> 16 & 255] + r[t >> 24 & 255] + "-" + r[255 & e] + r[e >> 8 & 255] + "-" + r[e >> 16 & 15 | 64] + r[e >> 24 & 255] + "-" + r[63 & n | 128] + r[n >> 8 & 255] + "-" + r[n >> 16 & 255] + r[n >> 24 & 255] + r[255 & i] + r[i >> 8 & 255] + r[i >> 16 & 255] + r[i >> 24 & 255]).toUpperCase()
        }
        function o(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        function l(t, e) {
            return (t % e + e) % e
        }
        function c(t, e, n, r, i) {
            return r + (t - e) * (i - r) / (n - e)
        }
        function u(t, e, n) {
            return (1 - n) * t + n * e
        }
        function h(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        }
        function d(t, e) {
            return t + Math.random() * (e - t)
        }
        function f(t) {
            return t * i
        }
        function p(t) {
            return t * s
        }
        function m(t) {
            return 0 == (t & t - 1) && 0 !== t
        }
        function g(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function v(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
    },
    1273: function(t, e, n) {
        n.d(e, {
            V: function() {
                return r
            }
        });
        class r {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, r, i, s, a, o, l) {
                const c = this.elements;
                return c[0] = t,
                c[1] = r,
                c[2] = a,
                c[3] = e,
                c[4] = i,
                c[5] = o,
                c[6] = n,
                c[7] = s,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0),
                e.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , r = e.elements
                  , i = this.elements
                  , s = n[0]
                  , a = n[3]
                  , o = n[6]
                  , l = n[1]
                  , c = n[4]
                  , u = n[7]
                  , h = n[2]
                  , d = n[5]
                  , f = n[8]
                  , p = r[0]
                  , m = r[3]
                  , g = r[6]
                  , v = r[1]
                  , _ = r[4]
                  , y = r[7]
                  , x = r[2]
                  , b = r[5]
                  , w = r[8];
                return i[0] = s * p + a * v + o * x,
                i[3] = s * m + a * _ + o * b,
                i[6] = s * g + a * y + o * w,
                i[1] = l * p + c * v + u * x,
                i[4] = l * m + c * _ + u * b,
                i[7] = l * g + c * y + u * w,
                i[2] = h * p + d * v + f * x,
                i[5] = h * m + d * _ + f * b,
                i[8] = h * g + d * y + f * w,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , r = t[2]
                  , i = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , l = t[7]
                  , c = t[8];
                return e * s * c - e * a * l - n * i * c + n * a * o + r * i * l - r * s * o
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , r = t[2]
                  , i = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = c * s - a * l
                  , h = a * o - c * i
                  , d = l * i - s * o
                  , f = e * u + n * h + r * d;
                if (0 === f)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const p = 1 / f;
                return t[0] = u * p,
                t[1] = (r * l - c * n) * p,
                t[2] = (a * n - r * s) * p,
                t[3] = h * p,
                t[4] = (c * e - r * o) * p,
                t[5] = (r * i - a * e) * p,
                t[6] = d * p,
                t[7] = (n * o - l * e) * p,
                t[8] = (s * e - n * i) * p,
                this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            }
            setUvTransform(t, e, n, r, i, s, a) {
                const o = Math.cos(i)
                  , l = Math.sin(i);
                return this.set(n * o, n * l, -n * (o * s + l * a) + s + t, -r * l, r * o, -r * (-l * s + o * a) + a + e, 0, 0, 1),
                this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t,
                n[3] *= t,
                n[6] *= t,
                n[1] *= e,
                n[4] *= e,
                n[7] *= e,
                this
            }
            rotate(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t)
                  , r = this.elements
                  , i = r[0]
                  , s = r[3]
                  , a = r[6]
                  , o = r[1]
                  , l = r[4]
                  , c = r[7];
                return r[0] = e * i + n * o,
                r[3] = e * s + n * l,
                r[6] = e * a + n * c,
                r[1] = -n * i + e * o,
                r[4] = -n * s + e * l,
                r[7] = -n * a + e * c,
                this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2],
                n[3] += t * n[5],
                n[6] += t * n[8],
                n[1] += e * n[2],
                n[4] += e * n[5],
                n[7] += e * n[8],
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        r.prototype.isMatrix3 = !0
    },
    9203: function(t, e, n) {
        n.d(e, {
            y: function() {
                return i
            }
        });
        var r = n(6881);
        class i {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, r, i, s, a, o, l, c, u, h, d, f, p, m) {
                const g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = n,
                g[12] = r,
                g[1] = i,
                g[5] = s,
                g[9] = a,
                g[13] = o,
                g[2] = l,
                g[6] = c,
                g[10] = u,
                g[14] = h,
                g[3] = d,
                g[7] = f,
                g[11] = p,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new i).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                e[9] = n[9],
                e[10] = n[10],
                e[11] = n[11],
                e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                e[15] = n[15],
                this
            }
            copyPosition(t) {
                const e = this.elements
                  , n = t.elements;
                return e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(t) {
                const e = this.elements
                  , n = t.elements
                  , r = 1 / s.setFromMatrixColumn(t, 0).length()
                  , i = 1 / s.setFromMatrixColumn(t, 1).length()
                  , a = 1 / s.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * r,
                e[1] = n[1] * r,
                e[2] = n[2] * r,
                e[3] = 0,
                e[4] = n[4] * i,
                e[5] = n[5] * i,
                e[6] = n[6] * i,
                e[7] = 0,
                e[8] = n[8] * a,
                e[9] = n[9] * a,
                e[10] = n[10] * a,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements
                  , n = t.x
                  , r = t.y
                  , i = t.z
                  , s = Math.cos(n)
                  , a = Math.sin(n)
                  , o = Math.cos(r)
                  , l = Math.sin(r)
                  , c = Math.cos(i)
                  , u = Math.sin(i);
                if ("XYZ" === t.order) {
                    const t = s * c
                      , n = s * u
                      , r = a * c
                      , i = a * u;
                    e[0] = o * c,
                    e[4] = -o * u,
                    e[8] = l,
                    e[1] = n + r * l,
                    e[5] = t - i * l,
                    e[9] = -a * o,
                    e[2] = i - t * l,
                    e[6] = r + n * l,
                    e[10] = s * o
                } else if ("YXZ" === t.order) {
                    const t = o * c
                      , n = o * u
                      , r = l * c
                      , i = l * u;
                    e[0] = t + i * a,
                    e[4] = r * a - n,
                    e[8] = s * l,
                    e[1] = s * u,
                    e[5] = s * c,
                    e[9] = -a,
                    e[2] = n * a - r,
                    e[6] = i + t * a,
                    e[10] = s * o
                } else if ("ZXY" === t.order) {
                    const t = o * c
                      , n = o * u
                      , r = l * c
                      , i = l * u;
                    e[0] = t - i * a,
                    e[4] = -s * u,
                    e[8] = r + n * a,
                    e[1] = n + r * a,
                    e[5] = s * c,
                    e[9] = i - t * a,
                    e[2] = -s * l,
                    e[6] = a,
                    e[10] = s * o
                } else if ("ZYX" === t.order) {
                    const t = s * c
                      , n = s * u
                      , r = a * c
                      , i = a * u;
                    e[0] = o * c,
                    e[4] = r * l - n,
                    e[8] = t * l + i,
                    e[1] = o * u,
                    e[5] = i * l + t,
                    e[9] = n * l - r,
                    e[2] = -l,
                    e[6] = a * o,
                    e[10] = s * o
                } else if ("YZX" === t.order) {
                    const t = s * o
                      , n = s * l
                      , r = a * o
                      , i = a * l;
                    e[0] = o * c,
                    e[4] = i - t * u,
                    e[8] = r * u + n,
                    e[1] = u,
                    e[5] = s * c,
                    e[9] = -a * c,
                    e[2] = -l * c,
                    e[6] = n * u + r,
                    e[10] = t - i * u
                } else if ("XZY" === t.order) {
                    const t = s * o
                      , n = s * l
                      , r = a * o
                      , i = a * l;
                    e[0] = o * c,
                    e[4] = -u,
                    e[8] = l * c,
                    e[1] = t * u + i,
                    e[5] = s * c,
                    e[9] = n * u - r,
                    e[2] = r * u - n,
                    e[6] = a * c,
                    e[10] = i * u + t
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(o, t, l)
            }
            lookAt(t, e, n) {
                const r = this.elements;
                return h.subVectors(t, e),
                0 === h.lengthSq() && (h.z = 1),
                h.normalize(),
                c.crossVectors(n, h),
                0 === c.lengthSq() && (1 === Math.abs(n.z) ? h.x += 1e-4 : h.z += 1e-4,
                h.normalize(),
                c.crossVectors(n, h)),
                c.normalize(),
                u.crossVectors(h, c),
                r[0] = c.x,
                r[4] = u.x,
                r[8] = h.x,
                r[1] = c.y,
                r[5] = u.y,
                r[9] = h.y,
                r[2] = c.z,
                r[6] = u.z,
                r[10] = h.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , r = e.elements
                  , i = this.elements
                  , s = n[0]
                  , a = n[4]
                  , o = n[8]
                  , l = n[12]
                  , c = n[1]
                  , u = n[5]
                  , h = n[9]
                  , d = n[13]
                  , f = n[2]
                  , p = n[6]
                  , m = n[10]
                  , g = n[14]
                  , v = n[3]
                  , _ = n[7]
                  , y = n[11]
                  , x = n[15]
                  , b = r[0]
                  , w = r[4]
                  , M = r[8]
                  , T = r[12]
                  , S = r[1]
                  , E = r[5]
                  , A = r[9]
                  , R = r[13]
                  , L = r[2]
                  , P = r[6]
                  , C = r[10]
                  , D = r[14]
                  , I = r[3]
                  , N = r[7]
                  , F = r[11]
                  , O = r[15];
                return i[0] = s * b + a * S + o * L + l * I,
                i[4] = s * w + a * E + o * P + l * N,
                i[8] = s * M + a * A + o * C + l * F,
                i[12] = s * T + a * R + o * D + l * O,
                i[1] = c * b + u * S + h * L + d * I,
                i[5] = c * w + u * E + h * P + d * N,
                i[9] = c * M + u * A + h * C + d * F,
                i[13] = c * T + u * R + h * D + d * O,
                i[2] = f * b + p * S + m * L + g * I,
                i[6] = f * w + p * E + m * P + g * N,
                i[10] = f * M + p * A + m * C + g * F,
                i[14] = f * T + p * R + m * D + g * O,
                i[3] = v * b + _ * S + y * L + x * I,
                i[7] = v * w + _ * E + y * P + x * N,
                i[11] = v * M + _ * A + y * C + x * F,
                i[15] = v * T + _ * R + y * D + x * O,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[4]
                  , r = t[8]
                  , i = t[12]
                  , s = t[1]
                  , a = t[5]
                  , o = t[9]
                  , l = t[13]
                  , c = t[2]
                  , u = t[6]
                  , h = t[10]
                  , d = t[14];
                return t[3] * (+i * o * u - r * l * u - i * a * h + n * l * h + r * a * d - n * o * d) + t[7] * (+e * o * d - e * l * h + i * s * h - r * s * d + r * l * c - i * o * c) + t[11] * (+e * l * u - e * a * d - i * s * u + n * s * d + i * a * c - n * l * c) + t[15] * (-r * a * c - e * o * u + e * a * h + r * s * u - n * s * h + n * o * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                t[1] = t[4],
                t[4] = e,
                e = t[2],
                t[2] = t[8],
                t[8] = e,
                e = t[6],
                t[6] = t[9],
                t[9] = e,
                e = t[3],
                t[3] = t[12],
                t[12] = e,
                e = t[7],
                t[7] = t[13],
                t[13] = e,
                e = t[11],
                t[11] = t[14],
                t[14] = e,
                this
            }
            setPosition(t, e, n) {
                const r = this.elements;
                return t.isVector3 ? (r[12] = t.x,
                r[13] = t.y,
                r[14] = t.z) : (r[12] = t,
                r[13] = e,
                r[14] = n),
                this
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , r = t[2]
                  , i = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = t[9]
                  , h = t[10]
                  , d = t[11]
                  , f = t[12]
                  , p = t[13]
                  , m = t[14]
                  , g = t[15]
                  , v = u * m * l - p * h * l + p * o * d - a * m * d - u * o * g + a * h * g
                  , _ = f * h * l - c * m * l - f * o * d + s * m * d + c * o * g - s * h * g
                  , y = c * p * l - f * u * l + f * a * d - s * p * d - c * a * g + s * u * g
                  , x = f * u * o - c * p * o - f * a * h + s * p * h + c * a * m - s * u * m
                  , b = e * v + n * _ + r * y + i * x;
                if (0 === b)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const w = 1 / b;
                return t[0] = v * w,
                t[1] = (p * h * i - u * m * i - p * r * d + n * m * d + u * r * g - n * h * g) * w,
                t[2] = (a * m * i - p * o * i + p * r * l - n * m * l - a * r * g + n * o * g) * w,
                t[3] = (u * o * i - a * h * i - u * r * l + n * h * l + a * r * d - n * o * d) * w,
                t[4] = _ * w,
                t[5] = (c * m * i - f * h * i + f * r * d - e * m * d - c * r * g + e * h * g) * w,
                t[6] = (f * o * i - s * m * i - f * r * l + e * m * l + s * r * g - e * o * g) * w,
                t[7] = (s * h * i - c * o * i + c * r * l - e * h * l - s * r * d + e * o * d) * w,
                t[8] = y * w,
                t[9] = (f * u * i - c * p * i - f * n * d + e * p * d + c * n * g - e * u * g) * w,
                t[10] = (s * p * i - f * a * i + f * n * l - e * p * l - s * n * g + e * a * g) * w,
                t[11] = (c * a * i - s * u * i - c * n * l + e * u * l + s * n * d - e * a * d) * w,
                t[12] = x * w,
                t[13] = (c * p * r - f * u * r + f * n * h - e * p * h - c * n * m + e * u * m) * w,
                t[14] = (f * a * r - s * p * r - f * n * o + e * p * o + s * n * m - e * a * m) * w,
                t[15] = (s * u * r - c * a * r + c * n * o - e * u * o - s * n * h + e * a * h) * w,
                this
            }
            scale(t) {
                const e = this.elements
                  , n = t.x
                  , r = t.y
                  , i = t.z;
                return e[0] *= n,
                e[4] *= r,
                e[8] *= i,
                e[1] *= n,
                e[5] *= r,
                e[9] *= i,
                e[2] *= n,
                e[6] *= r,
                e[10] *= i,
                e[3] *= n,
                e[7] *= r,
                e[11] *= i,
                this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, r))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e)
                  , r = Math.sin(e)
                  , i = 1 - n
                  , s = t.x
                  , a = t.y
                  , o = t.z
                  , l = i * s
                  , c = i * a;
                return this.set(l * s + n, l * a - r * o, l * o + r * a, 0, l * a + r * o, c * a + n, c * o - r * s, 0, l * o - r * a, c * o + r * s, i * o * o + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(t, e, n, r, i, s) {
                return this.set(1, n, i, 0, t, 1, s, 0, e, r, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(t, e, n) {
                const r = this.elements
                  , i = e._x
                  , s = e._y
                  , a = e._z
                  , o = e._w
                  , l = i + i
                  , c = s + s
                  , u = a + a
                  , h = i * l
                  , d = i * c
                  , f = i * u
                  , p = s * c
                  , m = s * u
                  , g = a * u
                  , v = o * l
                  , _ = o * c
                  , y = o * u
                  , x = n.x
                  , b = n.y
                  , w = n.z;
                return r[0] = (1 - (p + g)) * x,
                r[1] = (d + y) * x,
                r[2] = (f - _) * x,
                r[3] = 0,
                r[4] = (d - y) * b,
                r[5] = (1 - (h + g)) * b,
                r[6] = (m + v) * b,
                r[7] = 0,
                r[8] = (f + _) * w,
                r[9] = (m - v) * w,
                r[10] = (1 - (h + p)) * w,
                r[11] = 0,
                r[12] = t.x,
                r[13] = t.y,
                r[14] = t.z,
                r[15] = 1,
                this
            }
            decompose(t, e, n) {
                const r = this.elements;
                let i = s.set(r[0], r[1], r[2]).length();
                const o = s.set(r[4], r[5], r[6]).length()
                  , l = s.set(r[8], r[9], r[10]).length();
                this.determinant() < 0 && (i = -i),
                t.x = r[12],
                t.y = r[13],
                t.z = r[14],
                a.copy(this);
                const c = 1 / i
                  , u = 1 / o
                  , h = 1 / l;
                return a.elements[0] *= c,
                a.elements[1] *= c,
                a.elements[2] *= c,
                a.elements[4] *= u,
                a.elements[5] *= u,
                a.elements[6] *= u,
                a.elements[8] *= h,
                a.elements[9] *= h,
                a.elements[10] *= h,
                e.setFromRotationMatrix(a),
                n.x = i,
                n.y = o,
                n.z = l,
                this
            }
            makePerspective(t, e, n, r, i, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const a = this.elements
                  , o = 2 * i / (e - t)
                  , l = 2 * i / (n - r)
                  , c = (e + t) / (e - t)
                  , u = (n + r) / (n - r)
                  , h = -(s + i) / (s - i)
                  , d = -2 * s * i / (s - i);
                return a[0] = o,
                a[4] = 0,
                a[8] = c,
                a[12] = 0,
                a[1] = 0,
                a[5] = l,
                a[9] = u,
                a[13] = 0,
                a[2] = 0,
                a[6] = 0,
                a[10] = h,
                a[14] = d,
                a[3] = 0,
                a[7] = 0,
                a[11] = -1,
                a[15] = 0,
                this
            }
            makeOrthographic(t, e, n, r, i, s) {
                const a = this.elements
                  , o = 1 / (e - t)
                  , l = 1 / (n - r)
                  , c = 1 / (s - i)
                  , u = (e + t) * o
                  , h = (n + r) * l
                  , d = (s + i) * c;
                return a[0] = 2 * o,
                a[4] = 0,
                a[8] = 0,
                a[12] = -u,
                a[1] = 0,
                a[5] = 2 * l,
                a[9] = 0,
                a[13] = -h,
                a[2] = 0,
                a[6] = 0,
                a[10] = -2 * c,
                a[14] = -d,
                a[3] = 0,
                a[7] = 0,
                a[11] = 0,
                a[15] = 1,
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t[e + 9] = n[9],
                t[e + 10] = n[10],
                t[e + 11] = n[11],
                t[e + 12] = n[12],
                t[e + 13] = n[13],
                t[e + 14] = n[14],
                t[e + 15] = n[15],
                t
            }
        }
        i.prototype.isMatrix4 = !0;
        const s = new r.P
          , a = new i
          , o = new r.P(0,0,0)
          , l = new r.P(1,1,1)
          , c = new r.P
          , u = new r.P
          , h = new r.P
    },
    1158: function(t, e, n) {
        n.d(e, {
            J: function() {
                return l
            }
        });
        var r = n(1273)
          , i = n(6881);
        const s = new i.P
          , a = new i.P
          , o = new r.V;
        class l {
            constructor(t=new i.P(1,0,0), e=0) {
                this.normal = t,
                this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            }
            setComponents(t, e, n, r) {
                return this.normal.set(t, e, n),
                this.constant = r,
                this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            }
            setFromCoplanarPoints(t, e, n) {
                const r = s.subVectors(n, e).cross(a.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(r, t),
                this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                const n = t.delta(s)
                  , r = this.normal.dot(n);
                if (0 === r)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const i = -(t.start.dot(this.normal) + this.constant) / r;
                return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                  , n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || o.getNormalMatrix(t)
                  , r = this.coplanarPoint(s).applyMatrix4(t)
                  , i = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(i),
                this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        l.prototype.isPlane = !0
    },
    7092: function(t, e, n) {
        n.d(e, {
            _: function() {
                return i
            }
        });
        var r = n(2043);
        class i {
            constructor(t=0, e=0, n=0, r=1) {
                this._x = t,
                this._y = e,
                this._z = n,
                this._w = r
            }
            static slerp(t, e, n, r) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
                n.slerpQuaternions(t, e, r)
            }
            static slerpFlat(t, e, n, r, i, s, a) {
                let o = n[r + 0]
                  , l = n[r + 1]
                  , c = n[r + 2]
                  , u = n[r + 3];
                const h = i[s + 0]
                  , d = i[s + 1]
                  , f = i[s + 2]
                  , p = i[s + 3];
                if (0 === a)
                    return t[e + 0] = o,
                    t[e + 1] = l,
                    t[e + 2] = c,
                    void (t[e + 3] = u);
                if (1 === a)
                    return t[e + 0] = h,
                    t[e + 1] = d,
                    t[e + 2] = f,
                    void (t[e + 3] = p);
                if (u !== p || o !== h || l !== d || c !== f) {
                    let t = 1 - a;
                    const e = o * h + l * d + c * f + u * p
                      , n = e >= 0 ? 1 : -1
                      , r = 1 - e * e;
                    if (r > Number.EPSILON) {
                        const i = Math.sqrt(r)
                          , s = Math.atan2(i, e * n);
                        t = Math.sin(t * s) / i,
                        a = Math.sin(a * s) / i
                    }
                    const i = a * n;
                    if (o = o * t + h * i,
                    l = l * t + d * i,
                    c = c * t + f * i,
                    u = u * t + p * i,
                    t === 1 - a) {
                        const t = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
                        o *= t,
                        l *= t,
                        c *= t,
                        u *= t
                    }
                }
                t[e] = o,
                t[e + 1] = l,
                t[e + 2] = c,
                t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, r, i, s) {
                const a = n[r]
                  , o = n[r + 1]
                  , l = n[r + 2]
                  , c = n[r + 3]
                  , u = i[s]
                  , h = i[s + 1]
                  , d = i[s + 2]
                  , f = i[s + 3];
                return t[e] = a * f + c * u + o * d - l * h,
                t[e + 1] = o * f + c * h + l * u - a * d,
                t[e + 2] = l * f + c * d + a * h - o * u,
                t[e + 3] = c * f - a * u - o * h - l * d,
                t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                this._onChangeCallback()
            }
            set(t, e, n, r) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._w = r,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler)
                    throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x
                  , r = t._y
                  , i = t._z
                  , s = t._order
                  , a = Math.cos
                  , o = Math.sin
                  , l = a(n / 2)
                  , c = a(r / 2)
                  , u = a(i / 2)
                  , h = o(n / 2)
                  , d = o(r / 2)
                  , f = o(i / 2);
                switch (s) {
                case "XYZ":
                    this._x = h * c * u + l * d * f,
                    this._y = l * d * u - h * c * f,
                    this._z = l * c * f + h * d * u,
                    this._w = l * c * u - h * d * f;
                    break;
                case "YXZ":
                    this._x = h * c * u + l * d * f,
                    this._y = l * d * u - h * c * f,
                    this._z = l * c * f - h * d * u,
                    this._w = l * c * u + h * d * f;
                    break;
                case "ZXY":
                    this._x = h * c * u - l * d * f,
                    this._y = l * d * u + h * c * f,
                    this._z = l * c * f + h * d * u,
                    this._w = l * c * u - h * d * f;
                    break;
                case "ZYX":
                    this._x = h * c * u - l * d * f,
                    this._y = l * d * u + h * c * f,
                    this._z = l * c * f - h * d * u,
                    this._w = l * c * u + h * d * f;
                    break;
                case "YZX":
                    this._x = h * c * u + l * d * f,
                    this._y = l * d * u + h * c * f,
                    this._z = l * c * f - h * d * u,
                    this._w = l * c * u - h * d * f;
                    break;
                case "XZY":
                    this._x = h * c * u - l * d * f,
                    this._y = l * d * u - h * c * f,
                    this._z = l * c * f + h * d * u,
                    this._w = l * c * u + h * d * f;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== e && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2
                  , r = Math.sin(n);
                return this._x = t.x * r,
                this._y = t.y * r,
                this._z = t.z * r,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                  , n = e[0]
                  , r = e[4]
                  , i = e[8]
                  , s = e[1]
                  , a = e[5]
                  , o = e[9]
                  , l = e[2]
                  , c = e[6]
                  , u = e[10]
                  , h = n + a + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t,
                    this._x = (c - o) * t,
                    this._y = (i - l) * t,
                    this._z = (s - r) * t
                } else if (n > a && n > u) {
                    const t = 2 * Math.sqrt(1 + n - a - u);
                    this._w = (c - o) / t,
                    this._x = .25 * t,
                    this._y = (r + s) / t,
                    this._z = (i + l) / t
                } else if (a > u) {
                    const t = 2 * Math.sqrt(1 + a - n - u);
                    this._w = (i - l) / t,
                    this._x = (r + s) / t,
                    this._y = .25 * t,
                    this._z = (o + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - a);
                    this._w = (s - r) / t,
                    this._x = (i + l) / t,
                    this._y = (o + c) / t,
                    this._z = .25 * t
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                this._y = t.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -t.z,
                this._z = t.y,
                this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                this._y = t.z * e.x - t.x * e.z,
                this._z = t.x * e.y - t.y * e.x,
                this._w = n),
                this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(r.uZ(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n)
                    return this;
                const r = Math.min(1, e / n);
                return this.slerp(t, r),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this._onChangeCallback(),
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x
                  , r = t._y
                  , i = t._z
                  , s = t._w
                  , a = e._x
                  , o = e._y
                  , l = e._z
                  , c = e._w;
                return this._x = n * c + s * a + r * l - i * o,
                this._y = r * c + s * o + i * a - n * l,
                this._z = i * c + s * l + n * o - r * a,
                this._w = s * c - n * a - r * o - i * l,
                this._onChangeCallback(),
                this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const n = this._x
                  , r = this._y
                  , i = this._z
                  , s = this._w;
                let a = s * t._w + n * t._x + r * t._y + i * t._z;
                if (a < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                a = -a) : this.copy(t),
                a >= 1)
                    return this._w = s,
                    this._x = n,
                    this._y = r,
                    this._z = i,
                    this;
                const o = 1 - a * a;
                if (o <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w,
                    this._x = t * n + e * this._x,
                    this._y = t * r + e * this._y,
                    this._z = t * i + e * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const l = Math.sqrt(o)
                  , c = Math.atan2(l, a)
                  , u = Math.sin((1 - e) * c) / l
                  , h = Math.sin(e * c) / l;
                return this._w = s * u + this._w * h,
                this._x = n * u + this._x * h,
                this._y = r * u + this._y * h,
                this._z = i * u + this._z * h,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(t, e, n) {
                this.copy(t).slerp(e, n)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e=0) {
                return this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                this._y = t.getY(e),
                this._z = t.getZ(e),
                this._w = t.getW(e),
                this
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        i.prototype.isQuaternion = !0
    },
    7540: function(t, e, n) {
        n.d(e, {
            z: function() {
                return h
            }
        });
        var r = n(6881);
        const i = new r.P
          , s = new r.P
          , a = new r.P
          , o = new r.P
          , l = new r.P
          , c = new r.P
          , u = new r.P;
        class h {
            constructor(t=new r.P, e=new r.P(0,0,-1)) {
                this.origin = t,
                this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            }
            at(t, e) {
                return e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            }
            recast(t) {
                return this.origin.copy(this.at(t, i)),
                this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = i.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (i.copy(this.direction).multiplyScalar(e).add(this.origin),
                i.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, r) {
                s.copy(t).add(e).multiplyScalar(.5),
                a.copy(e).sub(t).normalize(),
                o.copy(this.origin).sub(s);
                const i = .5 * t.distanceTo(e)
                  , l = -this.direction.dot(a)
                  , c = o.dot(this.direction)
                  , u = -o.dot(a)
                  , h = o.lengthSq()
                  , d = Math.abs(1 - l * l);
                let f, p, m, g;
                if (d > 0)
                    if (f = l * u - c,
                    p = l * c - u,
                    g = i * d,
                    f >= 0)
                        if (p >= -g)
                            if (p <= g) {
                                const t = 1 / d;
                                f *= t,
                                p *= t,
                                m = f * (f + l * p + 2 * c) + p * (l * f + p + 2 * u) + h
                            } else
                                p = i,
                                f = Math.max(0, -(l * p + c)),
                                m = -f * f + p * (p + 2 * u) + h;
                        else
                            p = -i,
                            f = Math.max(0, -(l * p + c)),
                            m = -f * f + p * (p + 2 * u) + h;
                    else
                        p <= -g ? (f = Math.max(0, -(-l * i + c)),
                        p = f > 0 ? -i : Math.min(Math.max(-i, -u), i),
                        m = -f * f + p * (p + 2 * u) + h) : p <= g ? (f = 0,
                        p = Math.min(Math.max(-i, -u), i),
                        m = p * (p + 2 * u) + h) : (f = Math.max(0, -(l * i + c)),
                        p = f > 0 ? i : Math.min(Math.max(-i, -u), i),
                        m = -f * f + p * (p + 2 * u) + h);
                else
                    p = l > 0 ? -i : i,
                    f = Math.max(0, -(l * p + c)),
                    m = -f * f + p * (p + 2 * u) + h;
                return n && n.copy(this.direction).multiplyScalar(f).add(this.origin),
                r && r.copy(a).multiplyScalar(p).add(s),
                m
            }
            intersectSphere(t, e) {
                i.subVectors(t.center, this.origin);
                const n = i.dot(this.direction)
                  , r = i.dot(i) - n * n
                  , s = t.radius * t.radius;
                if (r > s)
                    return null;
                const a = Math.sqrt(s - r)
                  , o = n - a
                  , l = n + a;
                return o < 0 && l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e)
                    return !0;
                return t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, r, i, s, a, o;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , u = 1 / this.direction.z
                  , h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l,
                r = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l,
                r = (t.min.x - h.x) * l),
                c >= 0 ? (i = (t.min.y - h.y) * c,
                s = (t.max.y - h.y) * c) : (i = (t.max.y - h.y) * c,
                s = (t.min.y - h.y) * c),
                n > s || i > r ? null : ((i > n || n != n) && (n = i),
                (s < r || r != r) && (r = s),
                u >= 0 ? (a = (t.min.z - h.z) * u,
                o = (t.max.z - h.z) * u) : (a = (t.max.z - h.z) * u,
                o = (t.min.z - h.z) * u),
                n > o || a > r ? null : ((a > n || n != n) && (n = a),
                (o < r || r != r) && (r = o),
                r < 0 ? null : this.at(n >= 0 ? n : r, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, i)
            }
            intersectTriangle(t, e, n, r, i) {
                l.subVectors(e, t),
                c.subVectors(n, t),
                u.crossVectors(l, c);
                let s, a = this.direction.dot(u);
                if (a > 0) {
                    if (r)
                        return null;
                    s = 1
                } else {
                    if (!(a < 0))
                        return null;
                    s = -1,
                    a = -a
                }
                o.subVectors(this.origin, t);
                const h = s * this.direction.dot(c.crossVectors(o, c));
                if (h < 0)
                    return null;
                const d = s * this.direction.dot(l.cross(o));
                if (d < 0)
                    return null;
                if (h + d > a)
                    return null;
                const f = -s * o.dot(u);
                return f < 0 ? null : this.at(f / a, i)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
    },
    4699: function(t, e, n) {
        n.d(e, {
            a: function() {
                return c
            }
        });
        var r = n(1898)
          , i = n(6881);
        const s = new r.Z
          , a = new i.P
          , o = new i.P
          , l = new i.P;
        class c {
            constructor(t=new i.P, e=-1) {
                this.center = t,
                this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : s.setFromPoints(t).getCenter(n);
                let r = 0;
                for (let e = 0, i = t.length; e < i; e++)
                    r = Math.max(r, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(r),
                this
            }
            copy(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t),
                n > this.radius * this.radius && (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
                e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(),
                t) : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            }
            translate(t) {
                return this.center.add(t),
                this
            }
            expandByPoint(t) {
                l.subVectors(t, this.center);
                const e = l.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e)
                      , n = .5 * (t - this.radius);
                    this.center.add(l.multiplyScalar(n / t)),
                    this.radius += n
                }
                return this
            }
            union(t) {
                return o.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
                this.expandByPoint(a.copy(t.center).add(o)),
                this.expandByPoint(a.copy(t.center).sub(o)),
                this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
    },
    8121: function(t, e, n) {
        n.d(e, {
            C: function() {
                return p
            }
        });
        var r = n(6881);
        const i = new r.P
          , s = new r.P
          , a = new r.P
          , o = new r.P
          , l = new r.P
          , c = new r.P
          , u = new r.P
          , h = new r.P
          , d = new r.P
          , f = new r.P;
        class p {
            constructor(t=new r.P, e=new r.P, n=new r.P) {
                this.a = t,
                this.b = e,
                this.c = n
            }
            static getNormal(t, e, n, r) {
                r.subVectors(n, e),
                i.subVectors(t, e),
                r.cross(i);
                const s = r.lengthSq();
                return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, r, o) {
                i.subVectors(r, e),
                s.subVectors(n, e),
                a.subVectors(t, e);
                const l = i.dot(i)
                  , c = i.dot(s)
                  , u = i.dot(a)
                  , h = s.dot(s)
                  , d = s.dot(a)
                  , f = l * h - c * c;
                if (0 === f)
                    return o.set(-2, -1, -1);
                const p = 1 / f
                  , m = (h * u - c * d) * p
                  , g = (l * d - c * u) * p;
                return o.set(1 - m - g, g, m)
            }
            static containsPoint(t, e, n, r) {
                return this.getBarycoord(t, e, n, r, o),
                o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
            }
            static getUV(t, e, n, r, i, s, a, l) {
                return this.getBarycoord(t, e, n, r, o),
                l.set(0, 0),
                l.addScaledVector(i, o.x),
                l.addScaledVector(s, o.y),
                l.addScaledVector(a, o.z),
                l
            }
            static isFrontFacing(t, e, n, r) {
                return i.subVectors(n, e),
                s.subVectors(t, e),
                i.cross(s).dot(r) < 0
            }
            set(t, e, n) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(t, e, n, r) {
                return this.a.copy(t[e]),
                this.b.copy(t[n]),
                this.c.copy(t[r]),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            }
            getArea() {
                return i.subVectors(this.c, this.b),
                s.subVectors(this.a, this.b),
                .5 * i.cross(s).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return p.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return p.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, r, i) {
                return p.getUV(t, this.a, this.b, this.c, e, n, r, i)
            }
            containsPoint(t) {
                return p.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return p.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a
                  , r = this.b
                  , i = this.c;
                let s, a;
                l.subVectors(r, n),
                c.subVectors(i, n),
                h.subVectors(t, n);
                const o = l.dot(h)
                  , p = c.dot(h);
                if (o <= 0 && p <= 0)
                    return e.copy(n);
                d.subVectors(t, r);
                const m = l.dot(d)
                  , g = c.dot(d);
                if (m >= 0 && g <= m)
                    return e.copy(r);
                const v = o * g - m * p;
                if (v <= 0 && o >= 0 && m <= 0)
                    return s = o / (o - m),
                    e.copy(n).addScaledVector(l, s);
                f.subVectors(t, i);
                const _ = l.dot(f)
                  , y = c.dot(f);
                if (y >= 0 && _ <= y)
                    return e.copy(i);
                const x = _ * p - o * y;
                if (x <= 0 && p >= 0 && y <= 0)
                    return a = p / (p - y),
                    e.copy(n).addScaledVector(c, a);
                const b = m * y - _ * g;
                if (b <= 0 && g - m >= 0 && _ - y >= 0)
                    return u.subVectors(i, r),
                    a = (g - m) / (g - m + (_ - y)),
                    e.copy(r).addScaledVector(u, a);
                const w = 1 / (b + x + v);
                return s = x * w,
                a = v * w,
                e.copy(n).addScaledVector(l, s).addScaledVector(c, a)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
    },
    1138: function(t, e, n) {
        n.d(e, {
            F: function() {
                return r
            }
        });
        class r {
            constructor(t=0, e=0) {
                this.x = t,
                this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                this.y = e,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6],
                this.y = r[1] * e + r[4] * n + r[7],
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this
            }
            rotateAround(t, e) {
                const n = Math.cos(e)
                  , r = Math.sin(e)
                  , i = this.x - t.x
                  , s = this.y - t.y;
                return this.x = i * n - s * r + t.x,
                this.y = i * r + s * n + t.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
        }
        r.prototype.isVector2 = !0
    },
    6881: function(t, e, n) {
        n.d(e, {
            P: function() {
                return s
            }
        });
        var r = n(2043)
          , i = n(7092);
        class s {
            constructor(t=0, e=0, n=0) {
                this.x = t,
                this.y = e,
                this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z),
                this.x = t,
                this.y = e,
                this.z = n,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                this.multiplyVectors(t, e)) : (this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this)
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(o.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(o.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , r = this.z
                  , i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6] * r,
                this.y = i[1] * e + i[4] * n + i[7] * r,
                this.z = i[2] * e + i[5] * n + i[8] * r,
                this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , r = this.z
                  , i = t.elements
                  , s = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * s,
                this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * s,
                this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * s,
                this
            }
            applyQuaternion(t) {
                const e = this.x
                  , n = this.y
                  , r = this.z
                  , i = t.x
                  , s = t.y
                  , a = t.z
                  , o = t.w
                  , l = o * e + s * r - a * n
                  , c = o * n + a * e - i * r
                  , u = o * r + i * n - s * e
                  , h = -i * e - s * n - a * r;
                return this.x = l * o + h * -i + c * -a - u * -s,
                this.y = c * o + h * -s + u * -i - l * -a,
                this.z = u * o + h * -a + l * -s - c * -i,
                this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                  , n = this.y
                  , r = this.z
                  , i = t.elements;
                return this.x = i[0] * e + i[4] * n + i[8] * r,
                this.y = i[1] * e + i[5] * n + i[9] * r,
                this.z = i[2] * e + i[6] * n + i[10] * r,
                this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x
                  , r = t.y
                  , i = t.z
                  , s = e.x
                  , a = e.y
                  , o = e.z;
                return this.x = r * o - i * a,
                this.y = i * s - n * o,
                this.z = n * a - r * s,
                this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return a.copy(this).projectOnVector(t),
                this.sub(a)
            }
            reflect(t) {
                return this.sub(a.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(r.uZ(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y
                  , r = this.z - t.z;
                return e * e + n * n + r * r
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const r = Math.sin(e) * t;
                return this.x = r * Math.sin(n),
                this.y = Math.cos(e) * t,
                this.z = r * Math.cos(n),
                this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e),
                this.y = n,
                this.z = t * Math.cos(e),
                this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                this.y = e[13],
                this.z = e[14],
                this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                  , n = this.setFromMatrixColumn(t, 1).length()
                  , r = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                this.y = n,
                this.z = r,
                this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
        }
        s.prototype.isVector3 = !0;
        const a = new s
          , o = new i._
    },
    223: function(t, e, n) {
        n.d(e, {
            L: function() {
                return r
            }
        });
        class r {
            constructor(t=0, e=0, n=0, r=1) {
                this.x = t,
                this.y = e,
                this.z = n,
                this.w = r
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, r) {
                return this.x = t,
                this.y = e,
                this.z = n,
                this.w = r,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setW(t) {
                return this.w = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this.w *= t.w,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t,
                this
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , r = this.z
                  , i = this.w
                  , s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * r + s[12] * i,
                this.y = s[1] * e + s[5] * n + s[9] * r + s[13] * i,
                this.z = s[2] * e + s[6] * n + s[10] * r + s[14] * i,
                this.w = s[3] * e + s[7] * n + s[11] * r + s[15] * i,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, r, i;
                const s = .01
                  , a = .1
                  , o = t.elements
                  , l = o[0]
                  , c = o[4]
                  , u = o[8]
                  , h = o[1]
                  , d = o[5]
                  , f = o[9]
                  , p = o[2]
                  , m = o[6]
                  , g = o[10];
                if (Math.abs(c - h) < s && Math.abs(u - p) < s && Math.abs(f - m) < s) {
                    if (Math.abs(c + h) < a && Math.abs(u + p) < a && Math.abs(f + m) < a && Math.abs(l + d + g - 3) < a)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    const t = (l + 1) / 2
                      , o = (d + 1) / 2
                      , v = (g + 1) / 2
                      , _ = (c + h) / 4
                      , y = (u + p) / 4
                      , x = (f + m) / 4;
                    return t > o && t > v ? t < s ? (n = 0,
                    r = .707106781,
                    i = .707106781) : (n = Math.sqrt(t),
                    r = _ / n,
                    i = y / n) : o > v ? o < s ? (n = .707106781,
                    r = 0,
                    i = .707106781) : (r = Math.sqrt(o),
                    n = _ / r,
                    i = x / r) : v < s ? (n = .707106781,
                    r = .707106781,
                    i = 0) : (i = Math.sqrt(v),
                    n = y / i,
                    r = x / i),
                    this.set(n, r, i, e),
                    this
                }
                let v = Math.sqrt((m - f) * (m - f) + (u - p) * (u - p) + (h - c) * (h - c));
                return Math.abs(v) < .001 && (v = 1),
                this.x = (m - f) / v,
                this.y = (u - p) / v,
                this.z = (h - c) / v,
                this.w = Math.acos((l + d + g - 1) / 2),
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this.w = Math.max(t, Math.min(e, this.w)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this.w = t.w + (e.w - t.w) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this.w = t.getW(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
        }
        r.prototype.isVector4 = !0
    },
    2010: function(t, e, n) {
        n.d(e, {
            Z: function() {
                return i
            }
        });
        var r = n(4291);
        class i extends r.T {
            constructor() {
                super(),
                this.type = "Group"
            }
        }
        i.prototype.isGroup = !0
    },
    7936: function(t, e, n) {
        n.d(e, {
            S: function() {
                return u
            }
        });
        var r = n(612)
          , i = n(6454)
          , s = n(9203);
        const a = new s.y
          , o = new s.y
          , l = []
          , c = new i.K;
        class u extends i.K {
            constructor(t, e, n) {
                super(t, e),
                this.instanceMatrix = new r.l(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.frustumCulled = !1
            }
            copy(t) {
                return super.copy(t),
                this.instanceMatrix.copy(t.instanceMatrix),
                null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                this.count = t.count,
                this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld
                  , r = this.count;
                if (c.geometry = this.geometry,
                c.material = this.material,
                void 0 !== c.material)
                    for (let i = 0; i < r; i++) {
                        this.getMatrixAt(i, a),
                        o.multiplyMatrices(n, a),
                        c.matrixWorld = o,
                        c.raycast(t, l);
                        for (let t = 0, n = l.length; t < n; t++) {
                            const n = l[t];
                            n.instanceId = i,
                            n.object = this,
                            e.push(n)
                        }
                        l.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new r.l(new Float32Array(3 * this.instanceMatrix.count),3)),
                e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        u.prototype.isInstancedMesh = !0
    },
    1301: function(t, e, n) {
        n.d(e, {
            x: function() {
                return g
            }
        });
        var r = n(4699)
          , i = n(7540)
          , s = n(9203)
          , a = n(4291)
          , o = n(6881)
          , l = n(5785)
          , c = n(9046)
          , u = n(140);
        const h = new o.P
          , d = new o.P
          , f = new s.y
          , p = new i.z
          , m = new r.a;
        class g extends a.T {
            constructor(t=new c.u, e=new l.n) {
                super(),
                this.type = "Line",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , n = [0];
                        for (let t = 1, r = e.count; t < r; t++)
                            h.fromBufferAttribute(e, t - 1),
                            d.fromBufferAttribute(e, t),
                            n[t] = n[t - 1],
                            n[t] += h.distanceTo(d);
                        t.setAttribute("lineDistance", new u.a$(n,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry
                  , r = this.matrixWorld
                  , i = t.params.Line.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                m.copy(n.boundingSphere),
                m.applyMatrix4(r),
                m.radius += i,
                !1 === t.ray.intersectsSphere(m))
                    return;
                f.copy(r).invert(),
                p.copy(t.ray).applyMatrix4(f);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , l = a * a
                  , c = new o.P
                  , u = new o.P
                  , h = new o.P
                  , d = new o.P
                  , g = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const r = n.index
                      , i = n.attributes.position;
                    if (null !== r) {
                        for (let n = Math.max(0, s.start), a = Math.min(r.count, s.start + s.count) - 1; n < a; n += g) {
                            const s = r.getX(n)
                              , a = r.getX(n + 1);
                            c.fromBufferAttribute(i, s),
                            u.fromBufferAttribute(i, a);
                            if (p.distanceSqToSegment(c, u, d, h) > l)
                                continue;
                            d.applyMatrix4(this.matrixWorld);
                            const o = t.ray.origin.distanceTo(d);
                            o < t.near || o > t.far || e.push({
                                distance: o,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        for (let n = Math.max(0, s.start), r = Math.min(i.count, s.start + s.count) - 1; n < r; n += g) {
                            c.fromBufferAttribute(i, n),
                            u.fromBufferAttribute(i, n + 1);
                            if (p.distanceSqToSegment(c, u, d, h) > l)
                                continue;
                            d.applyMatrix4(this.matrixWorld);
                            const r = t.ray.origin.distanceTo(d);
                            r < t.near || r > t.far || e.push({
                                distance: r,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else
                    n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        g.prototype.isLine = !0
    },
    5920: function(t, e, n) {
        n.d(e, {
            e: function() {
                return l
            }
        });
        var r = n(1301)
          , i = n(6881)
          , s = n(140);
        const a = new i.P
          , o = new i.P;
        class l extends r.x {
            constructor(t, e) {
                super(t, e),
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , n = [];
                        for (let t = 0, r = e.count; t < r; t += 2)
                            a.fromBufferAttribute(e, t),
                            o.fromBufferAttribute(e, t + 1),
                            n[t] = 0 === t ? 0 : n[t - 1],
                            n[t + 1] = n[t] + a.distanceTo(o);
                        t.setAttribute("lineDistance", new s.a$(n,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }
        l.prototype.isLineSegments = !0
    },
    6454: function(t, e, n) {
        n.d(e, {
            K: function() {
                return P
            }
        });
        var r = n(6881)
          , i = n(1138)
          , s = n(4699)
          , a = n(7540)
          , o = n(9203)
          , l = n(4291)
          , c = n(8121)
          , u = n(1661)
          , h = n(6173)
          , d = n(9046);
        const f = new o.y
          , p = new a.z
          , m = new s.a
          , g = new r.P
          , v = new r.P
          , _ = new r.P
          , y = new r.P
          , x = new r.P
          , b = new r.P
          , w = new r.P
          , M = new r.P
          , T = new r.P
          , S = new i.F
          , E = new i.F
          , A = new i.F
          , R = new r.P
          , L = new r.P;
        class P extends l.T {
            constructor(t=new d.u, e=new h.v) {
                super(),
                this.type = "Mesh",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            raycast(t, e) {
                const n = this.geometry
                  , r = this.material
                  , i = this.matrixWorld;
                if (void 0 === r)
                    return;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                m.copy(n.boundingSphere),
                m.applyMatrix4(i),
                !1 === t.ray.intersectsSphere(m))
                    return;
                if (f.copy(i).invert(),
                p.copy(t.ray).applyMatrix4(f),
                null !== n.boundingBox && !1 === p.intersectsBox(n.boundingBox))
                    return;
                let s;
                if (n.isBufferGeometry) {
                    const i = n.index
                      , a = n.attributes.position
                      , o = n.morphAttributes.position
                      , l = n.morphTargetsRelative
                      , c = n.attributes.uv
                      , u = n.attributes.uv2
                      , h = n.groups
                      , d = n.drawRange;
                    if (null !== i)
                        if (Array.isArray(r))
                            for (let n = 0, f = h.length; n < f; n++) {
                                const f = h[n]
                                  , m = r[f.materialIndex];
                                for (let n = Math.max(f.start, d.start), r = Math.min(f.start + f.count, d.start + d.count); n < r; n += 3) {
                                    const r = i.getX(n)
                                      , h = i.getX(n + 1)
                                      , d = i.getX(n + 2);
                                    s = C(this, m, t, p, a, o, l, c, u, r, h, d),
                                    s && (s.faceIndex = Math.floor(n / 3),
                                    s.face.materialIndex = f.materialIndex,
                                    e.push(s))
                                }
                            }
                        else {
                            for (let n = Math.max(0, d.start), h = Math.min(i.count, d.start + d.count); n < h; n += 3) {
                                const h = i.getX(n)
                                  , d = i.getX(n + 1)
                                  , f = i.getX(n + 2);
                                s = C(this, r, t, p, a, o, l, c, u, h, d, f),
                                s && (s.faceIndex = Math.floor(n / 3),
                                e.push(s))
                            }
                        }
                    else if (void 0 !== a)
                        if (Array.isArray(r))
                            for (let n = 0, i = h.length; n < i; n++) {
                                const i = h[n]
                                  , f = r[i.materialIndex];
                                for (let n = Math.max(i.start, d.start), r = Math.min(i.start + i.count, d.start + d.count); n < r; n += 3) {
                                    s = C(this, f, t, p, a, o, l, c, u, n, n + 1, n + 2),
                                    s && (s.faceIndex = Math.floor(n / 3),
                                    s.face.materialIndex = i.materialIndex,
                                    e.push(s))
                                }
                            }
                        else {
                            for (let n = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); n < i; n += 3) {
                                s = C(this, r, t, p, a, o, l, c, u, n, n + 1, n + 2),
                                s && (s.faceIndex = Math.floor(n / 3),
                                e.push(s))
                            }
                        }
                } else
                    n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        function C(t, e, n, s, a, o, l, h, d, f, p, m) {
            g.fromBufferAttribute(a, f),
            v.fromBufferAttribute(a, p),
            _.fromBufferAttribute(a, m);
            const P = t.morphTargetInfluences;
            if (o && P) {
                w.set(0, 0, 0),
                M.set(0, 0, 0),
                T.set(0, 0, 0);
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = P[t]
                      , n = o[t];
                    0 !== e && (y.fromBufferAttribute(n, f),
                    x.fromBufferAttribute(n, p),
                    b.fromBufferAttribute(n, m),
                    l ? (w.addScaledVector(y, e),
                    M.addScaledVector(x, e),
                    T.addScaledVector(b, e)) : (w.addScaledVector(y.sub(g), e),
                    M.addScaledVector(x.sub(v), e),
                    T.addScaledVector(b.sub(_), e)))
                }
                g.add(w),
                v.add(M),
                _.add(T)
            }
            t.isSkinnedMesh && (t.boneTransform(f, g),
            t.boneTransform(p, v),
            t.boneTransform(m, _));
            const C = function(t, e, n, r, i, s, a, o) {
                let l;
                if (l = e.side === u._Li ? r.intersectTriangle(a, s, i, !0, o) : r.intersectTriangle(i, s, a, e.side !== u.ehD, o),
                null === l)
                    return null;
                L.copy(o),
                L.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(L);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: L.clone(),
                    object: t
                }
            }(t, e, n, s, g, v, _, R);
            if (C) {
                h && (S.fromBufferAttribute(h, f),
                E.fromBufferAttribute(h, p),
                A.fromBufferAttribute(h, m),
                C.uv = c.C.getUV(R, g, v, _, S, E, A, new i.F)),
                d && (S.fromBufferAttribute(d, f),
                E.fromBufferAttribute(d, p),
                A.fromBufferAttribute(d, m),
                C.uv2 = c.C.getUV(R, g, v, _, S, E, A, new i.F));
                const t = {
                    a: f,
                    b: p,
                    c: m,
                    normal: new r.P,
                    materialIndex: 0
                };
                c.C.getNormal(g, v, _, t.normal),
                C.face = t
            }
            return C
        }
        P.prototype.isMesh = !0
    },
    4302: function(t, e, n) {
        n.d(e, {
            d: function() {
                return o
            }
        });
        var r = n(7406)
          , i = n(1244)
          , s = n(1661)
          , a = n(223);
        class o extends r.p {
            constructor(t, e, n={}) {
                super(),
                this.width = t,
                this.height = e,
                this.depth = 1,
                this.scissor = new a.L(0,0,t,e),
                this.scissorTest = !1,
                this.viewport = new a.L(0,0,t,e),
                this.texture = new i.x(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                this.texture.isRenderTargetTexture = !0,
                this.texture.image = {
                    width: t,
                    height: e,
                    depth: 1
                },
                this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
                this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null,
                this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : s.wem,
                this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
                this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
            setTexture(t) {
                t.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                },
                this.texture = t
            }
            setSize(t, e, n=1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t,
                this.height = e,
                this.depth = n,
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = n,
                this.dispose()),
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.viewport.copy(t.viewport),
                this.texture = t.texture.clone(),
                this.texture.image = {
                    ...this.texture.image
                },
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.depthTexture = t.depthTexture,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        o.prototype.isWebGLRenderTarget = !0
    },
    2509: function(t, e, n) {
        n.d(e, {
            C: function() {
                return Mn
            }
        });
        var r = n(1661)
          , i = n(4698)
          , s = n(9203)
          , a = n(6881)
          , o = n(223);
        function l() {
            let t = null
              , e = !1
              , n = null
              , r = null;
            function i(e, s) {
                n(e, s),
                r = t.requestAnimationFrame(i)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (r = t.requestAnimationFrame(i),
                    e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(r),
                    e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function c(t, e) {
            const n = e.isWebGL2
              , r = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data),
                    r.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = r.get(e);
                    n && (t.deleteBuffer(n.buffer),
                    r.delete(e))
                },
                update: function(e, i) {
                    if (e.isGLBufferAttribute) {
                        const t = r.get(e);
                        return void ((!t || t.version < e.version) && r.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = r.get(e);
                    void 0 === s ? r.set(e, function(e, r) {
                        const i = e.array
                          , s = e.usage
                          , a = t.createBuffer();
                        t.bindBuffer(r, a),
                        t.bufferData(r, i, s),
                        e.onUploadCallback();
                        let o = t.FLOAT;
                        return i instanceof Float32Array ? o = t.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? o = t.HALF_FLOAT : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = t.UNSIGNED_SHORT : i instanceof Int16Array ? o = t.SHORT : i instanceof Uint32Array ? o = t.UNSIGNED_INT : i instanceof Int32Array ? o = t.INT : i instanceof Int8Array ? o = t.BYTE : (i instanceof Uint8Array || i instanceof Uint8ClampedArray) && (o = t.UNSIGNED_BYTE),
                        {
                            buffer: a,
                            type: o,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, i)) : s.version < e.version && (!function(e, r, i) {
                        const s = r.array
                          , a = r.updateRange;
                        t.bindBuffer(i, e),
                        -1 === a.count ? t.bufferSubData(i, 0, s) : (n ? t.bufferSubData(i, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(i, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)),
                        a.count = -1)
                    }(s.buffer, e, i),
                    s.version = e.version)
                }
            }
        }
        var u = n(9046)
          , h = n(140);
        class d extends u.u {
            constructor(t=1, e=1, n=1, r=1, i=1, s=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: s
                };
                const o = this;
                r = Math.floor(r),
                i = Math.floor(i),
                s = Math.floor(s);
                const l = []
                  , c = []
                  , u = []
                  , d = [];
                let f = 0
                  , p = 0;
                function m(t, e, n, r, i, s, h, m, g, v, _) {
                    const y = s / g
                      , x = h / v
                      , b = s / 2
                      , w = h / 2
                      , M = m / 2
                      , T = g + 1
                      , S = v + 1;
                    let E = 0
                      , A = 0;
                    const R = new a.P;
                    for (let s = 0; s < S; s++) {
                        const a = s * x - w;
                        for (let o = 0; o < T; o++) {
                            const l = o * y - b;
                            R[t] = l * r,
                            R[e] = a * i,
                            R[n] = M,
                            c.push(R.x, R.y, R.z),
                            R[t] = 0,
                            R[e] = 0,
                            R[n] = m > 0 ? 1 : -1,
                            u.push(R.x, R.y, R.z),
                            d.push(o / g),
                            d.push(1 - s / v),
                            E += 1
                        }
                    }
                    for (let t = 0; t < v; t++)
                        for (let e = 0; e < g; e++) {
                            const n = f + e + T * t
                              , r = f + e + T * (t + 1)
                              , i = f + (e + 1) + T * (t + 1)
                              , s = f + (e + 1) + T * t;
                            l.push(n, r, s),
                            l.push(r, i, s),
                            A += 6
                        }
                    o.addGroup(p, A, _),
                    p += A,
                    f += E
                }
                m("z", "y", "x", -1, -1, n, e, t, s, i, 0),
                m("z", "y", "x", 1, -1, n, e, -t, s, i, 1),
                m("x", "z", "y", 1, 1, t, n, e, r, s, 2),
                m("x", "z", "y", 1, -1, t, n, -e, r, s, 3),
                m("x", "y", "z", 1, -1, t, e, n, r, i, 4),
                m("x", "y", "z", -1, -1, t, e, -n, r, i, 5),
                this.setIndex(l),
                this.setAttribute("position", new h.a$(c,3)),
                this.setAttribute("normal", new h.a$(u,3)),
                this.setAttribute("uv", new h.a$(d,2))
            }
            static fromJSON(t) {
                return new d(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
            }
        }
        var f = n(4078)
          , p = n(876)
          , m = n(3662)
          , g = n(6454);
        const v = {
            alphamap_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n",
            alphamap_pars_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
            alphatest_fragment: "\n#ifdef USE_ALPHATEST\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n#endif\n",
            alphatest_pars_fragment: "\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n",
            aomap_fragment: "\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n\n#endif\n",
            aomap_pars_fragment: "\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n",
            bsdfs: '\n\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick \'94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH \'13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4\'s roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( V * D );\n\n}\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie( float roughness, float NoH ) {\n\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt( float NoV, float NoL ) {\n\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n\n}\n\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif\n',
            bumpmap_pars_fragment: "\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n",
            clipping_planes_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n",
            clipping_planes_pars_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n",
            clipping_planes_pars_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n",
            clipping_planes_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n",
            color_fragment: "\n#if defined( USE_COLOR_ALPHA )\n\n\tdiffuseColor *= vColor;\n\n#elif defined( USE_COLOR )\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n",
            color_pars_fragment: "\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n",
            color_pars_vertex: "\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n",
            color_vertex: "\n#if defined( USE_COLOR_ALPHA )\n\n\tvColor = vec4( 1.0 );\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n\tvColor *= color;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n\tvColor.xyz *= instanceColor.xyz;\n\n#endif\n",
            common: "\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n",
            cube_uv_reflection_fragment: "\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\n\t\tvec2 f = fract( uv );\n\n\t\tuv += 0.5 - f;\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\n\t\t}\n\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\n\t\tuv *= texelSize;\n\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tuv.x += texelSize;\n\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tuv.y += texelSize;\n\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tuv.x -= texelSize;\n\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tvec3 tm = mix( tl, tr, f.x );\n\n\t\tvec3 bm = mix( bl, br, f.x );\n\n\t\treturn mix( tm, bm, f.y );\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= r1 ) {\n\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n\t\t} else if ( roughness >= r4 ) {\n\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n\t\t} else if ( roughness >= r5 ) {\n\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n\t\t} else if ( roughness >= r6 ) {\n\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n",
            defaultnormal_vertex: "\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n",
            displacementmap_pars_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n",
            displacementmap_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n",
            emissivemap_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n",
            emissivemap_pars_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n",
            encodings_fragment: "\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n\t// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\t// NOTE: The implementation with min causes the shader to not compile on\n\t// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests \n\t// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n\t// D = min( floor( D ) / 255.0, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
            envmap_fragment: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvec3 cameraToFrag;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n\t\t}\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t\tenvColor = envMapTexelToLinear( envColor );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n",
            envmap_common_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n",
            envmap_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n",
            envmap_pars_vertex: "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n",
            envmap_physical_pars_fragment: "\n#if defined( USE_ENVMAP )\n\n\t#ifdef ENVMAP_MODE_REFRACTION\n\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n\tvec3 getIBLIrradiance( const in GeometricContext geometry ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 reflectVec;\n\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t\t#else\n\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\n\t\t\t#endif\n\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
            envmap_vertex: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\n\n\tvFogDepth = - mvPosition.z;\n\n#endif\n",
            fog_pars_vertex: "\n#ifdef USE_FOG\n\n\tvarying float vFogDepth;\n\n#endif\n",
            fog_fragment: "\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n",
            fog_pars_fragment: "\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n",
            gradientmap_pars_fragment: "\n\n#ifdef USE_GRADIENTMAP\n\n\tuniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t// dotNL will be from -1.0 to 1.0\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t#ifdef USE_GRADIENTMAP\n\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t#else\n\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t#endif\n\n}\n",
            lightmap_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tlightMapIrradiance *= PI;\n\n\t#endif\n\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n\n#endif\n",
            lightmap_pars_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n",
            lights_lambert_vertex: "\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n\n#ifdef DOUBLE_SIDED\n\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n",
            lights_pars_begin: "\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\treturn irradiance;\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t#else\n\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t#endif\n\n}\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\tif ( spotAttenuation > 0.0 ) {\n\n\t\t\tfloat lightDistance = length( lVector );\n\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t\t} else {\n\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n",
            lights_toon_fragment: "\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\n",
            lights_toon_pars_fragment: "\nvarying vec3 vViewPosition;\n\nstruct ToonMaterial {\n\n\tvec3 diffuseColor;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_phong_fragment: "\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "\nvarying vec3 vViewPosition;\n\nstruct BlinnPhongMaterial {\n\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n\n#ifdef IOR\n\n\t#ifdef SPECULAR\n\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\n\t\t#endif\n\n\t\t#ifdef USE_SPECULARTINTMAP\n\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\n\t\t#endif\n\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\n\t#else\n\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\n\t#endif\n\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenTint = sheenTint;\n\n#endif\n",
            lights_physical_pars_fragment: '\nstruct PhysicalMaterial {\n\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t#endif\n\n};\n\n// temporary\nvec3 clearcoatSpecular = vec3( 0.0 );\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\n\treturn fab;\n\n}\n\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\treturn specularColor * fab.x + specularF90 * fab.y;\n\n}\n\n// Fdez-Agera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n\n\t#else\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n',
            lights_fragment_begin: "\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
            lights_fragment_maps: "\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI;\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getIBLIrradiance( geometry );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\n\t#endif\n\n#endif\n",
            lights_fragment_end: "\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n",
            logdepthbuf_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n",
            logdepthbuf_pars_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n",
            logdepthbuf_pars_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n",
            logdepthbuf_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
            map_fragment: "\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n",
            map_pars_fragment: "\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n",
            map_particle_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n",
            map_particle_pars_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
            metalnessmap_fragment: "\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n",
            metalnessmap_pars_fragment: "\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n",
            morphnormal_vertex: "\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n#endif\n",
            morphtarget_pars_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifndef USE_MORPHNORMALS\n\n\t\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\t\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n",
            morphtarget_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n",
            normal_fragment_begin: "\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n",
            normal_fragment_maps: "\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tnormal = normalize( vTBN * mapN );\n\n\t#else\n\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n\n#endif\n",
            normal_pars_fragment: "\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n",
            normal_pars_vertex: "\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n",
            normal_vertex: "\n#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n",
            normalmap_pars_fragment: "\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Normal Mapping Without Precomputed Tangents\n\t// http://www.thetenthplanet.de/archives/1180\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 N = surf_norm; // normalized\n\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n\t}\n\n#endif\n",
            clearcoat_normal_fragment_begin: "\n#ifdef USE_CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n",
            clearcoat_normal_fragment_maps: "\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\n\t#endif\n\n#endif\n",
            clearcoat_pars_fragment: "\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n",
            output_fragment: "\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n\n// https://github.com/mrdoob/three.js/pull/22425\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\n\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",
            packing: "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\n\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n",
            project_vertex: "\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n",
            dithering_pars_fragment: "\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n",
            roughnessmap_fragment: "\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n",
            roughnessmap_pars_fragment: "\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n",
            shadowmap_pars_fragment: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
            shadowmap_pars_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n",
            shadowmap_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\t// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\n\t#endif\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n",
            shadowmask_pars_fragment: "\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\tDirectionalLightShadow directionalLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\tSpotLightShadow spotLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\tPointLightShadow pointLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n",
            skinbase_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n",
            skinning_pars_vertex: "\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
            skinning_vertex: "\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n",
            skinnormal_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n",
            specularmap_fragment: "\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n",
            specularmap_pars_fragment: "\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n",
            tonemapping_fragment: "\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n",
            tonemapping_pars_fragment: "\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\nvec3 RRTAndODTFit( vec3 v ) {\n\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n\n}\n\n// this implementation of ACES is modified to accommodate a brighter viewing environment.\n// the scale factor of 1/0.6 is subjective. see discussion in #19621.\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\n\tcolor *= toneMappingExposure / 0.6;\n\n\tcolor = ACESInputMat * color;\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat * color;\n\n\t// Clamp to [0, 1]\n\treturn saturate( color );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return color; }\n",
            transmission_fragment: "\n#ifdef USE_TRANSMISSION\n\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\n\t#endif\n\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = transmission.a;\n#endif\n",
            transmission_pars_fragment: "\n#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\n\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#else\n\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#endif\n\n\t}\n\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\n\t\tif ( attenuationDistance == 0.0 ) {\n\n\t\t\t// Attenuation distance is + (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\n\t\t\treturn radiance;\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance * radiance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\n\t}\n#endif\n",
            uv_pars_fragment: "\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n",
            uv_pars_vertex: "\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n",
            uv_vertex: "\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n",
            uv2_pars_fragment: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n",
            uv2_pars_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n",
            uv2_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n",
            worldpos_vertex: "\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n",
            background_frag: "\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            background_vert: "\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n",
            cube_frag: "\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            cube_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n",
            depth_frag: "\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
            depth_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
            distanceRGBA_frag: "\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n",
            distanceRGBA_vert: "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n",
            equirect_frag: "\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV = equirectUv( direction );\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            equirect_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n",
            linedashed_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
            linedashed_vert: "\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshbasic_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshbasic_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshlambert_frag: "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshmatcap_frag: "\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshmatcap_vert: "\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n",
            meshnormal_frag: "\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n",
            meshnormal_vert: "\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n",
            meshphong_frag: "\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshphong_vert: "\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshphysical_frag: "\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\n\tuniform float ior;\n#endif\n\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t#include <transmission_fragment>\n\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\n\t#endif\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshphysical_vert: "\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifdef USE_TRANSMISSION\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n#ifdef USE_TRANSMISSION\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n}\n",
            meshtoon_frag: "\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshtoon_vert: "\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            points_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
            points_vert: "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n",
            shadow_frag: "\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
            shadow_vert: "\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            sprite_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
            sprite_vert: "\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n"
        };
        var _ = n(6682)
          , y = n(1138)
          , x = n(1273);
        const b = {
            common: {
                diffuse: {
                    value: new m.I(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new x.V
                },
                uv2Transform: {
                    value: new x.V
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new y.F(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new m.I(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new m.I(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new x.V
                }
            },
            sprite: {
                diffuse: {
                    value: new m.I(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new y.F(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new x.V
                }
            }
        }
          , w = {
            basic: {
                uniforms: (0,
                _.Rh)([b.common, b.specularmap, b.envmap, b.aomap, b.lightmap, b.fog]),
                vertexShader: v.meshbasic_vert,
                fragmentShader: v.meshbasic_frag
            },
            lambert: {
                uniforms: (0,
                _.Rh)([b.common, b.specularmap, b.envmap, b.aomap, b.lightmap, b.emissivemap, b.fog, b.lights, {
                    emissive: {
                        value: new m.I(0)
                    }
                }]),
                vertexShader: v.meshlambert_vert,
                fragmentShader: v.meshlambert_frag
            },
            phong: {
                uniforms: (0,
                _.Rh)([b.common, b.specularmap, b.envmap, b.aomap, b.lightmap, b.emissivemap, b.bumpmap, b.normalmap, b.displacementmap, b.fog, b.lights, {
                    emissive: {
                        value: new m.I(0)
                    },
                    specular: {
                        value: new m.I(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: v.meshphong_vert,
                fragmentShader: v.meshphong_frag
            },
            standard: {
                uniforms: (0,
                _.Rh)([b.common, b.envmap, b.aomap, b.lightmap, b.emissivemap, b.bumpmap, b.normalmap, b.displacementmap, b.roughnessmap, b.metalnessmap, b.fog, b.lights, {
                    emissive: {
                        value: new m.I(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: v.meshphysical_vert,
                fragmentShader: v.meshphysical_frag
            },
            toon: {
                uniforms: (0,
                _.Rh)([b.common, b.aomap, b.lightmap, b.emissivemap, b.bumpmap, b.normalmap, b.displacementmap, b.gradientmap, b.fog, b.lights, {
                    emissive: {
                        value: new m.I(0)
                    }
                }]),
                vertexShader: v.meshtoon_vert,
                fragmentShader: v.meshtoon_frag
            },
            matcap: {
                uniforms: (0,
                _.Rh)([b.common, b.bumpmap, b.normalmap, b.displacementmap, b.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: v.meshmatcap_vert,
                fragmentShader: v.meshmatcap_frag
            },
            points: {
                uniforms: (0,
                _.Rh)([b.points, b.fog]),
                vertexShader: v.points_vert,
                fragmentShader: v.points_frag
            },
            dashed: {
                uniforms: (0,
                _.Rh)([b.common, b.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: v.linedashed_vert,
                fragmentShader: v.linedashed_frag
            },
            depth: {
                uniforms: (0,
                _.Rh)([b.common, b.displacementmap]),
                vertexShader: v.depth_vert,
                fragmentShader: v.depth_frag
            },
            normal: {
                uniforms: (0,
                _.Rh)([b.common, b.bumpmap, b.normalmap, b.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: v.meshnormal_vert,
                fragmentShader: v.meshnormal_frag
            },
            sprite: {
                uniforms: (0,
                _.Rh)([b.sprite, b.fog]),
                vertexShader: v.sprite_vert,
                fragmentShader: v.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new x.V
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: v.background_vert,
                fragmentShader: v.background_frag
            },
            cube: {
                uniforms: (0,
                _.Rh)([b.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: v.cube_vert,
                fragmentShader: v.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: v.equirect_vert,
                fragmentShader: v.equirect_frag
            },
            distanceRGBA: {
                uniforms: (0,
                _.Rh)([b.common, b.displacementmap, {
                    referencePosition: {
                        value: new a.P
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: v.distanceRGBA_vert,
                fragmentShader: v.distanceRGBA_frag
            },
            shadow: {
                uniforms: (0,
                _.Rh)([b.lights, b.fog, {
                    color: {
                        value: new m.I(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: v.shadow_vert,
                fragmentShader: v.shadow_frag
            }
        };
        function M(t, e, n, i, s) {
            const a = new m.I(0);
            let o, l, c = 0, u = null, h = 0, v = null;
            function y(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, s)
            }
            return {
                getClearColor: function() {
                    return a
                },
                setClearColor: function(t, e=1) {
                    a.set(t),
                    c = e,
                    y(a, c)
                },
                getClearAlpha: function() {
                    return c
                },
                setClearAlpha: function(t) {
                    c = t,
                    y(a, c)
                },
                render: function(n, s) {
                    let m = !1
                      , x = !0 === s.isScene ? s.background : null;
                    x && x.isTexture && (x = e.get(x));
                    const b = t.xr
                      , M = b.getSession && b.getSession();
                    M && "additive" === M.environmentBlendMode && (x = null),
                    null === x ? y(a, c) : x && x.isColor && (y(x, 1),
                    m = !0),
                    (t.autoClear || m) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                    x && (x.isCubeTexture || x.mapping === r.g8_) ? (void 0 === l && (l = new g.K(new d(1,1,1),new p.j({
                        name: "BackgroundCubeMaterial",
                        uniforms: (0,
                        _.dw)(w.cube.uniforms),
                        vertexShader: w.cube.vertexShader,
                        fragmentShader: w.cube.fragmentShader,
                        side: r._Li,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    l.geometry.deleteAttribute("normal"),
                    l.geometry.deleteAttribute("uv"),
                    l.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(l.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    i.update(l)),
                    l.material.uniforms.envMap.value = x,
                    l.material.uniforms.flipEnvMap.value = x.isCubeTexture && !1 === x.isRenderTargetTexture ? -1 : 1,
                    u === x && h === x.version && v === t.toneMapping || (l.material.needsUpdate = !0,
                    u = x,
                    h = x.version,
                    v = t.toneMapping),
                    n.unshift(l, l.geometry, l.material, 0, 0, null)) : x && x.isTexture && (void 0 === o && (o = new g.K(new f._(2,2),new p.j({
                        name: "BackgroundMaterial",
                        uniforms: (0,
                        _.dw)(w.background.uniforms),
                        vertexShader: w.background.vertexShader,
                        fragmentShader: w.background.fragmentShader,
                        side: r.Wl3,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    o.geometry.deleteAttribute("normal"),
                    Object.defineProperty(o.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    i.update(o)),
                    o.material.uniforms.t2D.value = x,
                    !0 === x.matrixAutoUpdate && x.updateMatrix(),
                    o.material.uniforms.uvTransform.value.copy(x.matrix),
                    u === x && h === x.version && v === t.toneMapping || (o.material.needsUpdate = !0,
                    u = x,
                    h = x.version,
                    v = t.toneMapping),
                    n.unshift(o, o.geometry, o.material, 0, 0, null))
                }
            }
        }
        function T(t, e, n, r) {
            const i = t.getParameter(t.MAX_VERTEX_ATTRIBS)
              , s = r.isWebGL2 ? null : e.get("OES_vertex_array_object")
              , a = r.isWebGL2 || null !== s
              , o = {}
              , l = d(null);
            let c = l;
            function u(e) {
                return r.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }
            function h(e) {
                return r.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }
            function d(t) {
                const e = []
                  , n = []
                  , r = [];
                for (let t = 0; t < i; t++)
                    e[t] = 0,
                    n[t] = 0,
                    r[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function f() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e] = 0
            }
            function p(t) {
                m(t, 0)
            }
            function m(n, i) {
                const s = c.newAttributes
                  , a = c.enabledAttributes
                  , o = c.attributeDivisors;
                if (s[n] = 1,
                0 === a[n] && (t.enableVertexAttribArray(n),
                a[n] = 1),
                o[n] !== i) {
                    (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i),
                    o[n] = i
                }
            }
            function g() {
                const e = c.newAttributes
                  , n = c.enabledAttributes;
                for (let r = 0, i = n.length; r < i; r++)
                    n[r] !== e[r] && (t.disableVertexAttribArray(r),
                    n[r] = 0)
            }
            function v(e, n, i, s, a, o) {
                !0 !== r.isWebGL2 || i !== t.INT && i !== t.UNSIGNED_INT ? t.vertexAttribPointer(e, n, i, s, a, o) : t.vertexAttribIPointer(e, n, i, a, o)
            }
            function _() {
                y(),
                c !== l && (c = l,
                u(c.object))
            }
            function y() {
                l.geometry = null,
                l.program = null,
                l.wireframe = !1
            }
            return {
                setup: function(i, l, h, _, y) {
                    let x = !1;
                    if (a) {
                        const e = function(e, n, i) {
                            const a = !0 === i.wireframe;
                            let l = o[e.id];
                            void 0 === l && (l = {},
                            o[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {},
                            l[n.id] = c);
                            let u = c[a];
                            void 0 === u && (u = d(r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                            c[a] = u);
                            return u
                        }(_, h, l);
                        c !== e && (c = e,
                        u(c.object)),
                        x = function(t, e) {
                            const n = c.attributes
                              , r = t.attributes;
                            let i = 0;
                            for (const t in r) {
                                const e = n[t]
                                  , s = r[t];
                                if (void 0 === e)
                                    return !0;
                                if (e.attribute !== s)
                                    return !0;
                                if (e.data !== s.data)
                                    return !0;
                                i++
                            }
                            return c.attributesNum !== i || c.index !== e
                        }(_, y),
                        x && function(t, e) {
                            const n = {}
                              , r = t.attributes;
                            let i = 0;
                            for (const t in r) {
                                const e = r[t]
                                  , s = {};
                                s.attribute = e,
                                e.data && (s.data = e.data),
                                n[t] = s,
                                i++
                            }
                            c.attributes = n,
                            c.attributesNum = i,
                            c.index = e
                        }(_, y)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === _.id && c.program === h.id && c.wireframe === t || (c.geometry = _.id,
                        c.program = h.id,
                        c.wireframe = t,
                        x = !0)
                    }
                    !0 === i.isInstancedMesh && (x = !0),
                    null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER),
                    x && (!function(i, s, a, o) {
                        if (!1 === r.isWebGL2 && (i.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                            return;
                        f();
                        const l = o.attributes
                          , c = a.getAttributes()
                          , u = s.defaultAttributeValues;
                        for (const e in c) {
                            const r = c[e];
                            if (r.location >= 0) {
                                let s = l[e];
                                if (void 0 === s && ("instanceMatrix" === e && i.instanceMatrix && (s = i.instanceMatrix),
                                "instanceColor" === e && i.instanceColor && (s = i.instanceColor)),
                                void 0 !== s) {
                                    const e = s.normalized
                                      , a = s.itemSize
                                      , l = n.get(s);
                                    if (void 0 === l)
                                        continue;
                                    const c = l.buffer
                                      , u = l.type
                                      , h = l.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data
                                          , l = n.stride
                                          , d = s.offset;
                                        if (n && n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < r.locationSize; t++)
                                                m(r.location + t, n.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < r.locationSize; t++)
                                                p(r.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, c);
                                        for (let t = 0; t < r.locationSize; t++)
                                            v(r.location + t, a / r.locationSize, u, e, l * h, (d + a / r.locationSize * t) * h)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let t = 0; t < r.locationSize; t++)
                                                m(r.location + t, s.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let t = 0; t < r.locationSize; t++)
                                                p(r.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, c);
                                        for (let t = 0; t < r.locationSize; t++)
                                            v(r.location + t, a / r.locationSize, u, e, a * h, a / r.locationSize * t * h)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n)
                                        switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(r.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(r.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(r.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(r.location, n)
                                        }
                                }
                            }
                        }
                        g()
                    }(i, l, h, _),
                    null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer))
                },
                reset: _,
                resetDefaultState: y,
                dispose: function() {
                    _();
                    for (const t in o) {
                        const e = o[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n)
                                h(n[t].object),
                                delete n[t];
                            delete e[t]
                        }
                        delete o[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === o[t.id])
                        return;
                    const e = o[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            h(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete o[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in o) {
                        const n = o[e];
                        if (void 0 === n[t.id])
                            continue;
                        const r = n[t.id];
                        for (const t in r)
                            h(r[t].object),
                            delete r[t];
                        delete n[t.id]
                    }
                },
                initAttributes: f,
                enableAttribute: p,
                disableUnusedAttributes: g
            }
        }
        function S(t, e, n, r) {
            const i = r.isWebGL2;
            let s;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.render = function(e, r) {
                t.drawArrays(s, e, r),
                n.update(r, s, 1)
            }
            ,
            this.renderInstances = function(r, a, o) {
                if (0 === o)
                    return;
                let l, c;
                if (i)
                    l = t,
                    c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"),
                c = "drawArraysInstancedANGLE",
                null === l)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](s, r, a, o),
                n.update(a, s, o)
            }
        }
        function E(t, e, n) {
            let r;
            function i(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const o = i(a);
            o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            a = o);
            const l = s || e.has("WEBGL_draw_buffers")
              , c = !0 === n.logarithmicDepthBuffer
              , u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
              , h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , d = t.getParameter(t.MAX_TEXTURE_SIZE)
              , f = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
              , p = t.getParameter(t.MAX_VERTEX_ATTRIBS)
              , m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
              , g = t.getParameter(t.MAX_VARYING_VECTORS)
              , v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
              , _ = h > 0
              , y = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== r)
                        return r;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        r = 0;
                    return r
                },
                getMaxPrecision: i,
                precision: a,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: f,
                maxAttributes: p,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: _,
                floatFragmentTextures: y,
                floatVertexTextures: _ && y,
                maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
            }
        }
        w.physical = {
            uniforms: (0,
            _.Rh)([w.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new y.F(1,1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheenTint: {
                    value: new m.I(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new y.F
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationTint: {
                    value: new m.I(0)
                },
                specularIntensity: {
                    value: 0
                },
                specularIntensityMap: {
                    value: null
                },
                specularTint: {
                    value: new m.I(1,1,1)
                },
                specularTintMap: {
                    value: null
                }
            }]),
            vertexShader: v.meshphysical_vert,
            fragmentShader: v.meshphysical_frag
        };
        var A = n(1158);
        function R(t) {
            const e = this;
            let n = null
              , r = 0
              , i = !1
              , s = !1;
            const a = new A.J
              , o = new x.V
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c() {
                l.value !== n && (l.value = n,
                l.needsUpdate = r > 0),
                e.numPlanes = r,
                e.numIntersection = 0
            }
            function u(t, n, r, i) {
                const s = null !== t ? t.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value,
                    !0 !== i || null === c) {
                        const e = r + 4 * s
                          , i = n.matrixWorldInverse;
                        o.getNormalMatrix(i),
                        (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = r; e !== s; ++e,
                        n += 4)
                            a.copy(t[e]).applyMatrix4(i, o),
                            a.normal.toArray(c, n),
                            c[n + 3] = a.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return e.numPlanes = s,
                e.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, e, s) {
                const a = 0 !== t.length || e || 0 !== r || i;
                return i = e,
                n = u(t, s, 0),
                r = t.length,
                a
            }
            ,
            this.beginShadows = function() {
                s = !0,
                u(null)
            }
            ,
            this.endShadows = function() {
                s = !1,
                c()
            }
            ,
            this.setState = function(e, a, o) {
                const h = e.clippingPlanes
                  , d = e.clipIntersection
                  , f = e.clipShadows
                  , p = t.get(e);
                if (!i || null === h || 0 === h.length || s && !f)
                    s ? u(null) : c();
                else {
                    const t = s ? 0 : r
                      , e = 4 * t;
                    let i = p.clippingState || null;
                    l.value = i,
                    i = u(h, a, e, o);
                    for (let t = 0; t !== e; ++t)
                        i[t] = n[t];
                    p.clippingState = i,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += t
                }
            }
        }
        var L = n(4302)
          , P = n(4291)
          , C = n(1051);
        const D = 90;
        class I extends P.T {
            constructor(t, e, n) {
                if (super(),
                this.type = "CubeCamera",
                !0 !== n.isWebGLCubeRenderTarget)
                    return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const r = new C.c(D,1,t,e);
                r.layers = this.layers,
                r.up.set(0, -1, 0),
                r.lookAt(new a.P(1,0,0)),
                this.add(r);
                const i = new C.c(D,1,t,e);
                i.layers = this.layers,
                i.up.set(0, -1, 0),
                i.lookAt(new a.P(-1,0,0)),
                this.add(i);
                const s = new C.c(D,1,t,e);
                s.layers = this.layers,
                s.up.set(0, 0, 1),
                s.lookAt(new a.P(0,1,0)),
                this.add(s);
                const o = new C.c(D,1,t,e);
                o.layers = this.layers,
                o.up.set(0, 0, -1),
                o.lookAt(new a.P(0,-1,0)),
                this.add(o);
                const l = new C.c(D,1,t,e);
                l.layers = this.layers,
                l.up.set(0, -1, 0),
                l.lookAt(new a.P(0,0,1)),
                this.add(l);
                const c = new C.c(D,1,t,e);
                c.layers = this.layers,
                c.up.set(0, -1, 0),
                c.lookAt(new a.P(0,0,-1)),
                this.add(c)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget
                  , [r,i,s,a,o,l] = this.children
                  , c = t.xr.enabled
                  , u = t.getRenderTarget();
                t.xr.enabled = !1;
                const h = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                t.setRenderTarget(n, 0),
                t.render(e, r),
                t.setRenderTarget(n, 1),
                t.render(e, i),
                t.setRenderTarget(n, 2),
                t.render(e, s),
                t.setRenderTarget(n, 3),
                t.render(e, a),
                t.setRenderTarget(n, 4),
                t.render(e, o),
                n.texture.generateMipmaps = h,
                t.setRenderTarget(n, 5),
                t.render(e, l),
                t.setRenderTarget(u),
                t.xr.enabled = c
            }
        }
        var N = n(3882);
        class F extends L.d {
            constructor(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
                e = n),
                super(t, t, e),
                e = e || {},
                this.texture = new N.B(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : r.wem,
                this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                this.texture.format = r.wk1,
                this.texture.encoding = e.encoding,
                this.texture.generateMipmaps = e.generateMipmaps,
                this.texture.minFilter = e.minFilter,
                this.texture.magFilter = e.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , i = new d(5,5,5)
                  , s = new p.j({
                    name: "CubemapFromEquirect",
                    uniforms: (0,
                    _.dw)(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: r._Li,
                    blending: r.jFi
                });
                s.uniforms.tEquirect.value = e;
                const a = new g.K(i,s)
                  , o = e.minFilter;
                e.minFilter === r.D1R && (e.minFilter = r.wem);
                return new I(1,10,this).update(t, a),
                e.minFilter = o,
                a.geometry.dispose(),
                a.material.dispose(),
                this
            }
            clear(t, e, n, r) {
                const i = t.getRenderTarget();
                for (let i = 0; i < 6; i++)
                    t.setRenderTarget(this, i),
                    t.clear(e, n, r);
                t.setRenderTarget(i)
            }
        }
        function O(t) {
            let e = new WeakMap;
            function n(t, e) {
                return e === r.dSO ? t.mapping = r.fY$ : e === r.Bf4 && (t.mapping = r.vxC),
                t
            }
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(s) {
                    if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
                        const a = s.mapping;
                        if (a === r.dSO || a === r.Bf4) {
                            if (e.has(s)) {
                                return n(e.get(s).texture, s.mapping)
                            }
                            {
                                const r = s.image;
                                if (r && r.height > 0) {
                                    const a = t.getRenderTarget()
                                      , o = new F(r.height / 2);
                                    return o.fromEquirectangularTexture(t, s),
                                    e.set(s, o),
                                    t.setRenderTarget(a),
                                    s.addEventListener("dispose", i),
                                    n(o.texture, s.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return s
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        F.prototype.isWebGLCubeRenderTarget = !0;
        var U = n(3131)
          , z = n(8549)
          , B = n(6173);
        const k = 4
          , G = 8
          , H = Math.pow(2, G)
          , V = [.125, .215, .35, .446, .526, .582]
          , W = G - k + 1 + V.length
          , X = 20
          , j = {
            [r.rnI]: 0,
            [r.knz]: 1,
            [r.KC9]: 2,
            [r.LgE]: 3,
            [r.Inb]: 4,
            [r.gMp]: 5,
            [r.pMV]: 6
        }
          , Y = new U.i
          , {_lodPlanes: q, _sizeLods: Z, _sigmas: K} = it()
          , J = new m.I;
        let Q = null;
        const $ = (1 + Math.sqrt(5)) / 2
          , tt = 1 / $
          , et = [new a.P(1,1,1), new a.P(-1,1,1), new a.P(1,1,-1), new a.P(-1,1,-1), new a.P(0,$,tt), new a.P(0,$,-tt), new a.P(tt,0,$), new a.P(-tt,0,$), new a.P($,tt,0), new a.P(-$,tt,0)];
        class nt {
            constructor(t) {
                this._renderer = t,
                this._pingPongRenderTarget = null,
                this._blurMaterial = function(t) {
                    const e = new Float32Array(t)
                      , n = new a.P(0,1,0);
                    return new z.F({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: t
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: e
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: n
                            },
                            inputEncoding: {
                                value: j[r.rnI]
                            },
                            outputEncoding: {
                                value: j[r.rnI]
                            }
                        },
                        vertexShader: ct(),
                        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t ${ut()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                        blending: r.jFi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(X),
                this._equirectShader = null,
                this._cubemapShader = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e=0, n=.1, r=100) {
                Q = this._renderer.getRenderTarget();
                const i = this._allocateTargets();
                return this._sceneToCubeUV(t, n, r, i),
                e > 0 && this._blur(i, 0, 0, e),
                this._applyPMREM(i),
                this._cleanup(i),
                i
            }
            fromEquirectangular(t) {
                return this._fromTexture(t)
            }
            fromCubemap(t) {
                return this._fromTexture(t)
            }
            compileCubemapShader() {
                null === this._cubemapShader && (this._cubemapShader = lt(),
                this._compileMaterial(this._cubemapShader))
            }
            compileEquirectangularShader() {
                null === this._equirectShader && (this._equirectShader = ot(),
                this._compileMaterial(this._equirectShader))
            }
            dispose() {
                this._blurMaterial.dispose(),
                null !== this._cubemapShader && this._cubemapShader.dispose(),
                null !== this._equirectShader && this._equirectShader.dispose();
                for (let t = 0; t < q.length; t++)
                    q[t].dispose()
            }
            _cleanup(t) {
                this._pingPongRenderTarget.dispose(),
                this._renderer.setRenderTarget(Q),
                t.scissorTest = !1,
                at(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t) {
                Q = this._renderer.getRenderTarget();
                const e = this._allocateTargets(t);
                return this._textureToCubeUV(t, e),
                this._applyPMREM(e),
                this._cleanup(e),
                e
            }
            _allocateTargets(t) {
                const e = {
                    magFilter: r.TyD,
                    minFilter: r.TyD,
                    generateMipmaps: !1,
                    type: r.ywz,
                    format: r.aoB,
                    encoding: rt(t) ? t.encoding : r.KC9,
                    depthBuffer: !1
                }
                  , n = st(e);
                return n.depthBuffer = !t,
                this._pingPongRenderTarget = st(e),
                n
            }
            _compileMaterial(t) {
                const e = new g.K(q[0],t);
                this._renderer.compile(e, Y)
            }
            _sceneToCubeUV(t, e, n, i) {
                const s = new C.c(90,1,e,n)
                  , a = [1, -1, 1, 1, 1, 1]
                  , o = [1, 1, 1, -1, -1, -1]
                  , l = this._renderer
                  , c = l.autoClear
                  , u = l.outputEncoding
                  , h = l.toneMapping;
                l.getClearColor(J),
                l.toneMapping = r.uL9,
                l.outputEncoding = r.rnI,
                l.autoClear = !1;
                const f = new B.v({
                    name: "PMREM.Background",
                    side: r._Li,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , p = new g.K(new d,f);
                let m = !1;
                const v = t.background;
                v ? v.isColor && (f.color.copy(v),
                t.background = null,
                m = !0) : (f.color.copy(J),
                m = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 == n ? (s.up.set(0, a[e], 0),
                    s.lookAt(o[e], 0, 0)) : 1 == n ? (s.up.set(0, 0, a[e]),
                    s.lookAt(0, o[e], 0)) : (s.up.set(0, a[e], 0),
                    s.lookAt(0, 0, o[e])),
                    at(i, n * H, e > 2 ? H : 0, H, H),
                    l.setRenderTarget(i),
                    m && l.render(p, s),
                    l.render(t, s)
                }
                p.geometry.dispose(),
                p.material.dispose(),
                l.toneMapping = h,
                l.outputEncoding = u,
                l.autoClear = c,
                t.background = v
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer;
                t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = lt()) : null == this._equirectShader && (this._equirectShader = ot());
                const r = t.isCubeTexture ? this._cubemapShader : this._equirectShader
                  , i = new g.K(q[0],r)
                  , s = r.uniforms;
                s.envMap.value = t,
                t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
                s.inputEncoding.value = j[t.encoding],
                s.outputEncoding.value = j[e.texture.encoding],
                at(e, 0, 0, 3 * H, 2 * H),
                n.setRenderTarget(e),
                n.render(i, Y)
            }
            _applyPMREM(t) {
                const e = this._renderer
                  , n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < W; e++) {
                    const n = Math.sqrt(K[e] * K[e] - K[e - 1] * K[e - 1])
                      , r = et[(e - 1) % et.length];
                    this._blur(t, e - 1, e, n, r)
                }
                e.autoClear = n
            }
            _blur(t, e, n, r, i) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(t, s, e, n, r, "latitudinal", i),
                this._halfBlur(s, t, n, n, r, "longitudinal", i)
            }
            _halfBlur(t, e, n, r, i, s, a) {
                const o = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new g.K(q[r],l)
                  , u = l.uniforms
                  , h = Z[n] - 1
                  , d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39
                  , f = i / d
                  , p = isFinite(i) ? 1 + Math.floor(3 * f) : X;
                p > X && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                const m = [];
                let v = 0;
                for (let t = 0; t < X; ++t) {
                    const e = t / f
                      , n = Math.exp(-e * e / 2);
                    m.push(n),
                    0 == t ? v += n : t < p && (v += 2 * n)
                }
                for (let t = 0; t < m.length; t++)
                    m[t] = m[t] / v;
                u.envMap.value = t.texture,
                u.samples.value = p,
                u.weights.value = m,
                u.latitudinal.value = "latitudinal" === s,
                a && (u.poleAxis.value = a),
                u.dTheta.value = d,
                u.mipInt.value = G - n,
                u.inputEncoding.value = j[t.texture.encoding],
                u.outputEncoding.value = j[t.texture.encoding];
                const _ = Z[r];
                at(e, 3 * Math.max(0, H - 2 * _), (0 === r ? 0 : 2 * H) + 2 * _ * (r > G - k ? r - G + k : 0), 3 * _, 2 * _),
                o.setRenderTarget(e),
                o.render(c, Y)
            }
        }
        function rt(t) {
            return void 0 !== t && t.type === r.ywz && (t.encoding === r.rnI || t.encoding === r.knz || t.encoding === r.pMV)
        }
        function it() {
            const t = []
              , e = []
              , n = [];
            let r = G;
            for (let i = 0; i < W; i++) {
                const s = Math.pow(2, r);
                e.push(s);
                let a = 1 / s;
                i > G - k ? a = V[i - G + k - 1] : 0 == i && (a = 0),
                n.push(a);
                const o = 1 / (s - 1)
                  , l = -o / 2
                  , c = 1 + o / 2
                  , d = [l, l, c, l, c, c, l, l, c, c, l, c]
                  , f = 6
                  , p = 6
                  , m = 3
                  , g = 2
                  , v = 1
                  , _ = new Float32Array(m * p * f)
                  , y = new Float32Array(g * p * f)
                  , x = new Float32Array(v * p * f);
                for (let t = 0; t < f; t++) {
                    const e = t % 3 * 2 / 3 - 1
                      , n = t > 2 ? 0 : -1
                      , r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    _.set(r, m * p * t),
                    y.set(d, g * p * t);
                    const i = [t, t, t, t, t, t];
                    x.set(i, v * p * t)
                }
                const b = new u.u;
                b.setAttribute("position", new h.Tl(_,m)),
                b.setAttribute("uv", new h.Tl(y,g)),
                b.setAttribute("faceIndex", new h.Tl(x,v)),
                t.push(b),
                r > k && r--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }
        function st(t) {
            const e = new L.d(3 * H,3 * H,t);
            return e.texture.mapping = r.g8_,
            e.texture.name = "PMREM.cubeUv",
            e.scissorTest = !0,
            e
        }
        function at(t, e, n, r, i) {
            t.viewport.set(e, n, r, i),
            t.scissor.set(e, n, r, i)
        }
        function ot() {
            const t = new y.F(1,1);
            return new z.F({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: t
                    },
                    inputEncoding: {
                        value: j[r.rnI]
                    },
                    outputEncoding: {
                        value: j[r.rnI]
                    }
                },
                vertexShader: ct(),
                fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t ${ut()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                blending: r.jFi,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function lt() {
            return new z.F({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: j[r.rnI]
                    },
                    outputEncoding: {
                        value: j[r.rnI]
                    }
                },
                vertexShader: ct(),
                fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t ${ut()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                blending: r.jFi,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function ct() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }
        function ut() {
            return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
        }
        function ht(t) {
            let e = new WeakMap
              , n = null;
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(s) {
                    if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
                        const a = s.mapping
                          , o = a === r.dSO || a === r.Bf4
                          , l = a === r.fY$ || a === r.vxC;
                        if (o || l) {
                            if (e.has(s))
                                return e.get(s).texture;
                            {
                                const r = s.image;
                                if (o && r && r.height > 0 || l && r && function(t) {
                                    let e = 0;
                                    const n = 6;
                                    for (let r = 0; r < n; r++)
                                        void 0 !== t[r] && e++;
                                    return e === n
                                }(r)) {
                                    const r = t.getRenderTarget();
                                    null === n && (n = new nt(t));
                                    const a = o ? n.fromEquirectangular(s) : n.fromCubemap(s);
                                    return e.set(s, a),
                                    t.setRenderTarget(r),
                                    s.addEventListener("dispose", i),
                                    a.texture
                                }
                                return null
                            }
                        }
                    }
                    return s
                },
                dispose: function() {
                    e = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function dt(t) {
            const e = {};
            function n(n) {
                if (void 0 !== e[n])
                    return e[n];
                let r;
                switch (n) {
                case "WEBGL_depth_texture":
                    r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    r = t.getExtension(n)
                }
                return e[n] = r,
                r
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                    n("OES_texture_float"),
                    n("OES_texture_half_float"),
                    n("OES_texture_half_float_linear"),
                    n("OES_standard_derivatives"),
                    n("OES_element_index_uint"),
                    n("OES_vertex_array_object"),
                    n("ANGLE_instanced_arrays")),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                    e
                }
            }
        }
        var ft = n(392);
        function pt(t, e, n, r) {
            const i = {}
              , s = new WeakMap;
            function a(t) {
                const o = t.target;
                null !== o.index && e.remove(o.index);
                for (const t in o.attributes)
                    e.remove(o.attributes[t]);
                o.removeEventListener("dispose", a),
                delete i[o.id];
                const l = s.get(o);
                l && (e.remove(l),
                s.delete(o)),
                r.releaseStatesOfGeometry(o),
                !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                n.memory.geometries--
            }
            function o(t) {
                const n = []
                  , r = t.index
                  , i = t.attributes.position;
                let a = 0;
                if (null !== r) {
                    const t = r.array;
                    a = r.version;
                    for (let e = 0, r = t.length; e < r; e += 3) {
                        const r = t[e + 0]
                          , i = t[e + 1]
                          , s = t[e + 2];
                        n.push(r, i, i, s, s, r)
                    }
                } else {
                    const t = i.array;
                    a = i.version;
                    for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                        const t = e + 0
                          , r = e + 1
                          , i = e + 2;
                        n.push(t, r, r, i, i, t)
                    }
                }
                const o = new ((0,
                ft.uH)(n) > 65535 ? h.lC : h.ql)(n,1);
                o.version = a;
                const l = s.get(t);
                l && e.remove(l),
                s.set(t, o)
            }
            return {
                get: function(t, e) {
                    return !0 === i[e.id] || (e.addEventListener("dispose", a),
                    i[e.id] = !0,
                    n.memory.geometries++),
                    e
                },
                update: function(n) {
                    const r = n.attributes;
                    for (const n in r)
                        e.update(r[n], t.ARRAY_BUFFER);
                    const i = n.morphAttributes;
                    for (const n in i) {
                        const r = i[n];
                        for (let n = 0, i = r.length; n < i; n++)
                            e.update(r[n], t.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && o(t)
                    } else
                        o(t);
                    return s.get(t)
                }
            }
        }
        function mt(t, e, n, r) {
            const i = r.isWebGL2;
            let s, a, o;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.setIndex = function(t) {
                a = t.type,
                o = t.bytesPerElement
            }
            ,
            this.render = function(e, r) {
                t.drawElements(s, r, a, e * o),
                n.update(r, s, 1)
            }
            ,
            this.renderInstances = function(r, l, c) {
                if (0 === c)
                    return;
                let u, h;
                if (i)
                    u = t,
                    h = "drawElementsInstanced";
                else if (u = e.get("ANGLE_instanced_arrays"),
                h = "drawElementsInstancedANGLE",
                null === u)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[h](s, l, a, r * o, c),
                n.update(l, s, c)
            }
        }
        function gt(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++,
                    e.calls = 0,
                    e.triangles = 0,
                    e.points = 0,
                    e.lines = 0
                },
                update: function(n, r, i) {
                    switch (e.calls++,
                    r) {
                    case t.TRIANGLES:
                        e.triangles += i * (n / 3);
                        break;
                    case t.LINES:
                        e.lines += i * (n / 2);
                        break;
                    case t.LINE_STRIP:
                        e.lines += i * (n - 1);
                        break;
                    case t.LINE_LOOP:
                        e.lines += i * n;
                        break;
                    case t.POINTS:
                        e.points += i * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                    }
                }
            }
        }
        function vt(t, e) {
            return t[0] - e[0]
        }
        function _t(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }
        function yt(t) {
            const e = {}
              , n = new Float32Array(8)
              , r = [];
            for (let t = 0; t < 8; t++)
                r[t] = [t, 0];
            return {
                update: function(i, s, a, o) {
                    const l = i.morphTargetInfluences
                      , c = void 0 === l ? 0 : l.length;
                    let u = e[s.id];
                    if (void 0 === u || u.length !== c) {
                        u = [];
                        for (let t = 0; t < c; t++)
                            u[t] = [t, 0];
                        e[s.id] = u
                    }
                    for (let t = 0; t < c; t++) {
                        const e = u[t];
                        e[0] = t,
                        e[1] = l[t]
                    }
                    u.sort(_t);
                    for (let t = 0; t < 8; t++)
                        t < c && u[t][1] ? (r[t][0] = u[t][0],
                        r[t][1] = u[t][1]) : (r[t][0] = Number.MAX_SAFE_INTEGER,
                        r[t][1] = 0);
                    r.sort(vt);
                    const h = s.morphAttributes.position
                      , d = s.morphAttributes.normal;
                    let f = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = r[t]
                          , i = e[0]
                          , a = e[1];
                        i !== Number.MAX_SAFE_INTEGER && a ? (h && s.getAttribute("morphTarget" + t) !== h[i] && s.setAttribute("morphTarget" + t, h[i]),
                        d && s.getAttribute("morphNormal" + t) !== d[i] && s.setAttribute("morphNormal" + t, d[i]),
                        n[t] = a,
                        f += a) : (h && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t),
                        d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t),
                        n[t] = 0)
                    }
                    const p = s.morphTargetsRelative ? 1 : 1 - f;
                    o.getUniforms().setValue(t, "morphTargetBaseInfluence", p),
                    o.getUniforms().setValue(t, "morphTargetInfluences", n)
                }
            }
        }
        class xt extends L.d {
            constructor(t, e, n) {
                super(t, e, n),
                this.samples = 4
            }
            copy(t) {
                return super.copy.call(this, t),
                this.samples = t.samples,
                this
            }
        }
        function bt(t, e, n, r) {
            let i = new WeakMap;
            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s),
                n.remove(e.instanceMatrix),
                null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(a) {
                    const o = r.render.frame
                      , l = a.geometry
                      , c = e.get(a, l);
                    return i.get(c) !== o && (e.update(c),
                    i.set(c, o)),
                    a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s),
                    n.update(a.instanceMatrix, t.ARRAY_BUFFER),
                    null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER)),
                    c
                },
                dispose: function() {
                    i = new WeakMap
                }
            }
        }
        xt.prototype.isWebGLMultisampleRenderTarget = !0;
        var wt = n(1244);
        class Mt extends wt.x {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = r.TyD,
                this.minFilter = r.TyD,
                this.wrapR = r.uWy,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        Mt.prototype.isDataTexture2DArray = !0;
        class Tt extends wt.x {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = r.TyD,
                this.minFilter = r.TyD,
                this.wrapR = r.uWy,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        Tt.prototype.isDataTexture3D = !0;
        const St = new wt.x
          , Et = new Mt
          , At = new Tt
          , Rt = new N.B
          , Lt = []
          , Pt = []
          , Ct = new Float32Array(16)
          , Dt = new Float32Array(9)
          , It = new Float32Array(4);
        function Nt(t, e, n) {
            const r = t[0];
            if (r <= 0 || r > 0)
                return t;
            const i = e * n;
            let s = Lt[i];
            if (void 0 === s && (s = new Float32Array(i),
            Lt[i] = s),
            0 !== e) {
                r.toArray(s, 0);
                for (let r = 1, i = 0; r !== e; ++r)
                    i += n,
                    t[r].toArray(s, i)
            }
            return s
        }
        function Ft(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let n = 0, r = t.length; n < r; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function Ot(t, e) {
            for (let n = 0, r = e.length; n < r; n++)
                t[n] = e[n]
        }
        function Ut(t, e) {
            let n = Pt[e];
            void 0 === n && (n = new Int32Array(e),
            Pt[e] = n);
            for (let r = 0; r !== e; ++r)
                n[r] = t.allocateTextureUnit();
            return n
        }
        function zt(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e),
            n[0] = e)
        }
        function Bt(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (Ft(n, e))
                    return;
                t.uniform2fv(this.addr, e),
                Ot(n, e)
            }
        }
        function kt(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else if (void 0 !== e.r)
                n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                n[0] = e.r,
                n[1] = e.g,
                n[2] = e.b);
            else {
                if (Ft(n, e))
                    return;
                t.uniform3fv(this.addr, e),
                Ot(n, e)
            }
        }
        function Gt(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (Ft(n, e))
                    return;
                t.uniform4fv(this.addr, e),
                Ot(n, e)
            }
        }
        function Ht(t, e) {
            const n = this.cache
              , r = e.elements;
            if (void 0 === r) {
                if (Ft(n, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                Ot(n, e)
            } else {
                if (Ft(n, r))
                    return;
                It.set(r),
                t.uniformMatrix2fv(this.addr, !1, It),
                Ot(n, r)
            }
        }
        function Vt(t, e) {
            const n = this.cache
              , r = e.elements;
            if (void 0 === r) {
                if (Ft(n, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                Ot(n, e)
            } else {
                if (Ft(n, r))
                    return;
                Dt.set(r),
                t.uniformMatrix3fv(this.addr, !1, Dt),
                Ot(n, r)
            }
        }
        function Wt(t, e) {
            const n = this.cache
              , r = e.elements;
            if (void 0 === r) {
                if (Ft(n, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                Ot(n, e)
            } else {
                if (Ft(n, r))
                    return;
                Ct.set(r),
                t.uniformMatrix4fv(this.addr, !1, Ct),
                Ot(n, r)
            }
        }
        function Xt(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e),
            n[0] = e)
        }
        function jt(t, e) {
            const n = this.cache;
            Ft(n, e) || (t.uniform2iv(this.addr, e),
            Ot(n, e))
        }
        function Yt(t, e) {
            const n = this.cache;
            Ft(n, e) || (t.uniform3iv(this.addr, e),
            Ot(n, e))
        }
        function qt(t, e) {
            const n = this.cache;
            Ft(n, e) || (t.uniform4iv(this.addr, e),
            Ot(n, e))
        }
        function Zt(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e),
            n[0] = e)
        }
        function Kt(t, e) {
            const n = this.cache;
            Ft(n, e) || (t.uniform2uiv(this.addr, e),
            Ot(n, e))
        }
        function Jt(t, e) {
            const n = this.cache;
            Ft(n, e) || (t.uniform3uiv(this.addr, e),
            Ot(n, e))
        }
        function Qt(t, e) {
            const n = this.cache;
            Ft(n, e) || (t.uniform4uiv(this.addr, e),
            Ot(n, e))
        }
        function $t(t, e, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i),
            r[0] = i),
            n.safeSetTexture2D(e || St, i)
        }
        function te(t, e, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i),
            r[0] = i),
            n.setTexture3D(e || At, i)
        }
        function ee(t, e, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i),
            r[0] = i),
            n.safeSetTextureCube(e || Rt, i)
        }
        function ne(t, e, n) {
            const r = this.cache
              , i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i),
            r[0] = i),
            n.setTexture2DArray(e || Et, i)
        }
        function re(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function ie(t, e) {
            const n = Nt(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }
        function se(t, e) {
            const n = Nt(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }
        function ae(t, e) {
            const n = Nt(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }
        function oe(t, e) {
            const n = Nt(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }
        function le(t, e) {
            const n = Nt(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }
        function ce(t, e) {
            const n = Nt(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }
        function ue(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function he(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function de(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function fe(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function pe(t, e) {
            t.uniform1uiv(this.addr, e)
        }
        function me(t, e) {
            t.uniform2uiv(this.addr, e)
        }
        function ge(t, e) {
            t.uniform3uiv(this.addr, e)
        }
        function ve(t, e) {
            t.uniform4uiv(this.addr, e)
        }
        function _e(t, e, n) {
            const r = e.length
              , i = Ut(n, r);
            t.uniform1iv(this.addr, i);
            for (let t = 0; t !== r; ++t)
                n.safeSetTexture2D(e[t] || St, i[t])
        }
        function ye(t, e, n) {
            const r = e.length
              , i = Ut(n, r);
            t.uniform1iv(this.addr, i);
            for (let t = 0; t !== r; ++t)
                n.safeSetTextureCube(e[t] || Rt, i[t])
        }
        function xe(t, e, n) {
            this.id = t,
            this.addr = n,
            this.cache = [],
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return zt;
                case 35664:
                    return Bt;
                case 35665:
                    return kt;
                case 35666:
                    return Gt;
                case 35674:
                    return Ht;
                case 35675:
                    return Vt;
                case 35676:
                    return Wt;
                case 5124:
                case 35670:
                    return Xt;
                case 35667:
                case 35671:
                    return jt;
                case 35668:
                case 35672:
                    return Yt;
                case 35669:
                case 35673:
                    return qt;
                case 5125:
                    return Zt;
                case 36294:
                    return Kt;
                case 36295:
                    return Jt;
                case 36296:
                    return Qt;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return $t;
                case 35679:
                case 36299:
                case 36307:
                    return te;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return ee;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return ne
                }
            }(e.type)
        }
        function be(t, e, n) {
            this.id = t,
            this.addr = n,
            this.cache = [],
            this.size = e.size,
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return re;
                case 35664:
                    return ie;
                case 35665:
                    return se;
                case 35666:
                    return ae;
                case 35674:
                    return oe;
                case 35675:
                    return le;
                case 35676:
                    return ce;
                case 5124:
                case 35670:
                    return ue;
                case 35667:
                case 35671:
                    return he;
                case 35668:
                case 35672:
                    return de;
                case 35669:
                case 35673:
                    return fe;
                case 5125:
                    return pe;
                case 36294:
                    return me;
                case 36295:
                    return ge;
                case 36296:
                    return ve;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return _e;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return ye
                }
            }(e.type)
        }
        function we(t) {
            this.id = t,
            this.seq = [],
            this.map = {}
        }
        be.prototype.updateCache = function(t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
            Ot(e, t)
        }
        ,
        we.prototype.setValue = function(t, e, n) {
            const r = this.seq;
            for (let i = 0, s = r.length; i !== s; ++i) {
                const s = r[i];
                s.setValue(t, e[s.id], n)
            }
        }
        ;
        const Me = /(\w+)(\])?(\[|\.)?/g;
        function Te(t, e) {
            t.seq.push(e),
            t.map[e.id] = e
        }
        function Se(t, e, n) {
            const r = t.name
              , i = r.length;
            for (Me.lastIndex = 0; ; ) {
                const s = Me.exec(r)
                  , a = Me.lastIndex;
                let o = s[1];
                const l = "]" === s[2]
                  , c = s[3];
                if (l && (o |= 0),
                void 0 === c || "[" === c && a + 2 === i) {
                    Te(n, void 0 === c ? new xe(o,t,e) : new be(o,t,e));
                    break
                }
                {
                    let t = n.map[o];
                    void 0 === t && (t = new we(o),
                    Te(n, t)),
                    n = t
                }
            }
        }
        function Ee(t, e) {
            this.seq = [],
            this.map = {};
            const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (let r = 0; r < n; ++r) {
                const n = t.getActiveUniform(e, r);
                Se(n, t.getUniformLocation(e, n.name), this)
            }
        }
        function Ae(t, e, n) {
            const r = t.createShader(e);
            return t.shaderSource(r, n),
            t.compileShader(r),
            r
        }
        Ee.prototype.setValue = function(t, e, n, r) {
            const i = this.map[e];
            void 0 !== i && i.setValue(t, n, r)
        }
        ,
        Ee.prototype.setOptional = function(t, e, n) {
            const r = e[n];
            void 0 !== r && this.setValue(t, n, r)
        }
        ,
        Ee.upload = function(t, e, n, r) {
            for (let i = 0, s = e.length; i !== s; ++i) {
                const s = e[i]
                  , a = n[s.id];
                !1 !== a.needsUpdate && s.setValue(t, a.value, r)
            }
        }
        ,
        Ee.seqWithValue = function(t, e) {
            const n = [];
            for (let r = 0, i = t.length; r !== i; ++r) {
                const i = t[r];
                i.id in e && n.push(i)
            }
            return n
        }
        ;
        let Re = 0;
        function Le(t) {
            switch (t) {
            case r.rnI:
                return ["Linear", "( value )"];
            case r.knz:
                return ["sRGB", "( value )"];
            case r.KC9:
                return ["RGBE", "( value )"];
            case r.LgE:
                return ["RGBM", "( value, 7.0 )"];
            case r.Inb:
                return ["RGBM", "( value, 16.0 )"];
            case r.gMp:
                return ["RGBD", "( value, 256.0 )"];
            case r.pMV:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case r.M6c:
                return ["LogLuv", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
            }
        }
        function Pe(t, e, n) {
            const r = t.getShaderParameter(e, t.COMPILE_STATUS)
              , i = t.getShaderInfoLog(e).trim();
            return r && "" === i ? "" : n.toUpperCase() + "\n\n" + i + "\n\n" + function(t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++)
                    e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t.getShaderSource(e))
        }
        function Ce(t, e) {
            const n = Le(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }
        function De(t, e) {
            const n = Le(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }
        function Ie(t, e) {
            let n;
            switch (e) {
            case r.EoG:
                n = "Linear";
                break;
            case r.CdI:
                n = "Reinhard";
                break;
            case r.YGz:
                n = "OptimizedCineon";
                break;
            case r.LY2:
                n = "ACESFilmic";
                break;
            case r.dZ3:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function Ne(t) {
            return "" !== t
        }
        function Fe(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function Oe(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Ue = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function ze(t) {
            return t.replace(Ue, Be)
        }
        function Be(t, e) {
            const n = v[e];
            if (void 0 === n)
                throw new Error("Can not resolve #include <" + e + ">");
            return ze(n)
        }
        const ke = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
          , Ge = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function He(t) {
            return t.replace(Ge, We).replace(ke, Ve)
        }
        function Ve(t, e, n, r) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
            We(t, e, n, r)
        }
        function We(t, e, n, r) {
            let i = "";
            for (let t = parseInt(e); t < parseInt(n); t++)
                i += r.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return i
        }
        function Xe(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
        }
        function je(t, e, n, i) {
            const s = t.getContext()
              , a = n.defines;
            let o = n.vertexShader
              , l = n.fragmentShader;
            const c = function(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return t.shadowMapType === r._iA ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === r.ntZ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === r.dwk && (e = "SHADOWMAP_TYPE_VSM"),
                e
            }(n)
              , u = function(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case r.fY$:
                    case r.vxC:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case r.g8_:
                    case r.SVc:
                        e = "ENVMAP_TYPE_CUBE_UV"
                    }
                return e
            }(n)
              , h = function(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case r.vxC:
                    case r.SVc:
                        e = "ENVMAP_MODE_REFRACTION"
                    }
                return e
            }(n)
              , d = function(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap)
                    switch (t.combine) {
                    case r.Ns1:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case r.qhX:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case r.NDo:
                        e = "ENVMAP_BLENDING_ADD"
                    }
                return e
            }(n)
              , f = t.gammaFactor > 0 ? t.gammaFactor : 1
              , p = n.isWebGL2 ? "" : function(t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ne).join("\n")
            }(n)
              , m = function(t) {
                const e = [];
                for (const n in t) {
                    const r = t[n];
                    !1 !== r && e.push("#define " + n + " " + r)
                }
                return e.join("\n")
            }(a)
              , g = s.createProgram();
            let _, y, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (_ = [m].filter(Ne).join("\n"),
            _.length > 0 && (_ += "\n"),
            y = [p, m].filter(Ne).join("\n"),
            y.length > 0 && (y += "\n")) : (_ = [Xe(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ne).join("\n"),
            y = [p, Xe(n), "#define SHADER_NAME " + n.shaderName, m, "#define GAMMA_FACTOR " + f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheenTint ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== r.uL9 ? "#define TONE_MAPPING" : "", n.toneMapping !== r.uL9 ? v.tonemapping_pars_fragment : "", n.toneMapping !== r.uL9 ? Ie("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === r.UCm ? "#define OPAQUE" : "", v.encodings_pars_fragment, n.map ? Ce("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Ce("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Ce("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Ce("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? Ce("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? Ce("lightMapTexelToLinear", n.lightMapEncoding) : "", De("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ne).join("\n")),
            o = ze(o),
            o = Fe(o, n),
            o = Oe(o, n),
            l = ze(l),
            l = Fe(l, n),
            l = Oe(l, n),
            o = He(o),
            l = He(l),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (x = "#version 300 es\n",
            _ = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + _,
            y = ["#define varying in", n.glslVersion === r.LSk ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === r.LSk ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
            const b = x + _ + o
              , w = x + y + l
              , M = Ae(s, s.VERTEX_SHADER, b)
              , T = Ae(s, s.FRAGMENT_SHADER, w);
            if (s.attachShader(g, M),
            s.attachShader(g, T),
            void 0 !== n.index0AttributeName ? s.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && s.bindAttribLocation(g, 0, "position"),
            s.linkProgram(g),
            t.debug.checkShaderErrors) {
                const t = s.getProgramInfoLog(g).trim()
                  , e = s.getShaderInfoLog(M).trim()
                  , n = s.getShaderInfoLog(T).trim();
                let r = !0
                  , i = !0;
                if (!1 === s.getProgramParameter(g, s.LINK_STATUS)) {
                    r = !1;
                    const e = Pe(s, M, "vertex")
                      , n = Pe(s, T, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                } else
                    "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (i = !1);
                i && (this.diagnostics = {
                    runnable: r,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: _
                    },
                    fragmentShader: {
                        log: n,
                        prefix: y
                    }
                })
            }
            let S, E;
            return s.deleteShader(M),
            s.deleteShader(T),
            this.getUniforms = function() {
                return void 0 === S && (S = new Ee(s,g)),
                S
            }
            ,
            this.getAttributes = function() {
                return void 0 === E && (E = function(t, e) {
                    const n = {}
                      , r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let i = 0; i < r; i++) {
                        const r = t.getActiveAttrib(e, i)
                          , s = r.name;
                        let a = 1;
                        r.type === t.FLOAT_MAT2 && (a = 2),
                        r.type === t.FLOAT_MAT3 && (a = 3),
                        r.type === t.FLOAT_MAT4 && (a = 4),
                        n[s] = {
                            type: r.type,
                            location: t.getAttribLocation(e, s),
                            locationSize: a
                        }
                    }
                    return n
                }(s, g)),
                E
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                s.deleteProgram(g),
                this.program = void 0
            }
            ,
            this.name = n.shaderName,
            this.id = Re++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = g,
            this.vertexShader = M,
            this.fragmentShader = T,
            this
        }
        function Ye(t, e, n, i, s, a, o) {
            const l = []
              , c = s.isWebGL2
              , u = s.logarithmicDepthBuffer
              , h = s.floatVertexTextures
              , d = s.maxVertexUniforms
              , f = s.vertexTextures;
            let p = s.precision;
            const m = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            }
              , g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheenTint", "transmission", "transmissionMap", "thicknessMap"];
            function v(t) {
                let e;
                return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                e = t.texture.encoding) : e = r.rnI,
                e
            }
            return {
                getParameters: function(a, l, g, _, y) {
                    const x = _.fog
                      , b = a.isMeshStandardMaterial ? _.environment : null
                      , M = (a.isMeshStandardMaterial ? n : e).get(a.envMap || b)
                      , T = m[a.type]
                      , S = y.isSkinnedMesh ? function(t) {
                        const e = t.skeleton.bones;
                        if (h)
                            return 1024;
                        {
                            const t = d
                              , n = Math.floor((t - 20) / 4)
                              , r = Math.min(n, e.length);
                            return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."),
                            0) : r
                        }
                    }(y) : 0;
                    let E, A;
                    if (null !== a.precision && (p = s.getMaxPrecision(a.precision),
                    p !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", p, "instead.")),
                    T) {
                        const t = w[T];
                        E = t.vertexShader,
                        A = t.fragmentShader
                    } else
                        E = a.vertexShader,
                        A = a.fragmentShader;
                    const R = t.getRenderTarget()
                      , L = a.alphaTest > 0
                      , P = a.clearcoat > 0;
                    return {
                        isWebGL2: c,
                        shaderID: T,
                        shaderName: a.type,
                        vertexShader: E,
                        fragmentShader: A,
                        defines: a.defines,
                        isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                        glslVersion: a.glslVersion,
                        precision: p,
                        instancing: !0 === y.isInstancedMesh,
                        instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                        supportsVertexTextures: f,
                        outputEncoding: null !== R ? v(R.texture) : t.outputEncoding,
                        map: !!a.map,
                        mapEncoding: v(a.map),
                        matcap: !!a.matcap,
                        matcapEncoding: v(a.matcap),
                        envMap: !!M,
                        envMapMode: M && M.mapping,
                        envMapEncoding: v(M),
                        envMapCubeUV: !!M && (M.mapping === r.g8_ || M.mapping === r.SVc),
                        lightMap: !!a.lightMap,
                        lightMapEncoding: v(a.lightMap),
                        aoMap: !!a.aoMap,
                        emissiveMap: !!a.emissiveMap,
                        emissiveMapEncoding: v(a.emissiveMap),
                        bumpMap: !!a.bumpMap,
                        normalMap: !!a.normalMap,
                        objectSpaceNormalMap: a.normalMapType === r.PA7,
                        tangentSpaceNormalMap: a.normalMapType === r.IOt,
                        clearcoat: P,
                        clearcoatMap: P && !!a.clearcoatMap,
                        clearcoatRoughnessMap: P && !!a.clearcoatRoughnessMap,
                        clearcoatNormalMap: P && !!a.clearcoatNormalMap,
                        displacementMap: !!a.displacementMap,
                        roughnessMap: !!a.roughnessMap,
                        metalnessMap: !!a.metalnessMap,
                        specularMap: !!a.specularMap,
                        specularIntensityMap: !!a.specularIntensityMap,
                        specularTintMap: !!a.specularTintMap,
                        specularTintMapEncoding: v(a.specularTintMap),
                        alphaMap: !!a.alphaMap,
                        alphaTest: L,
                        gradientMap: !!a.gradientMap,
                        sheenTint: !!a.sheenTint && (a.sheenTint.r > 0 || a.sheenTint.g > 0 || a.sheenTint.b > 0),
                        transmission: a.transmission > 0,
                        transmissionMap: !!a.transmissionMap,
                        thicknessMap: !!a.thicknessMap,
                        combine: a.combine,
                        vertexTangents: !!a.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
                        vertexColors: a.vertexColors,
                        vertexAlphas: !0 === a.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
                        vertexUvs: !!(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatMap || a.clearcoatRoughnessMap || a.clearcoatNormalMap || a.displacementMap || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularTintMap),
                        uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularTintMap || !a.displacementMap),
                        fog: !!x,
                        useFog: a.fog,
                        fogExp2: x && x.isFogExp2,
                        flatShading: !!a.flatShading,
                        sizeAttenuation: a.sizeAttenuation,
                        logarithmicDepthBuffer: u,
                        skinning: !0 === y.isSkinnedMesh && S > 0,
                        maxBones: S,
                        useVertexTexture: h,
                        morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
                        morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
                        numDirLights: l.directional.length,
                        numPointLights: l.point.length,
                        numSpotLights: l.spot.length,
                        numRectAreaLights: l.rectArea.length,
                        numHemiLights: l.hemi.length,
                        numDirLightShadows: l.directionalShadowMap.length,
                        numPointLightShadows: l.pointShadowMap.length,
                        numSpotLightShadows: l.spotShadowMap.length,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        format: a.format,
                        dithering: a.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && g.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: a.toneMapped ? t.toneMapping : r.uL9,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: a.premultipliedAlpha,
                        doubleSided: a.side === r.ehD,
                        flipSided: a.side === r._Li,
                        depthPacking: void 0 !== a.depthPacking && a.depthPacking,
                        index0AttributeName: a.index0AttributeName,
                        extensionDerivatives: a.extensions && a.extensions.derivatives,
                        extensionFragDepth: a.extensions && a.extensions.fragDepth,
                        extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                        extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: c || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: c || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: c || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: a.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader),
                    n.push(e.vertexShader)),
                    void 0 !== e.defines)
                        for (const t in e.defines)
                            n.push(t),
                            n.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let t = 0; t < g.length; t++)
                            n.push(e[g[t]]);
                        n.push(t.outputEncoding),
                        n.push(t.gammaFactor)
                    }
                    return n.push(e.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(t) {
                    const e = m[t.type];
                    let n;
                    if (e) {
                        const t = w[e];
                        n = _.rD.clone(t.uniforms)
                    } else
                        n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let r;
                    for (let t = 0, e = l.length; t < e; t++) {
                        const e = l[t];
                        if (e.cacheKey === n) {
                            r = e,
                            ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new je(t,n,e,a),
                    l.push(r)),
                    r
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = l.indexOf(t);
                        l[e] = l[l.length - 1],
                        l.pop(),
                        t.destroy()
                    }
                },
                programs: l
            }
        }
        function qe() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {},
                    t.set(e, n)),
                    n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, r) {
                    t.get(e)[n] = r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function Ze(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function Ke(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function Je(t) {
            const e = [];
            let n = 0;
            const r = []
              , i = []
              , s = []
              , a = {
                id: -1
            };
            function o(r, i, s, o, l, c) {
                let u = e[n];
                const h = t.get(s);
                return void 0 === u ? (u = {
                    id: r.id,
                    object: r,
                    geometry: i,
                    material: s,
                    program: h.program || a,
                    groupOrder: o,
                    renderOrder: r.renderOrder,
                    z: l,
                    group: c
                },
                e[n] = u) : (u.id = r.id,
                u.object = r,
                u.geometry = i,
                u.material = s,
                u.program = h.program || a,
                u.groupOrder = o,
                u.renderOrder = r.renderOrder,
                u.z = l,
                u.group = c),
                n++,
                u
            }
            return {
                opaque: r,
                transmissive: i,
                transparent: s,
                init: function() {
                    n = 0,
                    r.length = 0,
                    i.length = 0,
                    s.length = 0
                },
                push: function(t, e, n, a, l, c) {
                    const u = o(t, e, n, a, l, c);
                    n.transmission > 0 ? i.push(u) : !0 === n.transparent ? s.push(u) : r.push(u)
                },
                unshift: function(t, e, n, a, l, c) {
                    const u = o(t, e, n, a, l, c);
                    n.transmission > 0 ? i.unshift(u) : !0 === n.transparent ? s.unshift(u) : r.unshift(u)
                },
                finish: function() {
                    for (let t = n, r = e.length; t < r; t++) {
                        const n = e[t];
                        if (null === n.id)
                            break;
                        n.id = null,
                        n.object = null,
                        n.geometry = null,
                        n.material = null,
                        n.program = null,
                        n.group = null
                    }
                },
                sort: function(t, e) {
                    r.length > 1 && r.sort(t || Ze),
                    i.length > 1 && i.sort(e || Ke),
                    s.length > 1 && s.sort(e || Ke)
                }
            }
        }
        function Qe(t) {
            let e = new WeakMap;
            return {
                get: function(n, r) {
                    let i;
                    return !1 === e.has(n) ? (i = new Je(t),
                    e.set(n, [i])) : r >= e.get(n).length ? (i = new Je(t),
                    e.get(n).push(i)) : i = e.get(n)[r],
                    i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function $e() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new a.P,
                            color: new m.I
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new a.P,
                            direction: new a.P,
                            color: new m.I,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new a.P,
                            color: new m.I,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new a.P,
                            skyColor: new m.I,
                            groundColor: new m.I
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new m.I,
                            position: new a.P,
                            halfWidth: new a.P,
                            halfHeight: new a.P
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        let tn = 0;
        function en(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }
        function nn(t, e) {
            const n = new $e
              , r = function() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id])
                            return t[e.id];
                        let n;
                        switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new y.F
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new y.F,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return t[e.id] = n,
                        n
                    }
                }
            }()
              , i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            for (let t = 0; t < 9; t++)
                i.probe.push(new a.P);
            const o = new a.P
              , l = new s.y
              , c = new s.y;
            return {
                setup: function(s, a) {
                    let o = 0
                      , l = 0
                      , c = 0;
                    for (let t = 0; t < 9; t++)
                        i.probe[t].set(0, 0, 0);
                    let u = 0
                      , h = 0
                      , d = 0
                      , f = 0
                      , p = 0
                      , m = 0
                      , g = 0
                      , v = 0;
                    s.sort(en);
                    const _ = !0 !== a ? Math.PI : 1;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t]
                          , a = e.color
                          , y = e.intensity
                          , x = e.distance
                          , b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight)
                            o += a.r * y * _,
                            l += a.g * y * _,
                            c += a.b * y * _;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++)
                                i.probe[t].addScaledVector(e.sh.coefficients[t], y);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * _),
                            e.castShadow) {
                                const t = e.shadow
                                  , n = r.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                i.directionalShadow[u] = n,
                                i.directionalShadowMap[u] = b,
                                i.directionalShadowMatrix[u] = e.shadow.matrix,
                                m++
                            }
                            i.directional[u] = t,
                            u++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld),
                            t.color.copy(a).multiplyScalar(y * _),
                            t.distance = x,
                            t.coneCos = Math.cos(e.angle),
                            t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = r.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                i.spotShadow[d] = n,
                                i.spotShadowMap[d] = b,
                                i.spotShadowMatrix[d] = e.shadow.matrix,
                                v++
                            }
                            i.spot[d] = t,
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(a).multiplyScalar(y),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            i.rectArea[f] = t,
                            f++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * _),
                            t.distance = e.distance,
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = r.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                n.shadowCameraNear = t.camera.near,
                                n.shadowCameraFar = t.camera.far,
                                i.pointShadow[h] = n,
                                i.pointShadowMap[h] = b,
                                i.pointShadowMatrix[h] = e.shadow.matrix,
                                g++
                            }
                            i.point[h] = t,
                            h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(y * _),
                            t.groundColor.copy(e.groundColor).multiplyScalar(y * _),
                            i.hemi[p] = t,
                            p++
                        }
                    }
                    f > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = b.LTC_FLOAT_1,
                    i.rectAreaLTC2 = b.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = b.LTC_HALF_1,
                    i.rectAreaLTC2 = b.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    i.ambient[0] = o,
                    i.ambient[1] = l,
                    i.ambient[2] = c;
                    const y = i.hash;
                    y.directionalLength === u && y.pointLength === h && y.spotLength === d && y.rectAreaLength === f && y.hemiLength === p && y.numDirectionalShadows === m && y.numPointShadows === g && y.numSpotShadows === v || (i.directional.length = u,
                    i.spot.length = d,
                    i.rectArea.length = f,
                    i.point.length = h,
                    i.hemi.length = p,
                    i.directionalShadow.length = m,
                    i.directionalShadowMap.length = m,
                    i.pointShadow.length = g,
                    i.pointShadowMap.length = g,
                    i.spotShadow.length = v,
                    i.spotShadowMap.length = v,
                    i.directionalShadowMatrix.length = m,
                    i.pointShadowMatrix.length = g,
                    i.spotShadowMatrix.length = v,
                    y.directionalLength = u,
                    y.pointLength = h,
                    y.spotLength = d,
                    y.rectAreaLength = f,
                    y.hemiLength = p,
                    y.numDirectionalShadows = m,
                    y.numPointShadows = g,
                    y.numSpotShadows = v,
                    i.version = tn++)
                },
                setupView: function(t, e) {
                    let n = 0
                      , r = 0
                      , s = 0
                      , a = 0
                      , u = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = i.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            o.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(o),
                            t.direction.transformDirection(h),
                            n++
                        } else if (d.isSpotLight) {
                            const t = i.spot[s];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            o.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(o),
                            t.direction.transformDirection(h),
                            s++
                        } else if (d.isRectAreaLight) {
                            const t = i.rectArea[a];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            c.identity(),
                            l.copy(d.matrixWorld),
                            l.premultiply(h),
                            c.extractRotation(l),
                            t.halfWidth.set(.5 * d.width, 0, 0),
                            t.halfHeight.set(0, .5 * d.height, 0),
                            t.halfWidth.applyMatrix4(c),
                            t.halfHeight.applyMatrix4(c),
                            a++
                        } else if (d.isPointLight) {
                            const t = i.point[r];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            r++
                        } else if (d.isHemisphereLight) {
                            const t = i.hemi[u];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            t.direction.transformDirection(h),
                            t.direction.normalize(),
                            u++
                        }
                    }
                },
                state: i
            }
        }
        function rn(t, e) {
            const n = new nn(t,e)
              , r = []
              , i = [];
            return {
                init: function() {
                    r.length = 0,
                    i.length = 0
                },
                state: {
                    lightsArray: r,
                    shadowsArray: i,
                    lights: n
                },
                setupLights: function(t) {
                    n.setup(r, t)
                },
                setupLightsView: function(t) {
                    n.setupView(r, t)
                },
                pushLight: function(t) {
                    r.push(t)
                },
                pushShadow: function(t) {
                    i.push(t)
                }
            }
        }
        function sn(t, e) {
            let n = new WeakMap;
            return {
                get: function(r, i=0) {
                    let s;
                    return !1 === n.has(r) ? (s = new rn(t,e),
                    n.set(r, [s])) : i >= n.get(r).length ? (s = new rn(t,e),
                    n.get(r).push(s)) : s = n.get(r)[i],
                    s
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        var an = n(2114)
          , on = n(4164);
        class ln extends on.F {
            constructor(t) {
                super(),
                this.type = "MeshDistanceMaterial",
                this.referencePosition = new a.P,
                this.nearDistance = 1,
                this.farDistance = 1e3,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.referencePosition.copy(t.referencePosition),
                this.nearDistance = t.nearDistance,
                this.farDistance = t.farDistance,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this
            }
        }
        ln.prototype.isMeshDistanceMaterial = !0;
        var cn = "\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n\n#include <packing>\n\nvoid main() {\n\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\t// float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\n\t\t#ifdef HORIZONTAL_PASS\n\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n\t\t#else\n\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\n\t\t#endif\n\n\t}\n\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n"
          , un = "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n";
        function hn(t, e, n) {
            let s = new i.i;
            const a = new y.F
              , l = new y.F
              , c = new o.L
              , d = new an.l({
                depthPacking: r.mSO
            })
              , f = new ln
              , m = {}
              , v = n.maxTextureSize
              , _ = {
                0: r._Li,
                1: r.Wl3,
                2: r.ehD
            }
              , x = new p.j({
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new y.F
                    },
                    radius: {
                        value: 4
                    },
                    samples: {
                        value: 8
                    }
                },
                vertexShader: un,
                fragmentShader: cn
            })
              , b = x.clone();
            b.defines.HORIZONTAL_PASS = 1;
            const w = new u.u;
            w.setAttribute("position", new h.Tl(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const M = new g.K(w,x)
              , T = this;
            function S(n, r) {
                const i = e.update(M);
                x.uniforms.shadow_pass.value = n.map.texture,
                x.uniforms.resolution.value = n.mapSize,
                x.uniforms.radius.value = n.radius,
                x.uniforms.samples.value = n.blurSamples,
                t.setRenderTarget(n.mapPass),
                t.clear(),
                t.renderBufferDirect(r, null, i, x, M, null),
                b.uniforms.shadow_pass.value = n.mapPass.texture,
                b.uniforms.resolution.value = n.mapSize,
                b.uniforms.radius.value = n.radius,
                b.uniforms.samples.value = n.blurSamples,
                t.setRenderTarget(n.map),
                t.clear(),
                t.renderBufferDirect(r, null, i, b, M, null)
            }
            function E(e, n, i, s, a, o, l) {
                let c = null;
                const u = !0 === s.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (c = void 0 !== u ? u : !0 === s.isPointLight ? f : d,
                t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                    const t = c.uuid
                      , e = i.uuid;
                    let n = m[t];
                    void 0 === n && (n = {},
                    m[t] = n);
                    let r = n[e];
                    void 0 === r && (r = c.clone(),
                    n[e] = r),
                    c = r
                }
                return c.visible = i.visible,
                c.wireframe = i.wireframe,
                l === r.dwk ? c.side = null !== i.shadowSide ? i.shadowSide : i.side : c.side = null !== i.shadowSide ? i.shadowSide : _[i.side],
                c.alphaMap = i.alphaMap,
                c.alphaTest = i.alphaTest,
                c.clipShadows = i.clipShadows,
                c.clippingPlanes = i.clippingPlanes,
                c.clipIntersection = i.clipIntersection,
                c.displacementMap = i.displacementMap,
                c.displacementScale = i.displacementScale,
                c.displacementBias = i.displacementBias,
                c.wireframeLinewidth = i.wireframeLinewidth,
                c.linewidth = i.linewidth,
                !0 === s.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(s.matrixWorld),
                c.nearDistance = a,
                c.farDistance = o),
                c
            }
            function A(n, i, a, o, l) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && l === r.dwk) && (!n.frustumCulled || s.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                    const r = e.update(n)
                      , i = n.material;
                    if (Array.isArray(i)) {
                        const e = r.groups;
                        for (let s = 0, c = e.length; s < c; s++) {
                            const c = e[s]
                              , u = i[c.materialIndex];
                            if (u && u.visible) {
                                const e = E(n, 0, u, o, a.near, a.far, l);
                                t.renderBufferDirect(a, null, r, e, n, c)
                            }
                        }
                    } else if (i.visible) {
                        const e = E(n, 0, i, o, a.near, a.far, l);
                        t.renderBufferDirect(a, null, r, e, n, null)
                    }
                }
                const c = n.children;
                for (let t = 0, e = c.length; t < e; t++)
                    A(c[t], i, a, o, l)
            }
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = r._iA,
            this.render = function(e, n, i) {
                if (!1 === T.enabled)
                    return;
                if (!1 === T.autoUpdate && !1 === T.needsUpdate)
                    return;
                if (0 === e.length)
                    return;
                const o = t.getRenderTarget()
                  , u = t.getActiveCubeFace()
                  , h = t.getActiveMipmapLevel()
                  , d = t.state;
                d.setBlending(r.jFi),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                for (let o = 0, u = e.length; o < u; o++) {
                    const u = e[o]
                      , h = u.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                        continue;
                    a.copy(h.mapSize);
                    const f = h.getFrameExtents();
                    if (a.multiply(f),
                    l.copy(h.mapSize),
                    (a.x > v || a.y > v) && (a.x > v && (l.x = Math.floor(v / f.x),
                    a.x = l.x * f.x,
                    h.mapSize.x = l.x),
                    a.y > v && (l.y = Math.floor(v / f.y),
                    a.y = l.y * f.y,
                    h.mapSize.y = l.y)),
                    null === h.map && !h.isPointLightShadow && this.type === r.dwk) {
                        const t = {
                            minFilter: r.wem,
                            magFilter: r.wem,
                            format: r.wk1
                        };
                        h.map = new L.d(a.x,a.y,t),
                        h.map.texture.name = u.name + ".shadowMap",
                        h.mapPass = new L.d(a.x,a.y,t),
                        h.camera.updateProjectionMatrix()
                    }
                    if (null === h.map) {
                        const t = {
                            minFilter: r.TyD,
                            magFilter: r.TyD,
                            format: r.wk1
                        };
                        h.map = new L.d(a.x,a.y,t),
                        h.map.texture.name = u.name + ".shadowMap",
                        h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map),
                    t.clear();
                    const p = h.getViewportCount();
                    for (let t = 0; t < p; t++) {
                        const e = h.getViewport(t);
                        c.set(l.x * e.x, l.y * e.y, l.x * e.z, l.y * e.w),
                        d.viewport(c),
                        h.updateMatrices(u, t),
                        s = h.getFrustum(),
                        A(n, i, h.camera, u, this.type)
                    }
                    h.isPointLightShadow || this.type !== r.dwk || S(h, i),
                    h.needsUpdate = !1
                }
                T.needsUpdate = !1,
                t.setRenderTarget(o, u, h)
            }
        }
        function dn(t, e, n) {
            const i = n.isWebGL2;
            const s = new function() {
                let e = !1;
                const n = new o.L;
                let r = null;
                const i = new o.L(0,0,0,0);
                return {
                    setMask: function(n) {
                        r === n || e || (t.colorMask(n, n, n, n),
                        r = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, r, s, a, o) {
                        !0 === o && (e *= a,
                        r *= a,
                        s *= a),
                        n.set(e, r, s, a),
                        !1 === i.equals(n) && (t.clearColor(e, r, s, a),
                        i.copy(n))
                    },
                    reset: function() {
                        e = !1,
                        r = null,
                        i.set(-1, 0, 0, 0)
                    }
                }
            }
              , a = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , s = null;
                return {
                    setTest: function(e) {
                        e ? B(t.DEPTH_TEST) : k(t.DEPTH_TEST)
                    },
                    setMask: function(r) {
                        n === r || e || (t.depthMask(r),
                        n = r)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            if (e)
                                switch (e) {
                                case r.BVF:
                                    t.depthFunc(t.NEVER);
                                    break;
                                case r.Se2:
                                    t.depthFunc(t.ALWAYS);
                                    break;
                                case r.Zr5:
                                    t.depthFunc(t.LESS);
                                    break;
                                case r.vCF:
                                    t.depthFunc(t.LEQUAL);
                                    break;
                                case r.eD:
                                    t.depthFunc(t.EQUAL);
                                    break;
                                case r.ksN:
                                    t.depthFunc(t.GEQUAL);
                                    break;
                                case r.w$m:
                                    t.depthFunc(t.GREATER);
                                    break;
                                case r.M6v:
                                    t.depthFunc(t.NOTEQUAL);
                                    break;
                                default:
                                    t.depthFunc(t.LEQUAL)
                                }
                            else
                                t.depthFunc(t.LEQUAL);
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        s !== e && (t.clearDepth(e),
                        s = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        s = null
                    }
                }
            }
              , l = new function() {
                let e = !1
                  , n = null
                  , r = null
                  , i = null
                  , s = null
                  , a = null
                  , o = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(n) {
                        e || (n ? B(t.STENCIL_TEST) : k(t.STENCIL_TEST))
                    },
                    setMask: function(r) {
                        n === r || e || (t.stencilMask(r),
                        n = r)
                    },
                    setFunc: function(e, n, a) {
                        r === e && i === n && s === a || (t.stencilFunc(e, n, a),
                        r = e,
                        i = n,
                        s = a)
                    },
                    setOp: function(e, n, r) {
                        a === e && o === n && l === r || (t.stencilOp(e, n, r),
                        a = e,
                        o = n,
                        l = r)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        c !== e && (t.clearStencil(e),
                        c = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        r = null,
                        i = null,
                        s = null,
                        a = null,
                        o = null,
                        l = null,
                        c = null
                    }
                }
            }
            ;
            let c = {}
              , u = null
              , h = {}
              , d = null
              , f = !1
              , p = null
              , m = null
              , g = null
              , v = null
              , _ = null
              , y = null
              , x = null
              , b = !1
              , w = null
              , M = null
              , T = null
              , S = null
              , E = null;
            const A = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let R = !1
              , L = 0;
            const P = t.getParameter(t.VERSION);
            -1 !== P.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(P)[1]),
            R = L >= 1) : -1 !== P.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),
            R = L >= 2);
            let C = null
              , D = {};
            const I = t.getParameter(t.SCISSOR_BOX)
              , N = t.getParameter(t.VIEWPORT)
              , F = (new o.L).fromArray(I)
              , O = (new o.L).fromArray(N);
            function U(e, n, r) {
                const i = new Uint8Array(4)
                  , s = t.createTexture();
                t.bindTexture(e, s),
                t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (let e = 0; e < r; e++)
                    t.texImage2D(n + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, i);
                return s
            }
            const z = {};
            function B(e) {
                !0 !== c[e] && (t.enable(e),
                c[e] = !0)
            }
            function k(e) {
                !1 !== c[e] && (t.disable(e),
                c[e] = !1)
            }
            z[t.TEXTURE_2D] = U(t.TEXTURE_2D, t.TEXTURE_2D, 1),
            z[t.TEXTURE_CUBE_MAP] = U(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            s.setClear(0, 0, 0, 1),
            a.setClear(1),
            l.setClear(0),
            B(t.DEPTH_TEST),
            a.setFunc(r.vCF),
            W(!1),
            X(r.tm_),
            B(t.CULL_FACE),
            V(r.jFi);
            const G = {
                [r.bGH]: t.FUNC_ADD,
                [r.Wbm]: t.FUNC_SUBTRACT,
                [r.rOj]: t.FUNC_REVERSE_SUBTRACT
            };
            if (i)
                G[r.r_] = t.MIN,
                G[r.Sm8] = t.MAX;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (G[r.r_] = t.MIN_EXT,
                G[r.Sm8] = t.MAX_EXT)
            }
            const H = {
                [r.c8b]: t.ZERO,
                [r.ghN]: t.ONE,
                [r.KhW]: t.SRC_COLOR,
                [r.k74]: t.SRC_ALPHA,
                [r.RlZ]: t.SRC_ALPHA_SATURATE,
                [r.Vdb]: t.DST_COLOR,
                [r.fSK]: t.DST_ALPHA,
                [r.iWC]: t.ONE_MINUS_SRC_COLOR,
                [r.LgZ]: t.ONE_MINUS_SRC_ALPHA,
                [r.Wpd]: t.ONE_MINUS_DST_COLOR,
                [r.Hy8]: t.ONE_MINUS_DST_ALPHA
            };
            function V(e, n, i, s, a, o, l, c) {
                if (e !== r.jFi) {
                    if (!1 === f && (B(t.BLEND),
                    f = !0),
                    e === r.Xaj)
                        a = a || n,
                        o = o || i,
                        l = l || s,
                        n === m && a === _ || (t.blendEquationSeparate(G[n], G[a]),
                        m = n,
                        _ = a),
                        i === g && s === v && o === y && l === x || (t.blendFuncSeparate(H[i], H[s], H[o], H[l]),
                        g = i,
                        v = s,
                        y = o,
                        x = l),
                        p = e,
                        b = null;
                    else if (e !== p || c !== b) {
                        if (m === r.bGH && _ === r.bGH || (t.blendEquation(t.FUNC_ADD),
                        m = r.bGH,
                        _ = r.bGH),
                        c)
                            switch (e) {
                            case r.bdR:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case r.WMw:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case r.N4l:
                                t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case r.M5h:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        else
                            switch (e) {
                            case r.bdR:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case r.WMw:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case r.N4l:
                                t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                                break;
                            case r.M5h:
                                t.blendFunc(t.ZERO, t.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        g = null,
                        v = null,
                        y = null,
                        x = null,
                        p = e,
                        b = c
                    }
                } else
                    !0 === f && (k(t.BLEND),
                    f = !1)
            }
            function W(e) {
                w !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                w = e)
            }
            function X(e) {
                e !== r.PeU ? (B(t.CULL_FACE),
                e !== M && (e === r.tm_ ? t.cullFace(t.BACK) : e === r.S2y ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : k(t.CULL_FACE),
                M = e
            }
            function j(e, n, r) {
                e ? (B(t.POLYGON_OFFSET_FILL),
                S === n && E === r || (t.polygonOffset(n, r),
                S = n,
                E = r)) : k(t.POLYGON_OFFSET_FILL)
            }
            function Y(e) {
                void 0 === e && (e = t.TEXTURE0 + A - 1),
                C !== e && (t.activeTexture(e),
                C = e)
            }
            return {
                buffers: {
                    color: s,
                    depth: a,
                    stencil: l
                },
                enable: B,
                disable: k,
                bindFramebuffer: function(e, n) {
                    return null === n && null !== u && (n = u),
                    h[e] !== n && (t.bindFramebuffer(e, n),
                    h[e] = n,
                    i && (e === t.DRAW_FRAMEBUFFER && (h[t.FRAMEBUFFER] = n),
                    e === t.FRAMEBUFFER && (h[t.DRAW_FRAMEBUFFER] = n)),
                    !0)
                },
                bindXRFramebuffer: function(e) {
                    e !== u && (t.bindFramebuffer(t.FRAMEBUFFER, e),
                    u = e)
                },
                useProgram: function(e) {
                    return d !== e && (t.useProgram(e),
                    d = e,
                    !0)
                },
                setBlending: V,
                setMaterial: function(e, n) {
                    e.side === r.ehD ? k(t.CULL_FACE) : B(t.CULL_FACE);
                    let i = e.side === r._Li;
                    n && (i = !i),
                    W(i),
                    e.blending === r.bdR && !1 === e.transparent ? V(r.jFi) : V(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                    a.setFunc(e.depthFunc),
                    a.setTest(e.depthTest),
                    a.setMask(e.depthWrite),
                    s.setMask(e.colorWrite);
                    const o = e.stencilWrite;
                    l.setTest(o),
                    o && (l.setMask(e.stencilWriteMask),
                    l.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                    l.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                    j(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                    !0 === e.alphaToCoverage ? B(t.SAMPLE_ALPHA_TO_COVERAGE) : k(t.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: W,
                setCullFace: X,
                setLineWidth: function(e) {
                    e !== T && (R && t.lineWidth(e),
                    T = e)
                },
                setPolygonOffset: j,
                setScissorTest: function(e) {
                    e ? B(t.SCISSOR_TEST) : k(t.SCISSOR_TEST)
                },
                activeTexture: Y,
                bindTexture: function(e, n) {
                    null === C && Y();
                    let r = D[C];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    },
                    D[C] = r),
                    r.type === e && r.texture === n || (t.bindTexture(e, n || z[e]),
                    r.type = e,
                    r.texture = n)
                },
                unbindTexture: function() {
                    const e = D[C];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                    e.type = void 0,
                    e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                    F.copy(e))
                },
                viewport: function(e) {
                    !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                    O.copy(e))
                },
                reset: function() {
                    t.disable(t.BLEND),
                    t.disable(t.CULL_FACE),
                    t.disable(t.DEPTH_TEST),
                    t.disable(t.POLYGON_OFFSET_FILL),
                    t.disable(t.SCISSOR_TEST),
                    t.disable(t.STENCIL_TEST),
                    t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                    t.blendEquation(t.FUNC_ADD),
                    t.blendFunc(t.ONE, t.ZERO),
                    t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                    t.colorMask(!0, !0, !0, !0),
                    t.clearColor(0, 0, 0, 0),
                    t.depthMask(!0),
                    t.depthFunc(t.LESS),
                    t.clearDepth(1),
                    t.stencilMask(4294967295),
                    t.stencilFunc(t.ALWAYS, 0, 4294967295),
                    t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                    t.clearStencil(0),
                    t.cullFace(t.BACK),
                    t.frontFace(t.CCW),
                    t.polygonOffset(0, 0),
                    t.activeTexture(t.TEXTURE0),
                    t.bindFramebuffer(t.FRAMEBUFFER, null),
                    !0 === i && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                    t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
                    t.useProgram(null),
                    t.lineWidth(1),
                    t.scissor(0, 0, t.canvas.width, t.canvas.height),
                    t.viewport(0, 0, t.canvas.width, t.canvas.height),
                    c = {},
                    C = null,
                    D = {},
                    u = null,
                    h = {},
                    d = null,
                    f = !1,
                    p = null,
                    m = null,
                    g = null,
                    v = null,
                    _ = null,
                    y = null,
                    x = null,
                    b = !1,
                    w = null,
                    M = null,
                    T = null,
                    S = null,
                    E = null,
                    F.set(0, 0, t.canvas.width, t.canvas.height),
                    O.set(0, 0, t.canvas.width, t.canvas.height),
                    s.reset(),
                    a.reset(),
                    l.reset()
                }
            }
        }
        var fn = n(2043);
        function pn(t, e, n, i, s, a, o) {
            const l = s.isWebGL2
              , c = s.maxTextures
              , u = s.maxCubemapSize
              , h = s.maxTextureSize
              , d = s.maxSamples
              , f = new WeakMap;
            let p, m = !1;
            try {
                m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (t) {}
            function g(t, e) {
                return m ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }
            function v(t, e, n, r) {
                let i = 1;
                if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)),
                i < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const r = e ? fn.gy : Math.floor
                          , s = r(i * t.width)
                          , a = r(i * t.height);
                        void 0 === p && (p = g(s, a));
                        const o = n ? g(s, a) : p;
                        o.width = s,
                        o.height = a;
                        return o.getContext("2d").drawImage(t, 0, 0, s, a),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."),
                        o
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                    t
                }
                return t
            }
            function _(t) {
                return fn.wt(t.width) && fn.wt(t.height)
            }
            function y(t, e) {
                return t.generateMipmaps && e && t.minFilter !== r.TyD && t.minFilter !== r.wem
            }
            function x(e, n, r, s, a=1) {
                t.generateMipmap(e);
                i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, a))
            }
            function b(n, r, i) {
                if (!1 === l)
                    return r;
                if (null !== n) {
                    if (void 0 !== t[n])
                        return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let s = r;
                return r === t.RED && (i === t.FLOAT && (s = t.R32F),
                i === t.HALF_FLOAT && (s = t.R16F),
                i === t.UNSIGNED_BYTE && (s = t.R8)),
                r === t.RGB && (i === t.FLOAT && (s = t.RGB32F),
                i === t.HALF_FLOAT && (s = t.RGB16F),
                i === t.UNSIGNED_BYTE && (s = t.RGB8)),
                r === t.RGBA && (i === t.FLOAT && (s = t.RGBA32F),
                i === t.HALF_FLOAT && (s = t.RGBA16F),
                i === t.UNSIGNED_BYTE && (s = t.RGBA8)),
                s !== t.R16F && s !== t.R32F && s !== t.RGBA16F && s !== t.RGBA32F || e.get("EXT_color_buffer_float"),
                s
            }
            function w(e) {
                return e === r.TyD || e === r.YLQ || e === r.aH4 ? t.NEAREST : t.LINEAR
            }
            function M(e) {
                const n = e.target;
                n.removeEventListener("dispose", M),
                function(e) {
                    const n = i.get(e);
                    if (void 0 === n.__webglInit)
                        return;
                    t.deleteTexture(n.__webglTexture),
                    i.remove(e)
                }(n),
                n.isVideoTexture && f.delete(n),
                o.memory.textures--
            }
            function T(e) {
                const n = e.target;
                n.removeEventListener("dispose", T),
                function(e) {
                    const n = e.texture
                      , r = i.get(e)
                      , s = i.get(n);
                    if (!e)
                        return;
                    void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture),
                    o.memory.textures--);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++)
                            t.deleteFramebuffer(r.__webglFramebuffer[e]),
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                    else
                        t.deleteFramebuffer(r.__webglFramebuffer),
                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                        r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                        r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                    if (e.isWebGLMultipleRenderTargets)
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            r.__webglTexture && (t.deleteTexture(r.__webglTexture),
                            o.memory.textures--),
                            i.remove(n[e])
                        }
                    i.remove(n),
                    i.remove(e)
                }(n)
            }
            let S = 0;
            function E(e, r) {
                const s = i.get(e);
                if (e.isVideoTexture && function(t) {
                    const e = o.render.frame;
                    f.get(t) !== e && (f.set(t, e),
                    t.update())
                }(e),
                e.version > 0 && s.__version !== e.version) {
                    const t = e.image;
                    if (void 0 === t)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== t.complete)
                            return void D(s, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(t.TEXTURE0 + r),
                n.bindTexture(t.TEXTURE_2D, s.__webglTexture)
            }
            function A(e, s) {
                const o = i.get(e);
                e.version > 0 && o.__version !== e.version ? function(e, i, s) {
                    if (6 !== i.image.length)
                        return;
                    C(e, i),
                    n.activeTexture(t.TEXTURE0 + s),
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture),
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
                    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                    t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment),
                    t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                    const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture)
                      , c = i.image[0] && i.image[0].isDataTexture
                      , h = [];
                    for (let t = 0; t < 6; t++)
                        h[t] = o || c ? c ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, u);
                    const d = h[0]
                      , f = _(d) || l
                      , p = a.convert(i.format)
                      , m = a.convert(i.type)
                      , g = b(i.internalFormat, p, m);
                    let w;
                    if (P(t.TEXTURE_CUBE_MAP, i, f),
                    o) {
                        for (let e = 0; e < 6; e++) {
                            w = h[e].mipmaps;
                            for (let s = 0; s < w.length; s++) {
                                const a = w[s];
                                i.format !== r.wk1 && i.format !== r.UCm ? null !== p ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, s, g, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, s, g, a.width, a.height, 0, p, m, a.data)
                            }
                        }
                        e.__maxMipLevel = w.length - 1
                    } else {
                        w = i.mipmaps;
                        for (let e = 0; e < 6; e++)
                            if (c) {
                                n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, g, h[e].width, h[e].height, 0, p, m, h[e].data);
                                for (let r = 0; r < w.length; r++) {
                                    const i = w[r].image[e].image;
                                    n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, g, i.width, i.height, 0, p, m, i.data)
                                }
                            } else {
                                n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, g, p, m, h[e]);
                                for (let r = 0; r < w.length; r++) {
                                    const i = w[r];
                                    n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, g, p, m, i.image[e])
                                }
                            }
                        e.__maxMipLevel = w.length
                    }
                    y(i, f) && x(t.TEXTURE_CUBE_MAP, i, d.width, d.height);
                    e.__version = i.version,
                    i.onUpdate && i.onUpdate(i)
                }(o, e, s) : (n.activeTexture(t.TEXTURE0 + s),
                n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture))
            }
            const R = {
                [r.rpg]: t.REPEAT,
                [r.uWy]: t.CLAMP_TO_EDGE,
                [r.OoA]: t.MIRRORED_REPEAT
            }
              , L = {
                [r.TyD]: t.NEAREST,
                [r.YLQ]: t.NEAREST_MIPMAP_NEAREST,
                [r.aH4]: t.NEAREST_MIPMAP_LINEAR,
                [r.wem]: t.LINEAR,
                [r.qyh]: t.LINEAR_MIPMAP_NEAREST,
                [r.D1R]: t.LINEAR_MIPMAP_LINEAR
            };
            function P(n, a, o) {
                if (o ? (t.texParameteri(n, t.TEXTURE_WRAP_S, R[a.wrapS]),
                t.texParameteri(n, t.TEXTURE_WRAP_T, R[a.wrapT]),
                n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, R[a.wrapR]),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, L[a.magFilter]),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, L[a.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
                a.wrapS === r.uWy && a.wrapT === r.uWy || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, w(a.magFilter)),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, w(a.minFilter)),
                a.minFilter !== r.TyD && a.minFilter !== r.wem && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const o = e.get("EXT_texture_filter_anisotropic");
                    if (a.type === r.VzW && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (!1 === l && a.type === r.cLu && !1 === e.has("OES_texture_half_float_linear"))
                        return;
                    (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, s.getMaxAnisotropy())),
                    i.get(a).__currentAnisotropy = a.anisotropy)
                }
            }
            function C(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0,
                n.addEventListener("dispose", M),
                e.__webglTexture = t.createTexture(),
                o.memory.textures++)
            }
            function D(e, i, s) {
                let o = t.TEXTURE_2D;
                i.isDataTexture2DArray && (o = t.TEXTURE_2D_ARRAY),
                i.isDataTexture3D && (o = t.TEXTURE_3D),
                C(e, i),
                n.activeTexture(t.TEXTURE0 + s),
                n.bindTexture(o, e.__webglTexture),
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
                t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment),
                t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                const c = function(t) {
                    return !l && (t.wrapS !== r.uWy || t.wrapT !== r.uWy || t.minFilter !== r.TyD && t.minFilter !== r.wem)
                }(i) && !1 === _(i.image)
                  , u = v(i.image, c, !1, h)
                  , d = _(u) || l
                  , f = a.convert(i.format);
                let p, m = a.convert(i.type), g = b(i.internalFormat, f, m);
                P(o, i, d);
                const w = i.mipmaps;
                if (i.isDepthTexture)
                    g = t.DEPTH_COMPONENT,
                    l ? g = i.type === r.VzW ? t.DEPTH_COMPONENT32F : i.type === r.JQ4 ? t.DEPTH_COMPONENT24 : i.type === r.wJv ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : i.type === r.VzW && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                    i.format === r.qkB && g === t.DEPTH_COMPONENT && i.type !== r.LsT && i.type !== r.JQ4 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    i.type = r.LsT,
                    m = a.convert(i.type)),
                    i.format === r.brP && g === t.DEPTH_COMPONENT && (g = t.DEPTH_STENCIL,
                    i.type !== r.wJv && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                    i.type = r.wJv,
                    m = a.convert(i.type))),
                    n.texImage2D(t.TEXTURE_2D, 0, g, u.width, u.height, 0, f, m, null);
                else if (i.isDataTexture)
                    if (w.length > 0 && d) {
                        for (let e = 0, r = w.length; e < r; e++)
                            p = w[e],
                            n.texImage2D(t.TEXTURE_2D, e, g, p.width, p.height, 0, f, m, p.data);
                        i.generateMipmaps = !1,
                        e.__maxMipLevel = w.length - 1
                    } else
                        n.texImage2D(t.TEXTURE_2D, 0, g, u.width, u.height, 0, f, m, u.data),
                        e.__maxMipLevel = 0;
                else if (i.isCompressedTexture) {
                    for (let e = 0, s = w.length; e < s; e++)
                        p = w[e],
                        i.format !== r.wk1 && i.format !== r.UCm ? null !== f ? n.compressedTexImage2D(t.TEXTURE_2D, e, g, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, e, g, p.width, p.height, 0, f, m, p.data);
                    e.__maxMipLevel = w.length - 1
                } else if (i.isDataTexture2DArray)
                    n.texImage3D(t.TEXTURE_2D_ARRAY, 0, g, u.width, u.height, u.depth, 0, f, m, u.data),
                    e.__maxMipLevel = 0;
                else if (i.isDataTexture3D)
                    n.texImage3D(t.TEXTURE_3D, 0, g, u.width, u.height, u.depth, 0, f, m, u.data),
                    e.__maxMipLevel = 0;
                else if (w.length > 0 && d) {
                    for (let e = 0, r = w.length; e < r; e++)
                        p = w[e],
                        n.texImage2D(t.TEXTURE_2D, e, g, f, m, p);
                    i.generateMipmaps = !1,
                    e.__maxMipLevel = w.length - 1
                } else
                    n.texImage2D(t.TEXTURE_2D, 0, g, f, m, u),
                    e.__maxMipLevel = 0;
                y(i, d) && x(o, i, u.width, u.height),
                e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }
            function I(e, r, s, o, l) {
                const c = a.convert(s.format)
                  , u = a.convert(s.type)
                  , h = b(s.internalFormat, c, u);
                l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null),
                n.bindFramebuffer(t.FRAMEBUFFER, e),
                t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(s).__webglTexture, 0),
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            function N(e, n, i) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e),
                n.depthBuffer && !n.stencilBuffer) {
                    let s = t.DEPTH_COMPONENT16;
                    if (i) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === r.VzW ? s = t.DEPTH_COMPONENT32F : e.type === r.JQ4 && (s = t.DEPTH_COMPONENT24));
                        const i = O(n);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, i, s, n.width, n.height)
                    } else
                        t.renderbufferStorage(t.RENDERBUFFER, s, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        const e = O(n);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, e, t.DEPTH24_STENCIL8, n.width, n.height)
                    } else
                        t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture
                      , r = a.convert(e.format)
                      , s = a.convert(e.type)
                      , o = b(e.internalFormat, r, s);
                    if (i) {
                        const e = O(n);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, e, o, n.width, n.height)
                    } else
                        t.renderbufferStorage(t.RENDERBUFFER, o, n.width, n.height)
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }
            function F(e) {
                const s = i.get(e)
                  , a = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (a)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(e, s) {
                        if (s && s.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(t.FRAMEBUFFER, e),
                        !s.depthTexture || !s.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(s.depthTexture).__webglTexture && s.depthTexture.image.width === s.width && s.depthTexture.image.height === s.height || (s.depthTexture.image.width = s.width,
                        s.depthTexture.image.height = s.height,
                        s.depthTexture.needsUpdate = !0),
                        E(s.depthTexture, 0);
                        const a = i.get(s.depthTexture).__webglTexture;
                        if (s.depthTexture.format === r.qkB)
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0);
                        else {
                            if (s.depthTexture.format !== r.brP)
                                throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0)
                        }
                    }(s.__webglFramebuffer, e)
                } else if (a) {
                    s.__webglDepthbuffer = [];
                    for (let r = 0; r < 6; r++)
                        n.bindFramebuffer(t.FRAMEBUFFER, s.__webglFramebuffer[r]),
                        s.__webglDepthbuffer[r] = t.createRenderbuffer(),
                        N(s.__webglDepthbuffer[r], e, !1)
                } else
                    n.bindFramebuffer(t.FRAMEBUFFER, s.__webglFramebuffer),
                    s.__webglDepthbuffer = t.createRenderbuffer(),
                    N(s.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            function O(t) {
                return l && t.isWebGLMultisampleRenderTarget ? Math.min(d, t.samples) : 0
            }
            let U = !1
              , z = !1;
            this.allocateTextureUnit = function() {
                const t = S;
                return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c),
                S += 1,
                t
            }
            ,
            this.resetTextureUnits = function() {
                S = 0
            }
            ,
            this.setTexture2D = E,
            this.setTexture2DArray = function(e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? D(s, e, r) : (n.activeTexture(t.TEXTURE0 + r),
                n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture))
            }
            ,
            this.setTexture3D = function(e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? D(s, e, r) : (n.activeTexture(t.TEXTURE0 + r),
                n.bindTexture(t.TEXTURE_3D, s.__webglTexture))
            }
            ,
            this.setTextureCube = A,
            this.setupRenderTarget = function(e) {
                const c = e.texture
                  , u = i.get(e)
                  , h = i.get(c);
                e.addEventListener("dispose", T),
                !0 !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(),
                h.__version = c.version,
                o.memory.textures++);
                const d = !0 === e.isWebGLCubeRenderTarget
                  , f = !0 === e.isWebGLMultipleRenderTargets
                  , p = !0 === e.isWebGLMultisampleRenderTarget
                  , m = c.isDataTexture3D || c.isDataTexture2DArray
                  , g = _(e) || l;
                if (!l || c.format !== r.UCm || c.type !== r.VzW && c.type !== r.cLu || (c.format = r.wk1,
                console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
                d) {
                    u.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        u.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (u.__webglFramebuffer = t.createFramebuffer(),
                f)
                    if (s.drawBuffers) {
                        const n = e.texture;
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(),
                            o.memory.textures++)
                        }
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                else if (p)
                    if (l) {
                        u.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        u.__webglColorRenderbuffer = t.createRenderbuffer(),
                        t.bindRenderbuffer(t.RENDERBUFFER, u.__webglColorRenderbuffer);
                        const r = a.convert(c.format)
                          , i = a.convert(c.type)
                          , s = b(c.internalFormat, r, i)
                          , o = O(e);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, o, s, e.width, e.height),
                        n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, u.__webglColorRenderbuffer),
                        t.bindRenderbuffer(t.RENDERBUFFER, null),
                        e.depthBuffer && (u.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        N(u.__webglDepthRenderbuffer, e, !0)),
                        n.bindFramebuffer(t.FRAMEBUFFER, null)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (d) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture),
                    P(t.TEXTURE_CUBE_MAP, c, g);
                    for (let n = 0; n < 6; n++)
                        I(u.__webglFramebuffer[n], e, c, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n);
                    y(c, g) && x(t.TEXTURE_CUBE_MAP, c, e.width, e.height),
                    n.unbindTexture()
                } else if (f) {
                    const r = e.texture;
                    for (let s = 0, a = r.length; s < a; s++) {
                        const a = r[s]
                          , o = i.get(a);
                        n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
                        P(t.TEXTURE_2D, a, g),
                        I(u.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D),
                        y(a, g) && x(t.TEXTURE_2D, a, e.width, e.height)
                    }
                    n.unbindTexture()
                } else {
                    let r = t.TEXTURE_2D;
                    if (m)
                        if (l) {
                            r = c.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY
                        } else
                            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                    n.bindTexture(r, h.__webglTexture),
                    P(r, c, g),
                    I(u.__webglFramebuffer, e, c, t.COLOR_ATTACHMENT0, r),
                    y(c, g) && x(r, c, e.width, e.height, e.depth),
                    n.unbindTexture()
                }
                e.depthBuffer && F(e)
            }
            ,
            this.updateRenderTargetMipmap = function(e) {
                const r = _(e) || l
                  , s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                for (let a = 0, o = s.length; a < o; a++) {
                    const o = s[a];
                    if (y(o, r)) {
                        const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D
                          , s = i.get(o).__webglTexture;
                        n.bindTexture(r, s),
                        x(r, o, e.width, e.height),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (l) {
                        const r = e.width
                          , s = e.height;
                        let a = t.COLOR_BUFFER_BIT;
                        e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                        e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT);
                        const o = i.get(e);
                        n.bindFramebuffer(t.READ_FRAMEBUFFER, o.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, o.__webglFramebuffer),
                        t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, t.NEAREST),
                        n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, o.__webglMultisampledFramebuffer)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }
            ,
            this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                U = !0),
                t = t.texture),
                E(t, e)
            }
            ,
            this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                z = !0),
                t = t.texture),
                A(t, e)
            }
        }
        function mn(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function(n) {
                    let s;
                    if (n === r.ywz)
                        return t.UNSIGNED_BYTE;
                    if (n === r.k0A)
                        return t.UNSIGNED_SHORT_4_4_4_4;
                    if (n === r.irR)
                        return t.UNSIGNED_SHORT_5_5_5_1;
                    if (n === r.XNv)
                        return t.UNSIGNED_SHORT_5_6_5;
                    if (n === r.T95)
                        return t.BYTE;
                    if (n === r.iAb)
                        return t.SHORT;
                    if (n === r.LsT)
                        return t.UNSIGNED_SHORT;
                    if (n === r.Kz5)
                        return t.INT;
                    if (n === r.JQ4)
                        return t.UNSIGNED_INT;
                    if (n === r.VzW)
                        return t.FLOAT;
                    if (n === r.cLu)
                        return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"),
                        null !== s ? s.HALF_FLOAT_OES : null);
                    if (n === r.OTo)
                        return t.ALPHA;
                    if (n === r.UCm)
                        return t.RGB;
                    if (n === r.wk1)
                        return t.RGBA;
                    if (n === r.Y8D)
                        return t.LUMINANCE;
                    if (n === r.cRx)
                        return t.LUMINANCE_ALPHA;
                    if (n === r.qkB)
                        return t.DEPTH_COMPONENT;
                    if (n === r.brP)
                        return t.DEPTH_STENCIL;
                    if (n === r.hEm)
                        return t.RED;
                    if (n === r.D9w)
                        return t.RED_INTEGER;
                    if (n === r.av9)
                        return t.RG;
                    if (n === r.CtA)
                        return t.RG_INTEGER;
                    if (n === r.F5G)
                        return t.RGB_INTEGER;
                    if (n === r.E2K)
                        return t.RGBA_INTEGER;
                    if (n === r.wuA || n === r.BFQ || n === r.v3W || n === r.ILR) {
                        if (s = e.get("WEBGL_compressed_texture_s3tc"),
                        null === s)
                            return null;
                        if (n === r.wuA)
                            return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (n === r.BFQ)
                            return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (n === r.v3W)
                            return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (n === r.ILR)
                            return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (n === r._AM || n === r.vCx || n === r.eaV || n === r.CaW) {
                        if (s = e.get("WEBGL_compressed_texture_pvrtc"),
                        null === s)
                            return null;
                        if (n === r._AM)
                            return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (n === r.vCx)
                            return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === r.eaV)
                            return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (n === r.CaW)
                            return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === r.fto)
                        return s = e.get("WEBGL_compressed_texture_etc1"),
                        null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((n === r.l0P || n === r.ekQ) && (s = e.get("WEBGL_compressed_texture_etc"),
                    null !== s)) {
                        if (n === r.l0P)
                            return s.COMPRESSED_RGB8_ETC2;
                        if (n === r.ekQ)
                            return s.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return n === r.ptH || n === r.jZA || n === r.y2t || n === r.gi4 || n === r.Djp || n === r.BG$ || n === r.NYV || n === r.xJs || n === r.pKu || n === r.GG6 || n === r.Gih || n === r.FUD || n === r.iiP || n === r.SvJ || n === r.APR || n === r.Abz || n === r.v6B || n === r.pnl || n === r.OS$ || n === r._wO || n === r.bcs || n === r.Y5S || n === r.Wso || n === r.p1$ || n === r.I0h || n === r.Yjz || n === r.ePn || n === r.HBG ? (s = e.get("WEBGL_compressed_texture_astc"),
                    null !== s ? n : null) : n === r.bsb ? (s = e.get("EXT_texture_compression_bptc"),
                    null !== s ? n : null) : n === r.wJv ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"),
                    null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        class gn extends C.c {
            constructor(t=[]) {
                super(),
                this.cameras = t
            }
        }
        gn.prototype.isArrayCamera = !0;
        var vn = n(7406)
          , _n = n(2010);
        const yn = {
            type: "move"
        };
        class xn {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new _n.Z,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new _n.Z,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new a.P,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new a.P),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new _n.Z,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new a.P,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new a.P),
                this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(t, e, n) {
                let r = null
                  , i = null
                  , s = null;
                const a = this._targetRay
                  , o = this._grip
                  , l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (null !== a && (r = e.getPose(t.targetRaySpace, n),
                    null !== r && (a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    r.linearVelocity ? (a.hasLinearVelocity = !0,
                    a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
                    r.angularVelocity ? (a.hasAngularVelocity = !0,
                    a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
                    this.dispatchEvent(yn))),
                    l && t.hand) {
                        s = !0;
                        for (const r of t.hand.values()) {
                            const t = e.getJointPose(r, n);
                            if (void 0 === l.joints[r.jointName]) {
                                const t = new _n.Z;
                                t.matrixAutoUpdate = !1,
                                t.visible = !1,
                                l.joints[r.jointName] = t,
                                l.add(t)
                            }
                            const i = l.joints[r.jointName];
                            null !== t && (i.matrix.fromArray(t.transform.matrix),
                            i.matrix.decompose(i.position, i.rotation, i.scale),
                            i.jointRadius = t.radius),
                            i.visible = null !== t
                        }
                        const r = l.joints["index-finger-tip"]
                          , i = l.joints["thumb-tip"]
                          , a = r.position.distanceTo(i.position)
                          , o = .02
                          , c = .005;
                        l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else
                        null !== o && t.gripSpace && (i = e.getPose(t.gripSpace, n),
                        null !== i && (o.matrix.fromArray(i.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        i.linearVelocity ? (o.hasLinearVelocity = !0,
                        o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                        i.angularVelocity ? (o.hasAngularVelocity = !0,
                        o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1));
                return null !== a && (a.visible = null !== r),
                null !== o && (o.visible = null !== i),
                null !== l && (l.visible = null !== s),
                this
            }
        }
        class bn extends vn.p {
            constructor(t, e) {
                super();
                const n = this
                  , r = t.state;
                let i = null
                  , s = 1
                  , c = null
                  , u = "local-floor"
                  , h = null
                  , d = null
                  , f = null
                  , p = null
                  , m = null
                  , g = !1
                  , v = null
                  , _ = null
                  , y = null
                  , x = null
                  , b = null
                  , w = null;
                const M = []
                  , T = new Map
                  , S = new C.c;
                S.layers.enable(1),
                S.viewport = new o.L;
                const E = new C.c;
                E.layers.enable(2),
                E.viewport = new o.L;
                const A = [S, E]
                  , R = new gn;
                R.layers.enable(1),
                R.layers.enable(2);
                let L = null
                  , P = null;
                function D(t) {
                    const e = T.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }
                function I() {
                    T.forEach((function(t, e) {
                        t.disconnect(e)
                    }
                    )),
                    T.clear(),
                    L = null,
                    P = null,
                    r.bindXRFramebuffer(null),
                    t.setRenderTarget(t.getRenderTarget()),
                    f && e.deleteFramebuffer(f),
                    v && e.deleteFramebuffer(v),
                    _ && e.deleteRenderbuffer(_),
                    y && e.deleteRenderbuffer(y),
                    f = null,
                    v = null,
                    _ = null,
                    y = null,
                    m = null,
                    p = null,
                    d = null,
                    i = null,
                    B.stop(),
                    n.isPresenting = !1,
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function N(t) {
                    const e = i.inputSources;
                    for (let t = 0; t < M.length; t++)
                        T.set(e[t], M[t]);
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e]
                          , r = T.get(n);
                        r && (r.dispatchEvent({
                            type: "disconnected",
                            data: n
                        }),
                        T.delete(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e]
                          , r = T.get(n);
                        r && r.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(t) {
                    let e = M[t];
                    return void 0 === e && (e = new xn,
                    M[t] = e),
                    e.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(t) {
                    let e = M[t];
                    return void 0 === e && (e = new xn,
                    M[t] = e),
                    e.getGripSpace()
                }
                ,
                this.getHand = function(t) {
                    let e = M[t];
                    return void 0 === e && (e = new xn,
                    M[t] = e),
                    e.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(t) {
                    s = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(t) {
                    u = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return c
                }
                ,
                this.getBaseLayer = function() {
                    return null !== p ? p : m
                }
                ,
                this.getBinding = function() {
                    return d
                }
                ,
                this.getFrame = function() {
                    return x
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(t) {
                    if (i = t,
                    null !== i) {
                        i.addEventListener("select", D),
                        i.addEventListener("selectstart", D),
                        i.addEventListener("selectend", D),
                        i.addEventListener("squeeze", D),
                        i.addEventListener("squeezestart", D),
                        i.addEventListener("squeezeend", D),
                        i.addEventListener("end", I),
                        i.addEventListener("inputsourceschange", N);
                        const t = e.getContextAttributes();
                        if (!0 !== t.xrCompatible && await e.makeXRCompatible(),
                        void 0 === i.renderState.layers) {
                            const n = {
                                antialias: t.antialias,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil,
                                framebufferScaleFactor: s
                            };
                            m = new XRWebGLLayer(i,e,n),
                            i.updateRenderState({
                                baseLayer: m
                            })
                        } else if (e instanceof WebGLRenderingContext) {
                            const n = {
                                antialias: !0,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil,
                                framebufferScaleFactor: s
                            };
                            m = new XRWebGLLayer(i,e,n),
                            i.updateRenderState({
                                layers: [m]
                            })
                        } else {
                            g = t.antialias;
                            let n = null;
                            t.depth && (w = e.DEPTH_BUFFER_BIT,
                            t.stencil && (w |= e.STENCIL_BUFFER_BIT),
                            b = t.stencil ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            n = t.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24);
                            const a = {
                                colorFormat: t.alpha ? e.RGBA8 : e.RGB8,
                                depthFormat: n,
                                scaleFactor: s
                            };
                            d = new XRWebGLBinding(i,e),
                            p = d.createProjectionLayer(a),
                            f = e.createFramebuffer(),
                            i.updateRenderState({
                                layers: [p]
                            }),
                            g && (v = e.createFramebuffer(),
                            _ = e.createRenderbuffer(),
                            e.bindRenderbuffer(e.RENDERBUFFER, _),
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, e.RGBA8, p.textureWidth, p.textureHeight),
                            r.bindFramebuffer(e.FRAMEBUFFER, v),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, _),
                            e.bindRenderbuffer(e.RENDERBUFFER, null),
                            null !== n && (y = e.createRenderbuffer(),
                            e.bindRenderbuffer(e.RENDERBUFFER, y),
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, n, p.textureWidth, p.textureHeight),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, b, e.RENDERBUFFER, y),
                            e.bindRenderbuffer(e.RENDERBUFFER, null)),
                            r.bindFramebuffer(e.FRAMEBUFFER, null))
                        }
                        c = await i.requestReferenceSpace(u),
                        B.setContext(i),
                        B.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ;
                const F = new a.P
                  , O = new a.P;
                function U(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function(t) {
                    if (null === i)
                        return;
                    R.near = E.near = S.near = t.near,
                    R.far = E.far = S.far = t.far,
                    L === R.near && P === R.far || (i.updateRenderState({
                        depthNear: R.near,
                        depthFar: R.far
                    }),
                    L = R.near,
                    P = R.far);
                    const e = t.parent
                      , n = R.cameras;
                    U(R, e);
                    for (let t = 0; t < n.length; t++)
                        U(n[t], e);
                    R.matrixWorld.decompose(R.position, R.quaternion, R.scale),
                    t.position.copy(R.position),
                    t.quaternion.copy(R.quaternion),
                    t.scale.copy(R.scale),
                    t.matrix.copy(R.matrix),
                    t.matrixWorld.copy(R.matrixWorld);
                    const r = t.children;
                    for (let t = 0, e = r.length; t < e; t++)
                        r[t].updateMatrixWorld(!0);
                    2 === n.length ? function(t, e, n) {
                        F.setFromMatrixPosition(e.matrixWorld),
                        O.setFromMatrixPosition(n.matrixWorld);
                        const r = F.distanceTo(O)
                          , i = e.projectionMatrix.elements
                          , s = n.projectionMatrix.elements
                          , a = i[14] / (i[10] - 1)
                          , o = i[14] / (i[10] + 1)
                          , l = (i[9] + 1) / i[5]
                          , c = (i[9] - 1) / i[5]
                          , u = (i[8] - 1) / i[0]
                          , h = (s[8] + 1) / s[0]
                          , d = a * u
                          , f = a * h
                          , p = r / (-u + h)
                          , m = p * -u;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                        t.translateX(m),
                        t.translateZ(p),
                        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = a + p
                          , v = o + p
                          , _ = d - m
                          , y = f + (r - m)
                          , x = l * o / v * g
                          , b = c * o / v * g;
                        t.projectionMatrix.makePerspective(_, y, x, b, g, v)
                    }(R, S, E) : R.projectionMatrix.copy(S.projectionMatrix)
                }
                ,
                this.getCamera = function() {
                    return R
                }
                ,
                this.getFoveation = function() {
                    return null !== p ? p.fixedFoveation : null !== m ? m.fixedFoveation : void 0
                }
                ,
                this.setFoveation = function(t) {
                    null !== p && (p.fixedFoveation = t),
                    null !== m && void 0 !== m.fixedFoveation && (m.fixedFoveation = t)
                }
                ;
                let z = null;
                const B = new l;
                B.setAnimationLoop((function(t, n) {
                    if (h = n.getViewerPose(c),
                    x = n,
                    null !== h) {
                        const t = h.views;
                        null !== m && r.bindXRFramebuffer(m.framebuffer);
                        let n = !1;
                        t.length !== R.cameras.length && (R.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i];
                            let a = null;
                            if (null !== m)
                                a = m.getViewport(s);
                            else {
                                const t = d.getViewSubImage(p, s);
                                r.bindXRFramebuffer(f),
                                void 0 !== t.depthStencilTexture && e.framebufferTexture2D(e.FRAMEBUFFER, b, e.TEXTURE_2D, t.depthStencilTexture, 0),
                                e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t.colorTexture, 0),
                                a = t.viewport
                            }
                            const o = A[i];
                            o.matrix.fromArray(s.transform.matrix),
                            o.projectionMatrix.fromArray(s.projectionMatrix),
                            o.viewport.set(a.x, a.y, a.width, a.height),
                            0 === i && R.matrix.copy(o.matrix),
                            !0 === n && R.cameras.push(o)
                        }
                        g && (r.bindXRFramebuffer(v),
                        null !== w && e.clear(w))
                    }
                    const s = i.inputSources;
                    for (let t = 0; t < M.length; t++) {
                        const e = M[t]
                          , r = s[t];
                        e.update(r, n, c)
                    }
                    if (z && z(t, n),
                    g) {
                        const t = p.textureWidth
                          , n = p.textureHeight;
                        r.bindFramebuffer(e.READ_FRAMEBUFFER, v),
                        r.bindFramebuffer(e.DRAW_FRAMEBUFFER, f),
                        e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [b]),
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [b]),
                        e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, e.COLOR_BUFFER_BIT, e.NEAREST),
                        e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [e.COLOR_ATTACHMENT0]),
                        r.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        r.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        r.bindFramebuffer(e.FRAMEBUFFER, v)
                    }
                    x = null
                }
                )),
                this.setAnimationLoop = function(t) {
                    z = t
                }
                ,
                this.dispose = function() {}
            }
        }
        function wn(t) {
            function e(e, n) {
                e.opacity.value = n.opacity,
                n.color && e.diffuse.value.copy(n.color),
                n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                n.map && (e.map.value = n.map),
                n.alphaMap && (e.alphaMap.value = n.alphaMap),
                n.specularMap && (e.specularMap.value = n.specularMap),
                n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                const r = t.get(n).envMap;
                if (r) {
                    e.envMap.value = r,
                    e.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1,
                    e.reflectivity.value = n.reflectivity,
                    e.ior.value = n.ior,
                    e.refractionRatio.value = n.refractionRatio;
                    const i = t.get(r).__maxMipLevel;
                    void 0 !== i && (e.maxMipLevel.value = i)
                }
                let i, s;
                n.lightMap && (e.lightMap.value = n.lightMap,
                e.lightMapIntensity.value = n.lightMapIntensity),
                n.aoMap && (e.aoMap.value = n.aoMap,
                e.aoMapIntensity.value = n.aoMapIntensity),
                n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? i = n.clearcoatRoughnessMap : n.specularIntensityMap ? i = n.specularIntensityMap : n.specularTintMap ? i = n.specularTintMap : n.transmissionMap ? i = n.transmissionMap : n.thicknessMap && (i = n.thicknessMap),
                void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture),
                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                e.uvTransform.value.copy(i.matrix)),
                n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap),
                void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix))
            }
            function n(e, n) {
                e.roughness.value = n.roughness,
                e.metalness.value = n.metalness,
                n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
                n.bumpMap && (e.bumpMap.value = n.bumpMap,
                e.bumpScale.value = n.bumpScale,
                n.side === r._Li && (e.bumpScale.value *= -1)),
                n.normalMap && (e.normalMap.value = n.normalMap,
                e.normalScale.value.copy(n.normalScale),
                n.side === r._Li && e.normalScale.value.negate()),
                n.displacementMap && (e.displacementMap.value = n.displacementMap,
                e.displacementScale.value = n.displacementScale,
                e.displacementBias.value = n.displacementBias);
                t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color),
                    e.isFog ? (t.fogNear.value = e.near,
                    t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, i, s, a, o) {
                    i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i),
                    function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, i)) : i.isMeshToonMaterial ? (e(t, i),
                    function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === r._Li && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === r._Li && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshPhongMaterial ? (e(t, i),
                    function(t, e) {
                        t.specular.value.copy(e.specular),
                        t.shininess.value = Math.max(e.shininess, 1e-4),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === r._Li && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === r._Li && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshStandardMaterial ? (e(t, i),
                    i.isMeshPhysicalMaterial ? function(t, e, i) {
                        n(t, e),
                        t.ior.value = e.ior,
                        e.sheenTint && t.sheenTint.value.copy(e.sheenTint);
                        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat,
                        t.clearcoatRoughness.value = e.clearcoatRoughness,
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                        t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                        e.side === r._Li && t.clearcoatNormalScale.value.negate()));
                        e.transmission > 0 && (t.transmission.value = e.transmission,
                        t.transmissionSamplerMap.value = i.texture,
                        t.transmissionSamplerSize.value.set(i.width, i.height),
                        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                        t.thickness.value = e.thickness,
                        e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                        t.attenuationDistance.value = e.attenuationDistance,
                        t.attenuationTint.value.copy(e.attenuationTint));
                        t.specularIntensity.value = e.specularIntensity,
                        t.specularTint.value.copy(e.specularTint),
                        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
                        e.specularTintMap && (t.specularTintMap.value = e.specularTintMap)
                    }(t, i, o) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i),
                    function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === r._Li && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === r._Li && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDepthMaterial ? (e(t, i),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition),
                        t.nearDistance.value = e.nearDistance,
                        t.farDistance.value = e.farDistance
                    }(t, i)) : i.isMeshNormalMaterial ? (e(t, i),
                    function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === r._Li && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === r._Li && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity
                    }(t, i),
                    i.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function(t, e, n, r) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * n,
                        t.scale.value = .5 * r,
                        e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                        let i;
                        e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                        void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                        t.uvTransform.value.copy(i.matrix))
                    }(t, i, s, a) : i.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.rotation.value = e.rotation,
                        e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                        let n;
                        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                        t.uvTransform.value.copy(n.matrix))
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color),
                    t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }
        function Mn(t={}) {
            const e = void 0 !== t.canvas ? t.canvas : function() {
                const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return t.style.display = "block",
                t
            }()
              , n = void 0 !== t.context ? t.context : null
              , u = void 0 !== t.alpha && t.alpha
              , h = void 0 === t.depth || t.depth
              , d = void 0 === t.stencil || t.stencil
              , f = void 0 !== t.antialias && t.antialias
              , p = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
              , m = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
              , g = void 0 !== t.powerPreference ? t.powerPreference : "default"
              , v = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let _ = null
              , y = null;
            const x = []
              , b = [];
            this.domElement = e,
            this.debug = {
                checkShaderErrors: !0
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.gammaFactor = 2,
            this.outputEncoding = r.rnI,
            this.physicallyCorrectLights = !1,
            this.toneMapping = r.uL9,
            this.toneMappingExposure = 1;
            const w = this;
            let A = !1
              , P = 0
              , C = 0
              , D = null
              , I = -1
              , N = null;
            const F = new o.L
              , U = new o.L;
            let z = null
              , B = e.width
              , k = e.height
              , G = 1
              , H = null
              , V = null;
            const W = new o.L(0,0,B,k)
              , X = new o.L(0,0,B,k);
            let j = !1;
            const Y = []
              , q = new i.i;
            let Z = !1
              , K = !1
              , J = null;
            const Q = new s.y
              , $ = new a.P
              , tt = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function et() {
                return null === D ? G : 1
            }
            let nt, rt, it, st, at, ot, lt, ct, ut, ft, vt, _t, wt, Mt, Tt, St, Et, At, Rt, Lt, Pt, Ct, Dt, It = n;
            function Nt(t, n) {
                for (let r = 0; r < t.length; r++) {
                    const i = t[r]
                      , s = e.getContext(i, n);
                    if (null !== s)
                        return s
                }
                return null
            }
            try {
                const t = {
                    alpha: u,
                    depth: h,
                    stencil: d,
                    antialias: f,
                    premultipliedAlpha: p,
                    preserveDrawingBuffer: m,
                    powerPreference: g,
                    failIfMajorPerformanceCaveat: v
                };
                if (e.addEventListener("webglcontextlost", Ut, !1),
                e.addEventListener("webglcontextrestored", zt, !1),
                null === It) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === w.isWebGL1Renderer && e.shift(),
                    It = Nt(e, t),
                    null === It)
                        throw Nt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === It.getShaderPrecisionFormat && (It.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }
                )
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message),
                t
            }
            function Ft() {
                nt = new dt(It),
                rt = new E(It,nt,t),
                nt.init(rt),
                Ct = new mn(It,nt,rt),
                it = new dn(It,nt,rt),
                Y[0] = It.BACK,
                st = new gt(It),
                at = new qe,
                ot = new pn(It,nt,it,at,rt,Ct,st),
                lt = new O(w),
                ct = new ht(w),
                ut = new c(It,rt),
                Dt = new T(It,nt,ut,rt),
                ft = new pt(It,ut,st,Dt),
                vt = new bt(It,ft,ut,st),
                Rt = new yt(It),
                St = new R(at),
                _t = new Ye(w,lt,ct,nt,rt,Dt,St),
                wt = new wn(at),
                Mt = new Qe(at),
                Tt = new sn(nt,rt),
                At = new M(w,lt,it,vt,p),
                Et = new hn(w,vt,rt),
                Lt = new S(It,nt,st,rt),
                Pt = new mt(It,nt,st,rt),
                st.programs = _t.programs,
                w.capabilities = rt,
                w.extensions = nt,
                w.properties = at,
                w.renderLists = Mt,
                w.shadowMap = Et,
                w.state = it,
                w.info = st
            }
            Ft();
            const Ot = new bn(w,It);
            function Ut(t) {
                t.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                A = !0
            }
            function zt() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                A = !1;
                const t = st.autoReset
                  , e = Et.enabled
                  , n = Et.autoUpdate
                  , r = Et.needsUpdate
                  , i = Et.type;
                Ft(),
                st.autoReset = t,
                Et.enabled = e,
                Et.autoUpdate = n,
                Et.needsUpdate = r,
                Et.type = i
            }
            function Bt(t) {
                const e = t.target;
                e.removeEventListener("dispose", Bt),
                function(t) {
                    (function(t) {
                        const e = at.get(t).programs;
                        void 0 !== e && e.forEach((function(t) {
                            _t.releaseProgram(t)
                        }
                        ))
                    }
                    )(t),
                    at.remove(t)
                }(e)
            }
            this.xr = Ot,
            this.getContext = function() {
                return It
            }
            ,
            this.getContextAttributes = function() {
                return It.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                const t = nt.get("WEBGL_lose_context");
                t && t.loseContext()
            }
            ,
            this.forceContextRestore = function() {
                const t = nt.get("WEBGL_lose_context");
                t && t.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
                return G
            }
            ,
            this.setPixelRatio = function(t) {
                void 0 !== t && (G = t,
                this.setSize(B, k, !1))
            }
            ,
            this.getSize = function(t) {
                return t.set(B, k)
            }
            ,
            this.setSize = function(t, n, r) {
                Ot.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B = t,
                k = n,
                e.width = Math.floor(t * G),
                e.height = Math.floor(n * G),
                !1 !== r && (e.style.width = t + "px",
                e.style.height = n + "px"),
                this.setViewport(0, 0, t, n))
            }
            ,
            this.getDrawingBufferSize = function(t) {
                return t.set(B * G, k * G).floor()
            }
            ,
            this.setDrawingBufferSize = function(t, n, r) {
                B = t,
                k = n,
                G = r,
                e.width = Math.floor(t * r),
                e.height = Math.floor(n * r),
                this.setViewport(0, 0, t, n)
            }
            ,
            this.getCurrentViewport = function(t) {
                return t.copy(F)
            }
            ,
            this.getViewport = function(t) {
                return t.copy(W)
            }
            ,
            this.setViewport = function(t, e, n, r) {
                t.isVector4 ? W.set(t.x, t.y, t.z, t.w) : W.set(t, e, n, r),
                it.viewport(F.copy(W).multiplyScalar(G).floor())
            }
            ,
            this.getScissor = function(t) {
                return t.copy(X)
            }
            ,
            this.setScissor = function(t, e, n, r) {
                t.isVector4 ? X.set(t.x, t.y, t.z, t.w) : X.set(t, e, n, r),
                it.scissor(U.copy(X).multiplyScalar(G).floor())
            }
            ,
            this.getScissorTest = function() {
                return j
            }
            ,
            this.setScissorTest = function(t) {
                it.setScissorTest(j = t)
            }
            ,
            this.setOpaqueSort = function(t) {
                H = t
            }
            ,
            this.setTransparentSort = function(t) {
                V = t
            }
            ,
            this.getClearColor = function(t) {
                return t.copy(At.getClearColor())
            }
            ,
            this.setClearColor = function() {
                At.setClearColor.apply(At, arguments)
            }
            ,
            this.getClearAlpha = function() {
                return At.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
                At.setClearAlpha.apply(At, arguments)
            }
            ,
            this.clear = function(t, e, n) {
                let r = 0;
                (void 0 === t || t) && (r |= It.COLOR_BUFFER_BIT),
                (void 0 === e || e) && (r |= It.DEPTH_BUFFER_BIT),
                (void 0 === n || n) && (r |= It.STENCIL_BUFFER_BIT),
                It.clear(r)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
                e.removeEventListener("webglcontextlost", Ut, !1),
                e.removeEventListener("webglcontextrestored", zt, !1),
                Mt.dispose(),
                Tt.dispose(),
                at.dispose(),
                lt.dispose(),
                ct.dispose(),
                vt.dispose(),
                Dt.dispose(),
                Ot.dispose(),
                Ot.removeEventListener("sessionstart", Gt),
                Ot.removeEventListener("sessionend", Ht),
                J && (J.dispose(),
                J = null),
                Vt.stop()
            }
            ,
            this.renderBufferImmediate = function(t, e) {
                Dt.initAttributes();
                const n = at.get(t);
                t.hasPositions && !n.position && (n.position = It.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = It.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = It.createBuffer()),
                t.hasColors && !n.color && (n.color = It.createBuffer());
                const r = e.getAttributes();
                t.hasPositions && (It.bindBuffer(It.ARRAY_BUFFER, n.position),
                It.bufferData(It.ARRAY_BUFFER, t.positionArray, It.DYNAMIC_DRAW),
                Dt.enableAttribute(r.position.location),
                It.vertexAttribPointer(r.position.location, 3, It.FLOAT, !1, 0, 0)),
                t.hasNormals && (It.bindBuffer(It.ARRAY_BUFFER, n.normal),
                It.bufferData(It.ARRAY_BUFFER, t.normalArray, It.DYNAMIC_DRAW),
                Dt.enableAttribute(r.normal.location),
                It.vertexAttribPointer(r.normal.location, 3, It.FLOAT, !1, 0, 0)),
                t.hasUvs && (It.bindBuffer(It.ARRAY_BUFFER, n.uv),
                It.bufferData(It.ARRAY_BUFFER, t.uvArray, It.DYNAMIC_DRAW),
                Dt.enableAttribute(r.uv.location),
                It.vertexAttribPointer(r.uv.location, 2, It.FLOAT, !1, 0, 0)),
                t.hasColors && (It.bindBuffer(It.ARRAY_BUFFER, n.color),
                It.bufferData(It.ARRAY_BUFFER, t.colorArray, It.DYNAMIC_DRAW),
                Dt.enableAttribute(r.color.location),
                It.vertexAttribPointer(r.color.location, 3, It.FLOAT, !1, 0, 0)),
                Dt.disableUnusedAttributes(),
                It.drawArrays(It.TRIANGLES, 0, t.count),
                t.count = 0
            }
            ,
            this.renderBufferDirect = function(t, e, n, r, i, s) {
                null === e && (e = tt);
                const a = i.isMesh && i.matrixWorld.determinant() < 0
                  , o = Kt(t, e, r, i);
                it.setMaterial(r, a);
                let l = n.index;
                const c = n.attributes.position;
                if (null === l) {
                    if (void 0 === c || 0 === c.count)
                        return
                } else if (0 === l.count)
                    return;
                let u, h = 1;
                !0 === r.wireframe && (l = ft.getWireframeAttribute(n),
                h = 2),
                void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || Rt.update(i, n, r, o),
                Dt.setup(i, r, o, n, l);
                let d = Lt;
                null !== l && (u = ut.get(l),
                d = Pt,
                d.setIndex(u));
                const f = null !== l ? l.count : c.count
                  , p = n.drawRange.start * h
                  , m = n.drawRange.count * h
                  , g = null !== s ? s.start * h : 0
                  , v = null !== s ? s.count * h : 1 / 0
                  , _ = Math.max(p, g)
                  , y = Math.min(f, p + m, g + v) - 1
                  , x = Math.max(0, y - _ + 1);
                if (0 !== x) {
                    if (i.isMesh)
                        !0 === r.wireframe ? (it.setLineWidth(r.wireframeLinewidth * et()),
                        d.setMode(It.LINES)) : d.setMode(It.TRIANGLES);
                    else if (i.isLine) {
                        let t = r.linewidth;
                        void 0 === t && (t = 1),
                        it.setLineWidth(t * et()),
                        i.isLineSegments ? d.setMode(It.LINES) : i.isLineLoop ? d.setMode(It.LINE_LOOP) : d.setMode(It.LINE_STRIP)
                    } else
                        i.isPoints ? d.setMode(It.POINTS) : i.isSprite && d.setMode(It.TRIANGLES);
                    if (i.isInstancedMesh)
                        d.renderInstances(_, x, i.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        d.renderInstances(_, x, t)
                    } else
                        d.render(_, x)
                }
            }
            ,
            this.compile = function(t, e) {
                y = Tt.get(t),
                y.init(),
                b.push(y),
                t.traverseVisible((function(t) {
                    t.isLight && t.layers.test(e.layers) && (y.pushLight(t),
                    t.castShadow && y.pushShadow(t))
                }
                )),
                y.setupLights(w.physicallyCorrectLights),
                t.traverse((function(e) {
                    const n = e.material;
                    if (n)
                        if (Array.isArray(n))
                            for (let r = 0; r < n.length; r++) {
                                qt(n[r], t, e)
                            }
                        else
                            qt(n, t, e)
                }
                )),
                b.pop(),
                y = null
            }
            ;
            let kt = null;
            function Gt() {
                Vt.stop()
            }
            function Ht() {
                Vt.start()
            }
            const Vt = new l;
            function Wt(t, e, n, r) {
                if (!1 === t.visible)
                    return;
                if (t.layers.test(e.layers))
                    if (t.isGroup)
                        n = t.renderOrder;
                    else if (t.isLOD)
                        !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight)
                        y.pushLight(t),
                        t.castShadow && y.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || q.intersectsSprite(t)) {
                            r && $.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Q);
                            const e = vt.update(t)
                              , i = t.material;
                            i.visible && _.push(t, e, i, n, $.z, null)
                        }
                    } else if (t.isImmediateRenderObject)
                        r && $.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Q),
                        _.push(t, null, t.material, n, $.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== st.render.frame && (t.skeleton.update(),
                    t.skeleton.frame = st.render.frame),
                    !t.frustumCulled || q.intersectsObject(t))) {
                        r && $.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Q);
                        const e = vt.update(t)
                          , i = t.material;
                        if (Array.isArray(i)) {
                            const r = e.groups;
                            for (let s = 0, a = r.length; s < a; s++) {
                                const a = r[s]
                                  , o = i[a.materialIndex];
                                o && o.visible && _.push(t, e, o, n, $.z, a)
                            }
                        } else
                            i.visible && _.push(t, e, i, n, $.z, null)
                    }
                const i = t.children;
                for (let t = 0, s = i.length; t < s; t++)
                    Wt(i[t], e, n, r)
            }
            function Xt(t, e, n, i) {
                const s = t.opaque
                  , a = t.transmissive
                  , o = t.transparent;
                y.setupLightsView(n),
                a.length > 0 && function(t, e, n) {
                    if (null === J) {
                        const t = !0 === f && !0 === rt.isWebGL2 ? xt : L.d;
                        J = new t(1024,1024,{
                            generateMipmaps: !0,
                            type: null !== Ct.convert(r.cLu) ? r.cLu : r.ywz,
                            minFilter: r.D1R,
                            magFilter: r.TyD,
                            wrapS: r.uWy,
                            wrapT: r.uWy
                        })
                    }
                    const i = w.getRenderTarget();
                    w.setRenderTarget(J),
                    w.clear();
                    const s = w.toneMapping;
                    w.toneMapping = r.uL9,
                    jt(t, e, n),
                    w.toneMapping = s,
                    ot.updateMultisampleRenderTarget(J),
                    ot.updateRenderTargetMipmap(J),
                    w.setRenderTarget(i)
                }(s, e, n),
                i && it.viewport(F.copy(i)),
                s.length > 0 && jt(s, e, n),
                a.length > 0 && jt(a, e, n),
                o.length > 0 && jt(o, e, n)
            }
            function jt(t, e, n) {
                const r = !0 === e.isScene ? e.overrideMaterial : null;
                for (let i = 0, s = t.length; i < s; i++) {
                    const s = t[i]
                      , a = s.object
                      , o = s.geometry
                      , l = null === r ? s.material : r
                      , c = s.group;
                    a.layers.test(n.layers) && Yt(a, e, n, o, l, c)
                }
            }
            function Yt(t, e, n, i, s, a) {
                if (t.onBeforeRender(w, e, n, i, s, a),
                t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                t.isImmediateRenderObject) {
                    const r = Kt(n, e, s, t);
                    it.setMaterial(s),
                    Dt.reset(),
                    function(t, e) {
                        t.render((function(t) {
                            w.renderBufferImmediate(t, e)
                        }
                        ))
                    }(t, r)
                } else
                    !0 === s.transparent && s.side === r.ehD ? (s.side = r._Li,
                    s.needsUpdate = !0,
                    w.renderBufferDirect(n, e, i, s, t, a),
                    s.side = r.Wl3,
                    s.needsUpdate = !0,
                    w.renderBufferDirect(n, e, i, s, t, a),
                    s.side = r.ehD) : w.renderBufferDirect(n, e, i, s, t, a);
                t.onAfterRender(w, e, n, i, s, a)
            }
            function qt(t, e, n) {
                !0 !== e.isScene && (e = tt);
                const r = at.get(t)
                  , i = y.state.lights
                  , s = y.state.shadowsArray
                  , a = i.state.version
                  , o = _t.getParameters(t, i.state, s, e, n)
                  , l = _t.getProgramCacheKey(o);
                let c = r.programs;
                r.environment = t.isMeshStandardMaterial ? e.environment : null,
                r.fog = e.fog,
                r.envMap = (t.isMeshStandardMaterial ? ct : lt).get(t.envMap || r.environment),
                void 0 === c && (t.addEventListener("dispose", Bt),
                c = new Map,
                r.programs = c);
                let u = c.get(l);
                if (void 0 !== u) {
                    if (r.currentProgram === u && r.lightsStateVersion === a)
                        return Zt(t, o),
                        u
                } else
                    o.uniforms = _t.getUniforms(t),
                    t.onBuild(o, w),
                    t.onBeforeCompile(o, w),
                    u = _t.acquireProgram(o, l),
                    c.set(l, u),
                    r.uniforms = o.uniforms;
                const h = r.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = St.uniform),
                Zt(t, o),
                r.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t),
                r.lightsStateVersion = a,
                r.needsLights && (h.ambientLightColor.value = i.state.ambient,
                h.lightProbe.value = i.state.probe,
                h.directionalLights.value = i.state.directional,
                h.directionalLightShadows.value = i.state.directionalShadow,
                h.spotLights.value = i.state.spot,
                h.spotLightShadows.value = i.state.spotShadow,
                h.rectAreaLights.value = i.state.rectArea,
                h.ltc_1.value = i.state.rectAreaLTC1,
                h.ltc_2.value = i.state.rectAreaLTC2,
                h.pointLights.value = i.state.point,
                h.pointLightShadows.value = i.state.pointShadow,
                h.hemisphereLights.value = i.state.hemi,
                h.directionalShadowMap.value = i.state.directionalShadowMap,
                h.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
                h.spotShadowMap.value = i.state.spotShadowMap,
                h.spotShadowMatrix.value = i.state.spotShadowMatrix,
                h.pointShadowMap.value = i.state.pointShadowMap,
                h.pointShadowMatrix.value = i.state.pointShadowMatrix);
                const d = u.getUniforms()
                  , f = Ee.seqWithValue(d.seq, h);
                return r.currentProgram = u,
                r.uniformsList = f,
                u
            }
            function Zt(t, e) {
                const n = at.get(t);
                n.outputEncoding = e.outputEncoding,
                n.instancing = e.instancing,
                n.skinning = e.skinning,
                n.morphTargets = e.morphTargets,
                n.morphNormals = e.morphNormals,
                n.numClippingPlanes = e.numClippingPlanes,
                n.numIntersection = e.numClipIntersection,
                n.vertexAlphas = e.vertexAlphas,
                n.vertexTangents = e.vertexTangents
            }
            function Kt(t, e, n, r) {
                !0 !== e.isScene && (e = tt),
                ot.resetTextureUnits();
                const i = e.fog
                  , s = n.isMeshStandardMaterial ? e.environment : null
                  , a = null === D ? w.outputEncoding : D.texture.encoding
                  , o = (n.isMeshStandardMaterial ? ct : lt).get(n.envMap || s)
                  , l = !0 === n.vertexColors && !!r.geometry && !!r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize
                  , c = !!r.geometry && !!r.geometry.attributes.tangent
                  , u = !!r.geometry && !!r.geometry.morphAttributes.position
                  , h = !!r.geometry && !!r.geometry.morphAttributes.normal
                  , d = at.get(n)
                  , f = y.state.lights;
                if (!0 === Z && (!0 === K || t !== N)) {
                    const e = t === N && n.id === I;
                    St.setState(n, t, e)
                }
                let p = !1;
                n.version === d.__version ? d.needsLights && d.lightsStateVersion !== f.state.version || d.outputEncoding !== a || r.isInstancedMesh && !1 === d.instancing ? p = !0 : r.isInstancedMesh || !0 !== d.instancing ? r.isSkinnedMesh && !1 === d.skinning ? p = !0 : r.isSkinnedMesh || !0 !== d.skinning ? d.envMap !== o || n.fog && d.fog !== i ? p = !0 : void 0 === d.numClippingPlanes || d.numClippingPlanes === St.numPlanes && d.numIntersection === St.numIntersection ? (d.vertexAlphas !== l || d.vertexTangents !== c || d.morphTargets !== u || d.morphNormals !== h) && (p = !0) : p = !0 : p = !0 : p = !0 : (p = !0,
                d.__version = n.version);
                let m = d.currentProgram;
                !0 === p && (m = qt(n, e, r));
                let g = !1
                  , v = !1
                  , _ = !1;
                const x = m.getUniforms()
                  , b = d.uniforms;
                if (it.useProgram(m.program) && (g = !0,
                v = !0,
                _ = !0),
                n.id !== I && (I = n.id,
                v = !0),
                g || N !== t) {
                    if (x.setValue(It, "projectionMatrix", t.projectionMatrix),
                    rt.logarithmicDepthBuffer && x.setValue(It, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                    N !== t && (N = t,
                    v = !0,
                    _ = !0),
                    n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        const e = x.map.cameraPosition;
                        void 0 !== e && e.setValue(It, $.setFromMatrixPosition(t.matrixWorld))
                    }
                    (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && x.setValue(It, "isOrthographic", !0 === t.isOrthographicCamera),
                    (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && x.setValue(It, "viewMatrix", t.matrixWorldInverse)
                }
                if (r.isSkinnedMesh) {
                    x.setOptional(It, r, "bindMatrix"),
                    x.setOptional(It, r, "bindMatrixInverse");
                    const t = r.skeleton;
                    t && (rt.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(),
                    x.setValue(It, "boneTexture", t.boneTexture, ot),
                    x.setValue(It, "boneTextureSize", t.boneTextureSize)) : x.setOptional(It, t, "boneMatrices"))
                }
                var M, T;
                return (v || d.receiveShadow !== r.receiveShadow) && (d.receiveShadow = r.receiveShadow,
                x.setValue(It, "receiveShadow", r.receiveShadow)),
                v && (x.setValue(It, "toneMappingExposure", w.toneMappingExposure),
                d.needsLights && (T = _,
                (M = b).ambientLightColor.needsUpdate = T,
                M.lightProbe.needsUpdate = T,
                M.directionalLights.needsUpdate = T,
                M.directionalLightShadows.needsUpdate = T,
                M.pointLights.needsUpdate = T,
                M.pointLightShadows.needsUpdate = T,
                M.spotLights.needsUpdate = T,
                M.spotLightShadows.needsUpdate = T,
                M.rectAreaLights.needsUpdate = T,
                M.hemisphereLights.needsUpdate = T),
                i && n.fog && wt.refreshFogUniforms(b, i),
                wt.refreshMaterialUniforms(b, n, G, k, J),
                Ee.upload(It, d.uniformsList, b, ot)),
                n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Ee.upload(It, d.uniformsList, b, ot),
                n.uniformsNeedUpdate = !1),
                n.isSpriteMaterial && x.setValue(It, "center", r.center),
                x.setValue(It, "modelViewMatrix", r.modelViewMatrix),
                x.setValue(It, "normalMatrix", r.normalMatrix),
                x.setValue(It, "modelMatrix", r.matrixWorld),
                m
            }
            Vt.setAnimationLoop((function(t) {
                kt && kt(t)
            }
            )),
            "undefined" != typeof window && Vt.setContext(window),
            this.setAnimationLoop = function(t) {
                kt = t,
                Ot.setAnimationLoop(t),
                null === t ? Vt.stop() : Vt.start()
            }
            ,
            Ot.addEventListener("sessionstart", Gt),
            Ot.addEventListener("sessionend", Ht),
            this.render = function(t, e) {
                if (void 0 !== e && !0 !== e.isCamera)
                    return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === A)
                    return;
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === Ot.enabled && !0 === Ot.isPresenting && (!0 === Ot.cameraAutoUpdate && Ot.updateCamera(e),
                e = Ot.getCamera()),
                !0 === t.isScene && t.onBeforeRender(w, t, e, D),
                y = Tt.get(t, b.length),
                y.init(),
                b.push(y),
                Q.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                q.setFromProjectionMatrix(Q),
                K = this.localClippingEnabled,
                Z = St.init(this.clippingPlanes, K, e),
                _ = Mt.get(t, x.length),
                _.init(),
                x.push(_),
                Wt(t, e, 0, w.sortObjects),
                _.finish(),
                !0 === w.sortObjects && _.sort(H, V),
                !0 === Z && St.beginShadows();
                const n = y.state.shadowsArray;
                if (Et.render(n, t, e),
                !0 === Z && St.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                At.render(_, t),
                y.setupLights(w.physicallyCorrectLights),
                e.isArrayCamera) {
                    const n = e.cameras;
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        Xt(_, t, r, r.viewport)
                    }
                } else
                    Xt(_, t, e);
                null !== D && (ot.updateMultisampleRenderTarget(D),
                ot.updateRenderTargetMipmap(D)),
                !0 === t.isScene && t.onAfterRender(w, t, e),
                it.buffers.depth.setTest(!0),
                it.buffers.depth.setMask(!0),
                it.buffers.color.setMask(!0),
                it.setPolygonOffset(!1),
                Dt.resetDefaultState(),
                I = -1,
                N = null,
                b.pop(),
                y = b.length > 0 ? b[b.length - 1] : null,
                x.pop(),
                _ = x.length > 0 ? x[x.length - 1] : null
            }
            ,
            this.getActiveCubeFace = function() {
                return P
            }
            ,
            this.getActiveMipmapLevel = function() {
                return C
            }
            ,
            this.getRenderTarget = function() {
                return D
            }
            ,
            this.setRenderTarget = function(t, e=0, n=0) {
                D = t,
                P = e,
                C = n,
                t && void 0 === at.get(t).__webglFramebuffer && ot.setupRenderTarget(t);
                let r = null
                  , i = !1
                  , s = !1;
                if (t) {
                    const n = t.texture;
                    (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                    const a = at.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (r = a[e],
                    i = !0) : r = t.isWebGLMultisampleRenderTarget ? at.get(t).__webglMultisampledFramebuffer : a,
                    F.copy(t.viewport),
                    U.copy(t.scissor),
                    z = t.scissorTest
                } else
                    F.copy(W).multiplyScalar(G).floor(),
                    U.copy(X).multiplyScalar(G).floor(),
                    z = j;
                if (it.bindFramebuffer(It.FRAMEBUFFER, r) && rt.drawBuffers) {
                    let e = !1;
                    if (t)
                        if (t.isWebGLMultipleRenderTargets) {
                            const n = t.texture;
                            if (Y.length !== n.length || Y[0] !== It.COLOR_ATTACHMENT0) {
                                for (let t = 0, e = n.length; t < e; t++)
                                    Y[t] = It.COLOR_ATTACHMENT0 + t;
                                Y.length = n.length,
                                e = !0
                            }
                        } else
                            1 === Y.length && Y[0] === It.COLOR_ATTACHMENT0 || (Y[0] = It.COLOR_ATTACHMENT0,
                            Y.length = 1,
                            e = !0);
                    else
                        1 === Y.length && Y[0] === It.BACK || (Y[0] = It.BACK,
                        Y.length = 1,
                        e = !0);
                    e && (rt.isWebGL2 ? It.drawBuffers(Y) : nt.get("WEBGL_draw_buffers").drawBuffersWEBGL(Y))
                }
                if (it.viewport(F),
                it.scissor(U),
                it.setScissorTest(z),
                i) {
                    const r = at.get(t.texture);
                    It.framebufferTexture2D(It.FRAMEBUFFER, It.COLOR_ATTACHMENT0, It.TEXTURE_CUBE_MAP_POSITIVE_X + e, r.__webglTexture, n)
                } else if (s) {
                    const r = at.get(t.texture)
                      , i = e || 0;
                    It.framebufferTextureLayer(It.FRAMEBUFFER, It.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i)
                }
                I = -1
            }
            ,
            this.readRenderTargetPixels = function(t, e, n, i, s, a, o) {
                if (!t || !t.isWebGLRenderTarget)
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let l = at.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== o && (l = l[o]),
                l) {
                    it.bindFramebuffer(It.FRAMEBUFFER, l);
                    try {
                        const o = t.texture
                          , l = o.format
                          , c = o.type;
                        if (l !== r.wk1 && Ct.convert(l) !== It.getParameter(It.IMPLEMENTATION_COLOR_READ_FORMAT))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const u = c === r.cLu && (nt.has("EXT_color_buffer_half_float") || rt.isWebGL2 && nt.has("EXT_color_buffer_float"));
                        if (!(c === r.ywz || Ct.convert(c) === It.getParameter(It.IMPLEMENTATION_COLOR_READ_TYPE) || c === r.VzW && (rt.isWebGL2 || nt.has("OES_texture_float") || nt.has("WEBGL_color_buffer_float")) || u))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        It.checkFramebufferStatus(It.FRAMEBUFFER) === It.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - s && It.readPixels(e, n, i, s, Ct.convert(l), Ct.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const t = null !== D ? at.get(D).__webglFramebuffer : null;
                        it.bindFramebuffer(It.FRAMEBUFFER, t)
                    }
                }
            }
            ,
            this.copyFramebufferToTexture = function(t, e, n=0) {
                const r = Math.pow(2, -n)
                  , i = Math.floor(e.image.width * r)
                  , s = Math.floor(e.image.height * r);
                let a = Ct.convert(e.format);
                rt.isWebGL2 && (a === It.RGB && (a = It.RGB8),
                a === It.RGBA && (a = It.RGBA8)),
                ot.setTexture2D(e, 0),
                It.copyTexImage2D(It.TEXTURE_2D, n, a, t.x, t.y, i, s, 0),
                it.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(t, e, n, r=0) {
                const i = e.image.width
                  , s = e.image.height
                  , a = Ct.convert(n.format)
                  , o = Ct.convert(n.type);
                ot.setTexture2D(n, 0),
                It.pixelStorei(It.UNPACK_FLIP_Y_WEBGL, n.flipY),
                It.pixelStorei(It.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                It.pixelStorei(It.UNPACK_ALIGNMENT, n.unpackAlignment),
                e.isDataTexture ? It.texSubImage2D(It.TEXTURE_2D, r, t.x, t.y, i, s, a, o, e.image.data) : e.isCompressedTexture ? It.compressedTexSubImage2D(It.TEXTURE_2D, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : It.texSubImage2D(It.TEXTURE_2D, r, t.x, t.y, a, o, e.image),
                0 === r && n.generateMipmaps && It.generateMipmap(It.TEXTURE_2D),
                it.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(t, e, n, r, i=0) {
                if (w.isWebGL1Renderer)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const s = t.max.x - t.min.x + 1
                  , a = t.max.y - t.min.y + 1
                  , o = t.max.z - t.min.z + 1
                  , l = Ct.convert(r.format)
                  , c = Ct.convert(r.type);
                let u;
                if (r.isDataTexture3D)
                    ot.setTexture3D(r, 0),
                    u = It.TEXTURE_3D;
                else {
                    if (!r.isDataTexture2DArray)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    ot.setTexture2DArray(r, 0),
                    u = It.TEXTURE_2D_ARRAY
                }
                It.pixelStorei(It.UNPACK_FLIP_Y_WEBGL, r.flipY),
                It.pixelStorei(It.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                It.pixelStorei(It.UNPACK_ALIGNMENT, r.unpackAlignment);
                const h = It.getParameter(It.UNPACK_ROW_LENGTH)
                  , d = It.getParameter(It.UNPACK_IMAGE_HEIGHT)
                  , f = It.getParameter(It.UNPACK_SKIP_PIXELS)
                  , p = It.getParameter(It.UNPACK_SKIP_ROWS)
                  , m = It.getParameter(It.UNPACK_SKIP_IMAGES)
                  , g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                It.pixelStorei(It.UNPACK_ROW_LENGTH, g.width),
                It.pixelStorei(It.UNPACK_IMAGE_HEIGHT, g.height),
                It.pixelStorei(It.UNPACK_SKIP_PIXELS, t.min.x),
                It.pixelStorei(It.UNPACK_SKIP_ROWS, t.min.y),
                It.pixelStorei(It.UNPACK_SKIP_IMAGES, t.min.z),
                n.isDataTexture || n.isDataTexture3D ? It.texSubImage3D(u, i, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                It.compressedTexSubImage3D(u, i, e.x, e.y, e.z, s, a, o, l, g.data)) : It.texSubImage3D(u, i, e.x, e.y, e.z, s, a, o, l, c, g),
                It.pixelStorei(It.UNPACK_ROW_LENGTH, h),
                It.pixelStorei(It.UNPACK_IMAGE_HEIGHT, d),
                It.pixelStorei(It.UNPACK_SKIP_PIXELS, f),
                It.pixelStorei(It.UNPACK_SKIP_ROWS, p),
                It.pixelStorei(It.UNPACK_SKIP_IMAGES, m),
                0 === i && r.generateMipmaps && It.generateMipmap(u),
                it.unbindTexture()
            }
            ,
            this.initTexture = function(t) {
                ot.setTexture2D(t, 0),
                it.unbindTexture()
            }
            ,
            this.resetState = function() {
                P = 0,
                C = 0,
                D = null,
                it.reset(),
                Dt.reset()
            }
            ,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
    },
    6682: function(t, e, n) {
        function r(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const r in t[n]) {
                    const i = t[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                }
            }
            return e
        }
        function i(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = r(t[n]);
                for (const t in i)
                    e[t] = i[t]
            }
            return e
        }
        n.d(e, {
            Rh: function() {
                return i
            },
            dw: function() {
                return r
            },
            rD: function() {
                return s
            }
        });
        const s = {
            clone: r,
            merge: i
        }
    },
    7365: function(t, e, n) {
        n.d(e, {
            x: function() {
                return i
            }
        });
        var r = n(4291);
        class i extends r.T {
            constructor() {
                super(),
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.overrideMaterial = null,
                this.autoUpdate = !0,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.autoUpdate = t.autoUpdate,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()),
                e
            }
        }
        i.prototype.isScene = !0
    },
    3882: function(t, e, n) {
        n.d(e, {
            B: function() {
                return s
            }
        });
        var r = n(1244)
          , i = n(1661);
        class s extends r.x {
            constructor(t, e, n, r, s, a, o, l, c, u) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : i.fY$, n, r, s, a, o = void 0 !== o ? o : i.UCm, l, c, u),
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        s.prototype.isCubeTexture = !0
    },
    3993: function(t, e, n) {
        n.d(e, {
            I: function() {
                return s
            }
        });
        var r = n(1244)
          , i = n(1661);
        class s extends r.x {
            constructor(t=null, e=1, n=1, r, s, a, o, l, c=i.TyD, u=i.TyD, h, d) {
                super(null, a, o, l, c, u, r, s, h, d),
                this.image = {
                    data: t,
                    width: e,
                    height: n
                },
                this.magFilter = c,
                this.minFilter = u,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        s.prototype.isDataTexture = !0
    },
    1244: function(t, e, n) {
        n.d(e, {
            x: function() {
                return h
            }
        });
        var r = n(7406)
          , i = n(1661)
          , s = n(2043)
          , a = n(1138)
          , o = n(1273);
        let l;
        class c {
            static getDataURL(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === l && (l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                    l.width = t.width,
                    l.height = t.height;
                    const n = l.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                    e = l
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
                e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
        }
        let u = 0;
        class h extends r.p {
            constructor(t=h.DEFAULT_IMAGE, e=h.DEFAULT_MAPPING, n=i.uWy, r=i.uWy, l=i.wem, c=i.D1R, d=i.wk1, f=i.ywz, p=1, m=i.rnI) {
                super(),
                Object.defineProperty(this, "id", {
                    value: u++
                }),
                this.uuid = s.DO(),
                this.name = "",
                this.image = t,
                this.mipmaps = [],
                this.mapping = e,
                this.wrapS = n,
                this.wrapT = r,
                this.magFilter = l,
                this.minFilter = c,
                this.anisotropy = p,
                this.format = d,
                this.internalFormat = null,
                this.type = f,
                this.offset = new a.F(0,0),
                this.repeat = new a.F(1,1),
                this.center = new a.F(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new o.V,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.encoding = m,
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                this.image = t.image,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.internalFormat = t.internalFormat,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                this.rotation = t.rotation,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrix.copy(t.matrix),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this.encoding = t.encoding,
                this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const r = this.image;
                    if (void 0 === r.uuid && (r.uuid = s.DO()),
                    !e && void 0 === t.images[r.uuid]) {
                        let e;
                        if (Array.isArray(r)) {
                            e = [];
                            for (let t = 0, n = r.length; t < n; t++)
                                r[t].isDataTexture ? e.push(d(r[t].image)) : e.push(d(r[t]))
                        } else
                            e = d(r);
                        t.images[r.uuid] = {
                            uuid: r.uuid,
                            url: e
                        }
                    }
                    n.image = r.uuid
                }
                return e || (t.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (this.mapping !== i.xfE)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case i.rpg:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case i.uWy:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case i.OoA:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case i.rpg:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case i.uWy:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case i.OoA:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                return this.flipY && (t.y = 1 - t.y),
                t
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        function d(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? c.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        h.DEFAULT_IMAGE = void 0,
        h.DEFAULT_MAPPING = i.xfE,
        h.prototype.isTexture = !0
    },
    2250: function(t, e, n) {
        n.d(e, {
            f: function() {
                return s
            }
        });
        var r = n(1661)
          , i = n(1244);
        class s extends i.x {
            constructor(t, e, n, i, s, a, o, l, c) {
                super(t, e, n, i, s, a, o, l, c),
                this.format = void 0 !== o ? o : r.UCm,
                this.minFilter = void 0 !== a ? a : r.wem,
                this.magFilter = void 0 !== s ? s : r.wem,
                this.generateMipmaps = !1;
                const u = this;
                "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                    u.needsUpdate = !0,
                    t.requestVideoFrameCallback(e)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 === "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        s.prototype.isVideoTexture = !0
    },
    392: function(t, e, n) {
        function r(t) {
            if (0 === t.length)
                return -1 / 0;
            let e = t[0];
            for (let n = 1, r = t.length; n < r; ++n)
                t[n] > e && (e = t[n]);
            return e
        }
        n.d(e, {
            uH: function() {
                return r
            }
        });
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
    },
    2854: function(t, e, n) {
        n.d(e, {
            _: function() {
                return l
            }
        });
        var r = n(5183)
          , i = n(5092)
          , s = n(9046)
          , a = n(140);
        const o = new WeakMap;
        class l extends r.a {
            constructor(t) {
                super(t),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(t) {
                return this.decoderPath = t,
                this
            }
            setDecoderConfig(t) {
                return this.decoderConfig = t,
                this
            }
            setWorkerLimit(t) {
                return this.workerLimit = t,
                this
            }
            load(t, e, n, r) {
                const s = new i.h(this.manager);
                s.setPath(this.path),
                s.setResponseType("arraybuffer"),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(t, (t=>{
                    const n = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: !1
                    };
                    this.decodeGeometry(t, n).then(e).catch(r)
                }
                ), n, r)
            }
            decodeDracoFile(t, e, n, r) {
                const i = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: r || this.defaultAttributeTypes,
                    useUniqueIDs: !!n
                };
                this.decodeGeometry(t, i).then(e)
            }
            decodeGeometry(t, e) {
                for (const t in e.attributeTypes) {
                    const n = e.attributeTypes[t];
                    void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name)
                }
                const n = JSON.stringify(e);
                if (o.has(t)) {
                    const e = o.get(t);
                    if (e.key === n)
                        return e.promise;
                    if (0 === t.byteLength)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let r;
                const i = this.workerNextTaskID++
                  , s = t.byteLength
                  , a = this._getWorker(i, s).then((n=>(r = n,
                new Promise(((n,s)=>{
                    r._callbacks[i] = {
                        resolve: n,
                        reject: s
                    },
                    r.postMessage({
                        type: "decode",
                        id: i,
                        taskConfig: e,
                        buffer: t
                    }, [t])
                }
                ))))).then((t=>this._createGeometry(t.geometry)));
                return a.catch((()=>!0)).then((()=>{
                    r && i && this._releaseTask(r, i)
                }
                )),
                o.set(t, {
                    key: n,
                    promise: a
                }),
                a
            }
            _createGeometry(t) {
                const e = new s.u;
                t.index && e.setIndex(new a.Tl(t.index.array,1));
                for (let n = 0; n < t.attributes.length; n++) {
                    const r = t.attributes[n]
                      , i = r.name
                      , s = r.array
                      , o = r.itemSize;
                    e.setAttribute(i, new a.Tl(s,o))
                }
                return e
            }
            _loadLibrary(t, e) {
                const n = new i.h(this.manager);
                return n.setPath(this.decoderPath),
                n.setResponseType(e),
                n.setWithCredentials(this.withCredentials),
                new Promise(((e,r)=>{
                    n.load(t, e, void 0, r)
                }
                ))
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                  , e = [];
                return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(e).then((e=>{
                    const n = e[0];
                    t || (this.decoderConfig.wasmBinary = e[1]);
                    const r = c.toString()
                      , i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                }
                )),
                this.decoderPending
            }
            _getWorker(t, e) {
                return this._initDecoder().then((()=>{
                    if (this.workerPool.length < this.workerLimit) {
                        const t = new Worker(this.workerSourceURL);
                        t._callbacks = {},
                        t._taskCosts = {},
                        t._taskLoad = 0,
                        t.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        t.onmessage = function(e) {
                            const n = e.data;
                            switch (n.type) {
                            case "decode":
                                t._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                t._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(t)
                    } else
                        this.workerPool.sort((function(t, e) {
                            return t._taskLoad > e._taskLoad ? -1 : 1
                        }
                        ));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[t] = e,
                    n._taskLoad += e,
                    n
                }
                ))
            }
            _releaseTask(t, e) {
                t._taskLoad -= t._taskCosts[e],
                delete t._callbacks[e],
                delete t._taskCosts[e]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((t=>t._taskLoad)))
            }
            dispose() {
                for (let t = 0; t < this.workerPool.length; ++t)
                    this.workerPool[t].terminate();
                return this.workerPool.length = 0,
                this
            }
        }
        function c() {
            let t, e;
            function n(t, e, n, r, i, s) {
                const a = s.num_components()
                  , o = n.num_points() * a
                  , l = o * i.BYTES_PER_ELEMENT
                  , c = function(t, e) {
                    switch (e) {
                    case Float32Array:
                        return t.DT_FLOAT32;
                    case Int8Array:
                        return t.DT_INT8;
                    case Int16Array:
                        return t.DT_INT16;
                    case Int32Array:
                        return t.DT_INT32;
                    case Uint8Array:
                        return t.DT_UINT8;
                    case Uint16Array:
                        return t.DT_UINT16;
                    case Uint32Array:
                        return t.DT_UINT32
                    }
                }(t, i)
                  , u = t._malloc(l);
                e.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
                const h = new i(t.HEAPF32.buffer,u,o).slice();
                return t._free(u),
                {
                    name: r,
                    array: h,
                    itemSize: a
                }
            }
            onmessage = function(r) {
                const i = r.data;
                switch (i.type) {
                case "init":
                    t = i.decoderConfig,
                    e = new Promise((function(e) {
                        t.onModuleLoaded = function(t) {
                            e({
                                draco: t
                            })
                        }
                        ,
                        DracoDecoderModule(t)
                    }
                    ));
                    break;
                case "decode":
                    const r = i.buffer
                      , s = i.taskConfig;
                    e.then((t=>{
                        const e = t.draco
                          , a = new e.Decoder
                          , o = new e.DecoderBuffer;
                        o.Init(new Int8Array(r), r.byteLength);
                        try {
                            const t = function(t, e, r, i) {
                                const s = i.attributeIDs
                                  , a = i.attributeTypes;
                                let o, l;
                                const c = e.GetEncodedGeometryType(r);
                                if (c === t.TRIANGULAR_MESH)
                                    o = new t.Mesh,
                                    l = e.DecodeBufferToMesh(r, o);
                                else {
                                    if (c !== t.POINT_CLOUD)
                                        throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                    o = new t.PointCloud,
                                    l = e.DecodeBufferToPointCloud(r, o)
                                }
                                if (!l.ok() || 0 === o.ptr)
                                    throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                const u = {
                                    index: null,
                                    attributes: []
                                };
                                for (const r in s) {
                                    const l = self[a[r]];
                                    let c, h;
                                    if (i.useUniqueIDs)
                                        h = s[r],
                                        c = e.GetAttributeByUniqueId(o, h);
                                    else {
                                        if (h = e.GetAttributeId(o, t[s[r]]),
                                        -1 === h)
                                            continue;
                                        c = e.GetAttribute(o, h)
                                    }
                                    u.attributes.push(n(t, e, o, r, l, c))
                                }
                                c === t.TRIANGULAR_MESH && (u.index = function(t, e, n) {
                                    const r = n.num_faces()
                                      , i = 3 * r
                                      , s = 4 * i
                                      , a = t._malloc(s);
                                    e.GetTrianglesUInt32Array(n, s, a);
                                    const o = new Uint32Array(t.HEAPF32.buffer,a,i).slice();
                                    return t._free(a),
                                    {
                                        array: o,
                                        itemSize: 1
                                    }
                                }(t, e, o));
                                return t.destroy(o),
                                u
                            }(e, a, o, s)
                              , r = t.attributes.map((t=>t.array.buffer));
                            t.index && r.push(t.index.array.buffer),
                            self.postMessage({
                                type: "decode",
                                id: i.id,
                                geometry: t
                            }, r)
                        } catch (t) {
                            console.error(t),
                            self.postMessage({
                                type: "error",
                                id: i.id,
                                error: t.message
                            })
                        } finally {
                            e.destroy(o),
                            e.destroy(a)
                        }
                    }
                    ))
                }
            }
        }
    },
    4858: function(t, e, n) {
        n.d(e, {
            I: function() {
                return Ie
            }
        });
        var r = {};
        n.r(r),
        n.d(r, {
            AsyncCompress: function() {
                return kt
            },
            AsyncDecompress: function() {
                return ne
            },
            AsyncDeflate: function() {
                return Dt
            },
            AsyncGunzip: function() {
                return Wt
            },
            AsyncGzip: function() {
                return kt
            },
            AsyncInflate: function() {
                return Ot
            },
            AsyncUnzipInflate: function() {
                return Le
            },
            AsyncUnzlib: function() {
                return Qt
            },
            AsyncZipDeflate: function() {
                return Me
            },
            AsyncZlib: function() {
                return qt
            },
            Compress: function() {
                return Bt
            },
            DecodeUTF8: function() {
                return ue
            },
            Decompress: function() {
                return ee
            },
            Deflate: function() {
                return Ct
            },
            EncodeUTF8: function() {
                return he
            },
            Gunzip: function() {
                return Vt
            },
            Gzip: function() {
                return Bt
            },
            Inflate: function() {
                return Ft
            },
            Unzip: function() {
                return Pe
            },
            UnzipInflate: function() {
                return Re
            },
            UnzipPassThrough: function() {
                return Ae
            },
            Unzlib: function() {
                return Jt
            },
            Zip: function() {
                return Te
            },
            ZipDeflate: function() {
                return we
            },
            ZipPassThrough: function() {
                return be
            },
            Zlib: function() {
                return Yt
            },
            compress: function() {
                return Gt
            },
            compressSync: function() {
                return Ht
            },
            decompress: function() {
                return re
            },
            decompressSync: function() {
                return ie
            },
            deflate: function() {
                return It
            },
            deflateSync: function() {
                return Nt
            },
            gunzip: function() {
                return Xt
            },
            gunzipSync: function() {
                return jt
            },
            gzip: function() {
                return Gt
            },
            gzipSync: function() {
                return Ht
            },
            inflate: function() {
                return Ut
            },
            inflateSync: function() {
                return zt
            },
            strFromU8: function() {
                return fe
            },
            strToU8: function() {
                return de
            },
            unzip: function() {
                return Ce
            },
            unzipSync: function() {
                return De
            },
            unzlib: function() {
                return $t
            },
            unzlibSync: function() {
                return te
            },
            zip: function() {
                return Se
            },
            zipSync: function() {
                return Ee
            },
            zlib: function() {
                return Zt
            },
            zlibSync: function() {
                return Kt
            }
        });
        var i = n(1661)
          , s = n(5092)
          , a = n(3993)
          , o = n(5183);
        class l extends o.a {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const o = this
                  , l = new a.I
                  , c = new s.h(this.manager);
                return c.setResponseType("arraybuffer"),
                c.setRequestHeader(this.requestHeader),
                c.setPath(this.path),
                c.setWithCredentials(o.withCredentials),
                c.load(t, (function(t) {
                    const n = o.parse(t);
                    n && (void 0 !== n.image ? l.image = n.image : void 0 !== n.data && (l.image.width = n.width,
                    l.image.height = n.height,
                    l.image.data = n.data),
                    l.wrapS = void 0 !== n.wrapS ? n.wrapS : i.uWy,
                    l.wrapT = void 0 !== n.wrapT ? n.wrapT : i.uWy,
                    l.magFilter = void 0 !== n.magFilter ? n.magFilter : i.wem,
                    l.minFilter = void 0 !== n.minFilter ? n.minFilter : i.wem,
                    l.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                    void 0 !== n.encoding && (l.encoding = n.encoding),
                    void 0 !== n.flipY && (l.flipY = n.flipY),
                    void 0 !== n.format && (l.format = n.format),
                    void 0 !== n.type && (l.type = n.type),
                    void 0 !== n.mipmaps && (l.mipmaps = n.mipmaps,
                    l.minFilter = i.D1R),
                    1 === n.mipmapCount && (l.minFilter = i.wem),
                    void 0 !== n.generateMipmaps && (l.generateMipmaps = n.generateMipmaps),
                    l.needsUpdate = !0,
                    e && e(l, n))
                }
                ), n, r),
                l
            }
        }
        const c = new Float32Array(1)
          , u = new Int32Array(c.buffer);
        class h {
            static toHalfFloat(t) {
                c[0] = t;
                const e = u[0];
                let n = e >> 16 & 32768
                  , r = e >> 12 & 2047;
                const i = e >> 23 & 255;
                return i < 103 ? n : i > 142 ? (n |= 31744,
                n |= (255 == i ? 0 : 1) && 8388607 & e,
                n) : i < 113 ? (r |= 2048,
                n |= (r >> 114 - i) + (r >> 113 - i & 1),
                n) : (n |= i - 112 << 10 | r >> 1,
                n += 1 & r,
                n)
            }
        }
        var d = {}
          , f = function(t) {
            return URL.createObjectURL(new Blob([t],{
                type: "text/javascript"
            }))
        }
          , p = function(t) {
            return new Worker(t)
        };
        try {
            URL.revokeObjectURL(f(""))
        } catch (t) {
            f = function(t) {
                return "data:application/javascript;charset=UTF-8," + encodeURI(t)
            }
            ,
            p = function(t) {
                return new Worker(t,{
                    type: "module"
                })
            }
        }
        var m = Uint8Array
          , g = Uint16Array
          , v = Uint32Array
          , _ = new m([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
          , y = new m([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
          , x = new m([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , b = function(t, e) {
            for (var n = new g(31), r = 0; r < 31; ++r)
                n[r] = e += 1 << t[r - 1];
            var i = new v(n[30]);
            for (r = 1; r < 30; ++r)
                for (var s = n[r]; s < n[r + 1]; ++s)
                    i[s] = s - n[r] << 5 | r;
            return [n, i]
        }
          , w = b(_, 2)
          , M = w[0]
          , T = w[1];
        M[28] = 258,
        T[258] = 28;
        for (var S = b(y, 0), E = S[0], A = S[1], R = new g(32768), L = 0; L < 32768; ++L) {
            var P = (43690 & L) >>> 1 | (21845 & L) << 1;
            P = (61680 & (P = (52428 & P) >>> 2 | (13107 & P) << 2)) >>> 4 | (3855 & P) << 4,
            R[L] = ((65280 & P) >>> 8 | (255 & P) << 8) >>> 1
        }
        var C = function(t, e, n) {
            for (var r = t.length, i = 0, s = new g(e); i < r; ++i)
                ++s[t[i] - 1];
            var a, o = new g(e);
            for (i = 0; i < e; ++i)
                o[i] = o[i - 1] + s[i - 1] << 1;
            if (n) {
                a = new g(1 << e);
                var l = 15 - e;
                for (i = 0; i < r; ++i)
                    if (t[i])
                        for (var c = i << 4 | t[i], u = e - t[i], h = o[t[i] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
                            a[R[h] >>> l] = c
            } else
                for (a = new g(r),
                i = 0; i < r; ++i)
                    t[i] && (a[i] = R[o[t[i] - 1]++] >>> 15 - t[i]);
            return a
        }
          , D = new m(288);
        for (L = 0; L < 144; ++L)
            D[L] = 8;
        for (L = 144; L < 256; ++L)
            D[L] = 9;
        for (L = 256; L < 280; ++L)
            D[L] = 7;
        for (L = 280; L < 288; ++L)
            D[L] = 8;
        var I = new m(32);
        for (L = 0; L < 32; ++L)
            I[L] = 5;
        var N = C(D, 9, 0)
          , F = C(D, 9, 1)
          , O = C(I, 5, 0)
          , U = C(I, 5, 1)
          , z = function(t) {
            for (var e = t[0], n = 1; n < t.length; ++n)
                t[n] > e && (e = t[n]);
            return e
        }
          , B = function(t, e, n) {
            var r = e / 8 | 0;
            return (t[r] | t[r + 1] << 8) >> (7 & e) & n
        }
          , k = function(t, e) {
            var n = e / 8 | 0;
            return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (7 & e)
        }
          , G = function(t) {
            return (t / 8 | 0) + (7 & t && 1)
        }
          , H = function(t, e, n) {
            (null == e || e < 0) && (e = 0),
            (null == n || n > t.length) && (n = t.length);
            var r = new (t instanceof g ? g : t instanceof v ? v : m)(n - e);
            return r.set(t.subarray(e, n)),
            r
        }
          , V = function(t, e, n) {
            var r = t.length;
            if (!r || n && !n.l && r < 5)
                return e || new m(0);
            var i = !e || n
              , s = !n || n.i;
            n || (n = {}),
            e || (e = new m(3 * r));
            var a = function(t) {
                var n = e.length;
                if (t > n) {
                    var r = new m(Math.max(2 * n, t));
                    r.set(e),
                    e = r
                }
            }
              , o = n.f || 0
              , l = n.p || 0
              , c = n.b || 0
              , u = n.l
              , h = n.d
              , d = n.m
              , f = n.n
              , p = 8 * r;
            do {
                if (!u) {
                    n.f = o = B(t, l, 1);
                    var g = B(t, l + 1, 3);
                    if (l += 3,
                    !g) {
                        var v = t[(N = G(l) + 4) - 4] | t[N - 3] << 8
                          , b = N + v;
                        if (b > r) {
                            if (s)
                                throw "unexpected EOF";
                            break
                        }
                        i && a(c + v),
                        e.set(t.subarray(N, b), c),
                        n.b = c += v,
                        n.p = l = 8 * b;
                        continue
                    }
                    if (1 == g)
                        u = F,
                        h = U,
                        d = 9,
                        f = 5;
                    else {
                        if (2 != g)
                            throw "invalid block type";
                        var w = B(t, l, 31) + 257
                          , T = B(t, l + 10, 15) + 4
                          , S = w + B(t, l + 5, 31) + 1;
                        l += 14;
                        for (var A = new m(S), R = new m(19), L = 0; L < T; ++L)
                            R[x[L]] = B(t, l + 3 * L, 7);
                        l += 3 * T;
                        var P = z(R)
                          , D = (1 << P) - 1
                          , I = C(R, P, 1);
                        for (L = 0; L < S; ) {
                            var N, O = I[B(t, l, D)];
                            if (l += 15 & O,
                            (N = O >>> 4) < 16)
                                A[L++] = N;
                            else {
                                var V = 0
                                  , W = 0;
                                for (16 == N ? (W = 3 + B(t, l, 3),
                                l += 2,
                                V = A[L - 1]) : 17 == N ? (W = 3 + B(t, l, 7),
                                l += 3) : 18 == N && (W = 11 + B(t, l, 127),
                                l += 7); W--; )
                                    A[L++] = V
                            }
                        }
                        var X = A.subarray(0, w)
                          , j = A.subarray(w);
                        d = z(X),
                        f = z(j),
                        u = C(X, d, 1),
                        h = C(j, f, 1)
                    }
                    if (l > p) {
                        if (s)
                            throw "unexpected EOF";
                        break
                    }
                }
                i && a(c + 131072);
                for (var Y = (1 << d) - 1, q = (1 << f) - 1, Z = l; ; Z = l) {
                    var K = (V = u[k(t, l) & Y]) >>> 4;
                    if ((l += 15 & V) > p) {
                        if (s)
                            throw "unexpected EOF";
                        break
                    }
                    if (!V)
                        throw "invalid length/literal";
                    if (K < 256)
                        e[c++] = K;
                    else {
                        if (256 == K) {
                            Z = l,
                            u = null;
                            break
                        }
                        var J = K - 254;
                        if (K > 264) {
                            var Q = _[L = K - 257];
                            J = B(t, l, (1 << Q) - 1) + M[L],
                            l += Q
                        }
                        var $ = h[k(t, l) & q]
                          , tt = $ >>> 4;
                        if (!$)
                            throw "invalid distance";
                        l += 15 & $;
                        j = E[tt];
                        if (tt > 3) {
                            Q = y[tt];
                            j += k(t, l) & (1 << Q) - 1,
                            l += Q
                        }
                        if (l > p) {
                            if (s)
                                throw "unexpected EOF";
                            break
                        }
                        i && a(c + 131072);
                        for (var et = c + J; c < et; c += 4)
                            e[c] = e[c - j],
                            e[c + 1] = e[c + 1 - j],
                            e[c + 2] = e[c + 2 - j],
                            e[c + 3] = e[c + 3 - j];
                        c = et
                    }
                }
                n.l = u,
                n.p = Z,
                n.b = c,
                u && (o = 1,
                n.m = d,
                n.d = h,
                n.n = f)
            } while (!o);
            return c == e.length ? e : H(e, 0, c)
        }
          , W = function(t, e, n) {
            n <<= 7 & e;
            var r = e / 8 | 0;
            t[r] |= n,
            t[r + 1] |= n >>> 8
        }
          , X = function(t, e, n) {
            n <<= 7 & e;
            var r = e / 8 | 0;
            t[r] |= n,
            t[r + 1] |= n >>> 8,
            t[r + 2] |= n >>> 16
        }
          , j = function(t, e) {
            for (var n = [], r = 0; r < t.length; ++r)
                t[r] && n.push({
                    s: r,
                    f: t[r]
                });
            var i = n.length
              , s = n.slice();
            if (!i)
                return [$, 0];
            if (1 == i) {
                var a = new m(n[0].s + 1);
                return a[n[0].s] = 1,
                [a, 1]
            }
            n.sort((function(t, e) {
                return t.f - e.f
            }
            )),
            n.push({
                s: -1,
                f: 25001
            });
            var o = n[0]
              , l = n[1]
              , c = 0
              , u = 1
              , h = 2;
            for (n[0] = {
                s: -1,
                f: o.f + l.f,
                l: o,
                r: l
            }; u != i - 1; )
                o = n[n[c].f < n[h].f ? c++ : h++],
                l = n[c != u && n[c].f < n[h].f ? c++ : h++],
                n[u++] = {
                    s: -1,
                    f: o.f + l.f,
                    l: o,
                    r: l
                };
            var d = s[0].s;
            for (r = 1; r < i; ++r)
                s[r].s > d && (d = s[r].s);
            var f = new g(d + 1)
              , p = Y(n[u - 1], f, 0);
            if (p > e) {
                r = 0;
                var v = 0
                  , _ = p - e
                  , y = 1 << _;
                for (s.sort((function(t, e) {
                    return f[e.s] - f[t.s] || t.f - e.f
                }
                )); r < i; ++r) {
                    var x = s[r].s;
                    if (!(f[x] > e))
                        break;
                    v += y - (1 << p - f[x]),
                    f[x] = e
                }
                for (v >>>= _; v > 0; ) {
                    var b = s[r].s;
                    f[b] < e ? v -= 1 << e - f[b]++ - 1 : ++r
                }
                for (; r >= 0 && v; --r) {
                    var w = s[r].s;
                    f[w] == e && (--f[w],
                    ++v)
                }
                p = e
            }
            return [new m(f), p]
        }
          , Y = function(t, e, n) {
            return -1 == t.s ? Math.max(Y(t.l, e, n + 1), Y(t.r, e, n + 1)) : e[t.s] = n
        }
          , q = function(t) {
            for (var e = t.length; e && !t[--e]; )
                ;
            for (var n = new g(++e), r = 0, i = t[0], s = 1, a = function(t) {
                n[r++] = t
            }, o = 1; o <= e; ++o)
                if (t[o] == i && o != e)
                    ++s;
                else {
                    if (!i && s > 2) {
                        for (; s > 138; s -= 138)
                            a(32754);
                        s > 2 && (a(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305),
                        s = 0)
                    } else if (s > 3) {
                        for (a(i),
                        --s; s > 6; s -= 6)
                            a(8304);
                        s > 2 && (a(s - 3 << 5 | 8208),
                        s = 0)
                    }
                    for (; s--; )
                        a(i);
                    s = 1,
                    i = t[o]
                }
            return [n.subarray(0, r), e]
        }
          , Z = function(t, e) {
            for (var n = 0, r = 0; r < e.length; ++r)
                n += t[r] * e[r];
            return n
        }
          , K = function(t, e, n) {
            var r = n.length
              , i = G(e + 2);
            t[i] = 255 & r,
            t[i + 1] = r >>> 8,
            t[i + 2] = 255 ^ t[i],
            t[i + 3] = 255 ^ t[i + 1];
            for (var s = 0; s < r; ++s)
                t[i + s + 4] = n[s];
            return 8 * (i + 4 + r)
        }
          , J = function(t, e, n, r, i, s, a, o, l, c, u) {
            W(e, u++, n),
            ++i[256];
            for (var h = j(i, 15), d = h[0], f = h[1], p = j(s, 15), m = p[0], v = p[1], b = q(d), w = b[0], M = b[1], T = q(m), S = T[0], E = T[1], A = new g(19), R = 0; R < w.length; ++R)
                A[31 & w[R]]++;
            for (R = 0; R < S.length; ++R)
                A[31 & S[R]]++;
            for (var L = j(A, 7), P = L[0], F = L[1], U = 19; U > 4 && !P[x[U - 1]]; --U)
                ;
            var z, B, k, G, H = c + 5 << 3, V = Z(i, D) + Z(s, I) + a, Y = Z(i, d) + Z(s, m) + a + 14 + 3 * U + Z(A, P) + (2 * A[16] + 3 * A[17] + 7 * A[18]);
            if (H <= V && H <= Y)
                return K(e, u, t.subarray(l, l + c));
            if (W(e, u, 1 + (Y < V)),
            u += 2,
            Y < V) {
                z = C(d, f, 0),
                B = d,
                k = C(m, v, 0),
                G = m;
                var J = C(P, F, 0);
                W(e, u, M - 257),
                W(e, u + 5, E - 1),
                W(e, u + 10, U - 4),
                u += 14;
                for (R = 0; R < U; ++R)
                    W(e, u + 3 * R, P[x[R]]);
                u += 3 * U;
                for (var Q = [w, S], $ = 0; $ < 2; ++$) {
                    var tt = Q[$];
                    for (R = 0; R < tt.length; ++R) {
                        var et = 31 & tt[R];
                        W(e, u, J[et]),
                        u += P[et],
                        et > 15 && (W(e, u, tt[R] >>> 5 & 127),
                        u += tt[R] >>> 12)
                    }
                }
            } else
                z = N,
                B = D,
                k = O,
                G = I;
            for (R = 0; R < o; ++R)
                if (r[R] > 255) {
                    et = r[R] >>> 18 & 31;
                    X(e, u, z[et + 257]),
                    u += B[et + 257],
                    et > 7 && (W(e, u, r[R] >>> 23 & 31),
                    u += _[et]);
                    var nt = 31 & r[R];
                    X(e, u, k[nt]),
                    u += G[nt],
                    nt > 3 && (X(e, u, r[R] >>> 5 & 8191),
                    u += y[nt])
                } else
                    X(e, u, z[r[R]]),
                    u += B[r[R]];
            return X(e, u, z[256]),
            u + B[256]
        }
          , Q = new v([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
          , $ = new m(0)
          , tt = function(t, e, n, r, i, s) {
            var a = t.length
              , o = new m(r + a + 5 * (1 + Math.ceil(a / 7e3)) + i)
              , l = o.subarray(r, o.length - i)
              , c = 0;
            if (!e || a < 8)
                for (var u = 0; u <= a; u += 65535) {
                    var h = u + 65535;
                    h < a ? c = K(l, c, t.subarray(u, h)) : (l[u] = s,
                    c = K(l, c, t.subarray(u, a)))
                }
            else {
                for (var d = Q[e - 1], f = d >>> 13, p = 8191 & d, x = (1 << n) - 1, b = new g(32768), w = new g(x + 1), M = Math.ceil(n / 3), S = 2 * M, E = function(e) {
                    return (t[e] ^ t[e + 1] << M ^ t[e + 2] << S) & x
                }, R = new v(25e3), L = new g(288), P = new g(32), C = 0, D = 0, I = (u = 0,
                0), N = 0, F = 0; u < a; ++u) {
                    var O = E(u)
                      , U = 32767 & u
                      , z = w[O];
                    if (b[U] = z,
                    w[O] = U,
                    N <= u) {
                        var B = a - u;
                        if ((C > 7e3 || I > 24576) && B > 423) {
                            c = J(t, l, 0, R, L, P, D, I, F, u - F, c),
                            I = C = D = 0,
                            F = u;
                            for (var k = 0; k < 286; ++k)
                                L[k] = 0;
                            for (k = 0; k < 30; ++k)
                                P[k] = 0
                        }
                        var V = 2
                          , W = 0
                          , X = p
                          , j = U - z & 32767;
                        if (B > 2 && O == E(u - j))
                            for (var Y = Math.min(f, B) - 1, q = Math.min(32767, u), Z = Math.min(258, B); j <= q && --X && U != z; ) {
                                if (t[u + V] == t[u + V - j]) {
                                    for (var tt = 0; tt < Z && t[u + tt] == t[u + tt - j]; ++tt)
                                        ;
                                    if (tt > V) {
                                        if (V = tt,
                                        W = j,
                                        tt > Y)
                                            break;
                                        var et = Math.min(j, tt - 2)
                                          , nt = 0;
                                        for (k = 0; k < et; ++k) {
                                            var rt = u - j + k + 32768 & 32767
                                              , it = rt - b[rt] + 32768 & 32767;
                                            it > nt && (nt = it,
                                            z = rt)
                                        }
                                    }
                                }
                                j += (U = z) - (z = b[U]) + 32768 & 32767
                            }
                        if (W) {
                            R[I++] = 268435456 | T[V] << 18 | A[W];
                            var st = 31 & T[V]
                              , at = 31 & A[W];
                            D += _[st] + y[at],
                            ++L[257 + st],
                            ++P[at],
                            N = u + V,
                            ++C
                        } else
                            R[I++] = t[u],
                            ++L[t[u]]
                    }
                }
                c = J(t, l, s, R, L, P, D, I, F, u - F, c),
                !s && 7 & c && (c = K(l, c + 1, $))
            }
            return H(o, 0, r + G(c) + i)
        }
          , et = function() {
            for (var t = new v(256), e = 0; e < 256; ++e) {
                for (var n = e, r = 9; --r; )
                    n = (1 & n && 3988292384) ^ n >>> 1;
                t[e] = n
            }
            return t
        }()
          , nt = function() {
            var t = -1;
            return {
                p: function(e) {
                    for (var n = t, r = 0; r < e.length; ++r)
                        n = et[255 & n ^ e[r]] ^ n >>> 8;
                    t = n
                },
                d: function() {
                    return ~t
                }
            }
        }
          , rt = function() {
            var t = 1
              , e = 0;
            return {
                p: function(n) {
                    for (var r = t, i = e, s = n.length, a = 0; a != s; ) {
                        for (var o = Math.min(a + 2655, s); a < o; ++a)
                            i += r += n[a];
                        r = (65535 & r) + 15 * (r >> 16),
                        i = (65535 & i) + 15 * (i >> 16)
                    }
                    t = r,
                    e = i
                },
                d: function() {
                    return (255 & (t %= 65521)) << 24 | t >>> 8 << 16 | (255 & (e %= 65521)) << 8 | e >>> 8
                }
            }
        }
          , it = function(t, e, n, r, i) {
            return tt(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, n, r, !i)
        }
          , st = function(t, e) {
            var n = {};
            for (var r in t)
                n[r] = t[r];
            for (var r in e)
                n[r] = e[r];
            return n
        }
          , at = function(t, e, n) {
            for (var r = t(), i = t.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), a = 0; a < r.length; ++a) {
                var o = r[a]
                  , l = s[a];
                if ("function" == typeof o) {
                    e += ";" + l + "=";
                    var c = o.toString();
                    if (o.prototype)
                        if (-1 != c.indexOf("[native code]")) {
                            var u = c.indexOf(" ", 8) + 1;
                            e += c.slice(u, c.indexOf("(", u))
                        } else
                            for (var h in e += c,
                            o.prototype)
                                e += ";" + l + ".prototype." + h + "=" + o.prototype[h].toString();
                    else
                        e += c
                } else
                    n[l] = o
            }
            return [e, n]
        }
          , ot = []
          , lt = function(t, e, n, r) {
            var i;
            if (!ot[n]) {
                for (var s = "", a = {}, o = t.length - 1, l = 0; l < o; ++l)
                    s = (i = at(t[l], s, a))[0],
                    a = i[1];
                ot[n] = at(t[o], s, a)
            }
            var c = st({}, ot[n][1]);
            return function(t, e, n, r, i) {
                var s = p(d[e] || (d[e] = f(t)));
                return s.onerror = function(t) {
                    return i(t.error, null)
                }
                ,
                s.onmessage = function(t) {
                    return i(null, t.data)
                }
                ,
                s.postMessage(n, r),
                s
            }(ot[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", n, c, function(t) {
                var e = [];
                for (var n in t)
                    (t[n]instanceof m || t[n]instanceof g || t[n]instanceof v) && e.push((t[n] = new t[n].constructor(t[n])).buffer);
                return e
            }(c), r)
        }
          , ct = function() {
            return [m, g, v, _, y, x, M, E, F, U, R, C, z, B, k, G, H, V, zt, mt, gt]
        }
          , ut = function() {
            return [m, g, v, _, y, x, T, A, N, D, O, I, R, Q, $, C, W, X, j, Y, q, Z, K, J, G, H, tt, it, Nt, mt]
        }
          , ht = function() {
            return [Tt, At, Mt, nt, et]
        }
          , dt = function() {
            return [St, Et]
        }
          , ft = function() {
            return [Rt, Mt, rt]
        }
          , pt = function() {
            return [Lt]
        }
          , mt = function(t) {
            return postMessage(t, [t.buffer])
        }
          , gt = function(t) {
            return t && t.size && new m(t.size)
        }
          , vt = function(t, e, n, r, i, s) {
            var a = lt(n, r, i, (function(t, e) {
                a.terminate(),
                s(t, e)
            }
            ));
            return a.postMessage([t, e], e.consume ? [t.buffer] : []),
            function() {
                a.terminate()
            }
        }
          , _t = function(t) {
            return t.ondata = function(t, e) {
                return postMessage([t, e], [t.buffer])
            }
            ,
            function(e) {
                return t.push(e.data[0], e.data[1])
            }
        }
          , yt = function(t, e, n, r, i) {
            var s, a = lt(t, r, i, (function(t, n) {
                t ? (a.terminate(),
                e.ondata.call(e, t)) : (n[1] && a.terminate(),
                e.ondata.call(e, t, n[0], n[1]))
            }
            ));
            a.postMessage(n),
            e.push = function(t, n) {
                if (s)
                    throw "stream finished";
                if (!e.ondata)
                    throw "no stream handler";
                a.postMessage([t, s = n], [t.buffer])
            }
            ,
            e.terminate = function() {
                a.terminate()
            }
        }
          , xt = function(t, e) {
            return t[e] | t[e + 1] << 8
        }
          , bt = function(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0
        }
          , wt = function(t, e) {
            return bt(t, e) + 4294967296 * bt(t, e + 4)
        }
          , Mt = function(t, e, n) {
            for (; n; ++e)
                t[e] = n,
                n >>>= 8
        }
          , Tt = function(t, e) {
            var n = e.filename;
            if (t[0] = 31,
            t[1] = 139,
            t[2] = 8,
            t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0,
            t[9] = 3,
            0 != e.mtime && Mt(t, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
            n) {
                t[3] = 8;
                for (var r = 0; r <= n.length; ++r)
                    t[r + 10] = n.charCodeAt(r)
            }
        }
          , St = function(t) {
            if (31 != t[0] || 139 != t[1] || 8 != t[2])
                throw "invalid gzip data";
            var e = t[3]
              , n = 10;
            4 & e && (n += t[10] | 2 + (t[11] << 8));
            for (var r = (e >> 3 & 1) + (e >> 4 & 1); r > 0; r -= !t[n++])
                ;
            return n + (2 & e)
        }
          , Et = function(t) {
            var e = t.length;
            return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0
        }
          , At = function(t) {
            return 10 + (t.filename && t.filename.length + 1 || 0)
        }
          , Rt = function(t, e) {
            var n = e.level
              , r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
            t[0] = 120,
            t[1] = r << 6 | (r ? 32 - 2 * r : 1)
        }
          , Lt = function(t) {
            if (8 != (15 & t[0]) || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31)
                throw "invalid zlib data";
            if (32 & t[1])
                throw "invalid zlib data: preset dictionaries not supported"
        };
        function Pt(t, e) {
            return e || "function" != typeof t || (e = t,
            t = {}),
            this.ondata = e,
            t
        }
        var Ct = function() {
            function t(t, e) {
                e || "function" != typeof t || (e = t,
                t = {}),
                this.ondata = e,
                this.o = t || {}
            }
            return t.prototype.p = function(t, e) {
                this.ondata(it(t, this.o, 0, 0, !e), e)
            }
            ,
            t.prototype.push = function(t, e) {
                if (this.d)
                    throw "stream finished";
                if (!this.ondata)
                    throw "no stream handler";
                this.d = e,
                this.p(t, e || !1)
            }
            ,
            t
        }()
          , Dt = function() {
            return function(t, e) {
                yt([ut, function() {
                    return [_t, Ct]
                }
                ], this, Pt.call(this, t, e), (function(t) {
                    var e = new Ct(t.data);
                    onmessage = _t(e)
                }
                ), 6)
            }
        }();
        function It(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return vt(t, e, [ut], (function(t) {
                return mt(Nt(t.data[0], t.data[1]))
            }
            ), 0, n)
        }
        function Nt(t, e) {
            return it(t, e || {}, 0, 0)
        }
        var Ft = function() {
            function t(t) {
                this.s = {},
                this.p = new m(0),
                this.ondata = t
            }
            return t.prototype.e = function(t) {
                if (this.d)
                    throw "stream finished";
                if (!this.ondata)
                    throw "no stream handler";
                var e = this.p.length
                  , n = new m(e + t.length);
                n.set(this.p),
                n.set(t, e),
                this.p = n
            }
            ,
            t.prototype.c = function(t) {
                this.d = this.s.i = t || !1;
                var e = this.s.b
                  , n = V(this.p, this.o, this.s);
                this.ondata(H(n, e, this.s.b), this.d),
                this.o = H(n, this.s.b - 32768),
                this.s.b = this.o.length,
                this.p = H(this.p, this.s.p / 8 | 0),
                this.s.p &= 7
            }
            ,
            t.prototype.push = function(t, e) {
                this.e(t),
                this.c(e)
            }
            ,
            t
        }()
          , Ot = function() {
            return function(t) {
                this.ondata = t,
                yt([ct, function() {
                    return [_t, Ft]
                }
                ], this, 0, (function() {
                    var t = new Ft;
                    onmessage = _t(t)
                }
                ), 7)
            }
        }();
        function Ut(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return vt(t, e, [ct], (function(t) {
                return mt(zt(t.data[0], gt(t.data[1])))
            }
            ), 1, n)
        }
        function zt(t, e) {
            return V(t, e)
        }
        var Bt = function() {
            function t(t, e) {
                this.c = nt(),
                this.l = 0,
                this.v = 1,
                Ct.call(this, t, e)
            }
            return t.prototype.push = function(t, e) {
                Ct.prototype.push.call(this, t, e)
            }
            ,
            t.prototype.p = function(t, e) {
                this.c.p(t),
                this.l += t.length;
                var n = it(t, this.o, this.v && At(this.o), e && 8, !e);
                this.v && (Tt(n, this.o),
                this.v = 0),
                e && (Mt(n, n.length - 8, this.c.d()),
                Mt(n, n.length - 4, this.l)),
                this.ondata(n, e)
            }
            ,
            t
        }()
          , kt = function() {
            return function(t, e) {
                yt([ut, ht, function() {
                    return [_t, Ct, Bt]
                }
                ], this, Pt.call(this, t, e), (function(t) {
                    var e = new Bt(t.data);
                    onmessage = _t(e)
                }
                ), 8)
            }
        }();
        function Gt(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return vt(t, e, [ut, ht, function() {
                return [Ht]
            }
            ], (function(t) {
                return mt(Ht(t.data[0], t.data[1]))
            }
            ), 2, n)
        }
        function Ht(t, e) {
            e || (e = {});
            var n = nt()
              , r = t.length;
            n.p(t);
            var i = it(t, e, At(e), 8)
              , s = i.length;
            return Tt(i, e),
            Mt(i, s - 8, n.d()),
            Mt(i, s - 4, r),
            i
        }
        var Vt = function() {
            function t(t) {
                this.v = 1,
                Ft.call(this, t)
            }
            return t.prototype.push = function(t, e) {
                if (Ft.prototype.e.call(this, t),
                this.v) {
                    var n = this.p.length > 3 ? St(this.p) : 4;
                    if (n >= this.p.length && !e)
                        return;
                    this.p = this.p.subarray(n),
                    this.v = 0
                }
                if (e) {
                    if (this.p.length < 8)
                        throw "invalid gzip stream";
                    this.p = this.p.subarray(0, -8)
                }
                Ft.prototype.c.call(this, e)
            }
            ,
            t
        }()
          , Wt = function() {
            return function(t) {
                this.ondata = t,
                yt([ct, dt, function() {
                    return [_t, Ft, Vt]
                }
                ], this, 0, (function() {
                    var t = new Vt;
                    onmessage = _t(t)
                }
                ), 9)
            }
        }();
        function Xt(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return vt(t, e, [ct, dt, function() {
                return [jt]
            }
            ], (function(t) {
                return mt(jt(t.data[0]))
            }
            ), 3, n)
        }
        function jt(t, e) {
            return V(t.subarray(St(t), -8), e || new m(Et(t)))
        }
        var Yt = function() {
            function t(t, e) {
                this.c = rt(),
                this.v = 1,
                Ct.call(this, t, e)
            }
            return t.prototype.push = function(t, e) {
                Ct.prototype.push.call(this, t, e)
            }
            ,
            t.prototype.p = function(t, e) {
                this.c.p(t);
                var n = it(t, this.o, this.v && 2, e && 4, !e);
                this.v && (Rt(n, this.o),
                this.v = 0),
                e && Mt(n, n.length - 4, this.c.d()),
                this.ondata(n, e)
            }
            ,
            t
        }()
          , qt = function() {
            return function(t, e) {
                yt([ut, ft, function() {
                    return [_t, Ct, Yt]
                }
                ], this, Pt.call(this, t, e), (function(t) {
                    var e = new Yt(t.data);
                    onmessage = _t(e)
                }
                ), 10)
            }
        }();
        function Zt(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return vt(t, e, [ut, ft, function() {
                return [Kt]
            }
            ], (function(t) {
                return mt(Kt(t.data[0], t.data[1]))
            }
            ), 4, n)
        }
        function Kt(t, e) {
            e || (e = {});
            var n = rt();
            n.p(t);
            var r = it(t, e, 2, 4);
            return Rt(r, e),
            Mt(r, r.length - 4, n.d()),
            r
        }
        var Jt = function() {
            function t(t) {
                this.v = 1,
                Ft.call(this, t)
            }
            return t.prototype.push = function(t, e) {
                if (Ft.prototype.e.call(this, t),
                this.v) {
                    if (this.p.length < 2 && !e)
                        return;
                    this.p = this.p.subarray(2),
                    this.v = 0
                }
                if (e) {
                    if (this.p.length < 4)
                        throw "invalid zlib stream";
                    this.p = this.p.subarray(0, -4)
                }
                Ft.prototype.c.call(this, e)
            }
            ,
            t
        }()
          , Qt = function() {
            return function(t) {
                this.ondata = t,
                yt([ct, pt, function() {
                    return [_t, Ft, Jt]
                }
                ], this, 0, (function() {
                    var t = new Jt;
                    onmessage = _t(t)
                }
                ), 11)
            }
        }();
        function $t(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return vt(t, e, [ct, pt, function() {
                return [te]
            }
            ], (function(t) {
                return mt(te(t.data[0], gt(t.data[1])))
            }
            ), 5, n)
        }
        function te(t, e) {
            return V((Lt(t),
            t.subarray(2, -4)), e)
        }
        var ee = function() {
            function t(t) {
                this.G = Vt,
                this.I = Ft,
                this.Z = Jt,
                this.ondata = t
            }
            return t.prototype.push = function(t, e) {
                if (!this.ondata)
                    throw "no stream handler";
                if (this.s)
                    this.s.push(t, e);
                else {
                    if (this.p && this.p.length) {
                        var n = new m(this.p.length + t.length);
                        n.set(this.p),
                        n.set(t, this.p.length)
                    } else
                        this.p = t;
                    if (this.p.length > 2) {
                        var r = this
                          , i = function() {
                            r.ondata.apply(r, arguments)
                        };
                        this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i),
                        this.s.push(this.p, e),
                        this.p = null
                    }
                }
            }
            ,
            t
        }()
          , ne = function() {
            function t(t) {
                this.G = Wt,
                this.I = Ot,
                this.Z = Qt,
                this.ondata = t
            }
            return t.prototype.push = function(t, e) {
                ee.prototype.push.call(this, t, e)
            }
            ,
            t
        }();
        function re(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            return 31 == t[0] && 139 == t[1] && 8 == t[2] ? Xt(t, e, n) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? Ut(t, e, n) : $t(t, e, n)
        }
        function ie(t, e) {
            return 31 == t[0] && 139 == t[1] && 8 == t[2] ? jt(t, e) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? zt(t, e) : te(t, e)
        }
        var se = function(t, e, n, r) {
            for (var i in t) {
                var s = t[i]
                  , a = e + i;
                s instanceof m ? n[a] = [s, r] : Array.isArray(s) ? n[a] = [s[0], st(r, s[1])] : se(s, a + "/", n, r)
            }
        }
          , ae = "undefined" != typeof TextEncoder && new TextEncoder
          , oe = "undefined" != typeof TextDecoder && new TextDecoder
          , le = 0;
        try {
            oe.decode($, {
                stream: !0
            }),
            le = 1
        } catch (t) {}
        var ce = function(t) {
            for (var e = "", n = 0; ; ) {
                var r = t[n++]
                  , i = (r > 127) + (r > 223) + (r > 239);
                if (n + i > t.length)
                    return [e, H(t, n - 1)];
                i ? 3 == i ? (r = ((15 & r) << 18 | (63 & t[n++]) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) - 65536,
                e += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : e += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & t[n++]) : String.fromCharCode((15 & r) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) : e += String.fromCharCode(r)
            }
        }
          , ue = function() {
            function t(t) {
                this.ondata = t,
                le ? this.t = new TextDecoder : this.p = $
            }
            return t.prototype.push = function(t, e) {
                if (!this.ondata)
                    throw "no callback";
                if (e = !!e,
                this.t) {
                    if (this.ondata(this.t.decode(t, {
                        stream: !0
                    }), e),
                    e) {
                        if (this.t.decode().length)
                            throw "invalid utf-8 data";
                        this.t = null
                    }
                } else {
                    if (!this.p)
                        throw "stream finished";
                    var n = new m(this.p.length + t.length);
                    n.set(this.p),
                    n.set(t, this.p.length);
                    var r = ce(n)
                      , i = r[0]
                      , s = r[1];
                    if (e) {
                        if (s.length)
                            throw "invalid utf-8 data";
                        this.p = null
                    } else
                        this.p = s;
                    this.ondata(i, e)
                }
            }
            ,
            t
        }()
          , he = function() {
            function t(t) {
                this.ondata = t
            }
            return t.prototype.push = function(t, e) {
                if (!this.ondata)
                    throw "no callback";
                if (this.d)
                    throw "stream finished";
                this.ondata(de(t), this.d = e || !1)
            }
            ,
            t
        }();
        function de(t, e) {
            if (e) {
                for (var n = new m(t.length), r = 0; r < t.length; ++r)
                    n[r] = t.charCodeAt(r);
                return n
            }
            if (ae)
                return ae.encode(t);
            var i = t.length
              , s = new m(t.length + (t.length >> 1))
              , a = 0
              , o = function(t) {
                s[a++] = t
            };
            for (r = 0; r < i; ++r) {
                if (a + 5 > s.length) {
                    var l = new m(a + 8 + (i - r << 1));
                    l.set(s),
                    s = l
                }
                var c = t.charCodeAt(r);
                c < 128 || e ? o(c) : c < 2048 ? (o(192 | c >> 6),
                o(128 | 63 & c)) : c > 55295 && c < 57344 ? (o(240 | (c = 65536 + (1047552 & c) | 1023 & t.charCodeAt(++r)) >> 18),
                o(128 | c >> 12 & 63),
                o(128 | c >> 6 & 63),
                o(128 | 63 & c)) : (o(224 | c >> 12),
                o(128 | c >> 6 & 63),
                o(128 | 63 & c))
            }
            return H(s, 0, a)
        }
        function fe(t, e) {
            if (e) {
                for (var n = "", r = 0; r < t.length; r += 16384)
                    n += String.fromCharCode.apply(null, t.subarray(r, r + 16384));
                return n
            }
            if (oe)
                return oe.decode(t);
            var i = ce(t)
              , s = i[0];
            if (i[1].length)
                throw "invalid utf-8 data";
            return s
        }
        var pe = function(t) {
            return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0
        }
          , me = function(t, e) {
            return e + 30 + xt(t, e + 26) + xt(t, e + 28)
        }
          , ge = function(t, e, n) {
            var r = xt(t, e + 28)
              , i = fe(t.subarray(e + 46, e + 46 + r), !(2048 & xt(t, e + 8)))
              , s = e + 46 + r
              , a = bt(t, e + 20)
              , o = n && 4294967295 == a ? ve(t, s) : [a, bt(t, e + 24), bt(t, e + 42)]
              , l = o[0]
              , c = o[1]
              , u = o[2];
            return [xt(t, e + 10), l, c, i, s + xt(t, e + 30) + xt(t, e + 32), u]
        }
          , ve = function(t, e) {
            for (; 1 != xt(t, e); e += 4 + xt(t, e + 2))
                ;
            return [wt(t, e + 12), wt(t, e + 4), wt(t, e + 20)]
        }
          , _e = function(t) {
            var e = 0;
            if (t)
                for (var n in t) {
                    var r = t[n].length;
                    if (r > 65535)
                        throw "extra field too long";
                    e += r + 4
                }
            return e
        }
          , ye = function(t, e, n, r, i, s, a, o) {
            var l = r.length
              , c = n.extra
              , u = o && o.length
              , h = _e(c);
            Mt(t, e, null != a ? 33639248 : 67324752),
            e += 4,
            null != a && (t[e++] = 20,
            t[e++] = n.os),
            t[e] = 20,
            e += 2,
            t[e++] = n.flag << 1 | (null == s && 8),
            t[e++] = i && 8,
            t[e++] = 255 & n.compression,
            t[e++] = n.compression >> 8;
            var d = new Date(null == n.mtime ? Date.now() : n.mtime)
              , f = d.getFullYear() - 1980;
            if (f < 0 || f > 119)
                throw "date not in range 1980-2099";
            if (Mt(t, e, f << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1),
            e += 4,
            null != s && (Mt(t, e, n.crc),
            Mt(t, e + 4, s),
            Mt(t, e + 8, n.size)),
            Mt(t, e + 12, l),
            Mt(t, e + 14, h),
            e += 16,
            null != a && (Mt(t, e, u),
            Mt(t, e + 6, n.attrs),
            Mt(t, e + 10, a),
            e += 14),
            t.set(r, e),
            e += l,
            h)
                for (var p in c) {
                    var m = c[p]
                      , g = m.length;
                    Mt(t, e, +p),
                    Mt(t, e + 2, g),
                    t.set(m, e + 4),
                    e += 4 + g
                }
            return u && (t.set(o, e),
            e += u),
            e
        }
          , xe = function(t, e, n, r, i) {
            Mt(t, e, 101010256),
            Mt(t, e + 8, n),
            Mt(t, e + 10, n),
            Mt(t, e + 12, r),
            Mt(t, e + 16, i)
        }
          , be = function() {
            function t(t) {
                this.filename = t,
                this.c = nt(),
                this.size = 0,
                this.compression = 0
            }
            return t.prototype.process = function(t, e) {
                this.ondata(null, t, e)
            }
            ,
            t.prototype.push = function(t, e) {
                if (!this.ondata)
                    throw "no callback - add to ZIP archive before pushing";
                this.c.p(t),
                this.size += t.length,
                e && (this.crc = this.c.d()),
                this.process(t, e || !1)
            }
            ,
            t
        }()
          , we = function() {
            function t(t, e) {
                var n = this;
                e || (e = {}),
                be.call(this, t),
                this.d = new Ct(e,(function(t, e) {
                    n.ondata(null, t, e)
                }
                )),
                this.compression = 8,
                this.flag = pe(e.level)
            }
            return t.prototype.process = function(t, e) {
                try {
                    this.d.push(t, e)
                } catch (t) {
                    this.ondata(t, null, e)
                }
            }
            ,
            t.prototype.push = function(t, e) {
                be.prototype.push.call(this, t, e)
            }
            ,
            t
        }()
          , Me = function() {
            function t(t, e) {
                var n = this;
                e || (e = {}),
                be.call(this, t),
                this.d = new Dt(e,(function(t, e, r) {
                    n.ondata(t, e, r)
                }
                )),
                this.compression = 8,
                this.flag = pe(e.level),
                this.terminate = this.d.terminate
            }
            return t.prototype.process = function(t, e) {
                this.d.push(t, e)
            }
            ,
            t.prototype.push = function(t, e) {
                be.prototype.push.call(this, t, e)
            }
            ,
            t
        }()
          , Te = function() {
            function t(t) {
                this.ondata = t,
                this.u = [],
                this.d = 1
            }
            return t.prototype.add = function(t) {
                var e = this;
                if (2 & this.d)
                    throw "stream finished";
                var n = de(t.filename)
                  , r = n.length
                  , i = t.comment
                  , s = i && de(i)
                  , a = r != t.filename.length || s && i.length != s.length
                  , o = r + _e(t.extra) + 30;
                if (r > 65535)
                    throw "filename too long";
                var l = new m(o);
                ye(l, 0, t, n, a);
                var c = [l]
                  , u = function() {
                    for (var t = 0, n = c; t < n.length; t++) {
                        var r = n[t];
                        e.ondata(null, r, !1)
                    }
                    c = []
                }
                  , h = this.d;
                this.d = 0;
                var d = this.u.length
                  , f = st(t, {
                    f: n,
                    u: a,
                    o: s,
                    t: function() {
                        t.terminate && t.terminate()
                    },
                    r: function() {
                        if (u(),
                        h) {
                            var t = e.u[d + 1];
                            t ? t.r() : e.d = 1
                        }
                        h = 1
                    }
                })
                  , p = 0;
                t.ondata = function(n, r, i) {
                    if (n)
                        e.ondata(n, r, i),
                        e.terminate();
                    else if (p += r.length,
                    c.push(r),
                    i) {
                        var s = new m(16);
                        Mt(s, 0, 134695760),
                        Mt(s, 4, t.crc),
                        Mt(s, 8, p),
                        Mt(s, 12, t.size),
                        c.push(s),
                        f.c = p,
                        f.b = o + p + 16,
                        f.crc = t.crc,
                        f.size = t.size,
                        h && f.r(),
                        h = 1
                    } else
                        h && u()
                }
                ,
                this.u.push(f)
            }
            ,
            t.prototype.end = function() {
                var t = this;
                if (2 & this.d) {
                    if (1 & this.d)
                        throw "stream finishing";
                    throw "stream finished"
                }
                this.d ? this.e() : this.u.push({
                    r: function() {
                        1 & t.d && (t.u.splice(-1, 1),
                        t.e())
                    },
                    t: function() {}
                }),
                this.d = 3
            }
            ,
            t.prototype.e = function() {
                for (var t = 0, e = 0, n = 0, r = 0, i = this.u; r < i.length; r++) {
                    n += 46 + (l = i[r]).f.length + _e(l.extra) + (l.o ? l.o.length : 0)
                }
                for (var s = new m(n + 22), a = 0, o = this.u; a < o.length; a++) {
                    var l = o[a];
                    ye(s, t, l, l.f, l.u, l.c, e, l.o),
                    t += 46 + l.f.length + _e(l.extra) + (l.o ? l.o.length : 0),
                    e += l.b
                }
                xe(s, t, this.u.length, n, e),
                this.ondata(null, s, !0),
                this.d = 2
            }
            ,
            t.prototype.terminate = function() {
                for (var t = 0, e = this.u; t < e.length; t++) {
                    e[t].t()
                }
                this.d = 2
            }
            ,
            t
        }();
        function Se(t, e, n) {
            if (n || (n = e,
            e = {}),
            "function" != typeof n)
                throw "no callback";
            var r = {};
            se(t, "", r, e);
            var i = Object.keys(r)
              , s = i.length
              , a = 0
              , o = 0
              , l = s
              , c = new Array(s)
              , u = []
              , h = function() {
                for (var t = 0; t < u.length; ++t)
                    u[t]()
            }
              , d = function() {
                var t = new m(o + 22)
                  , e = a
                  , r = o - a;
                o = 0;
                for (var i = 0; i < l; ++i) {
                    var s = c[i];
                    try {
                        var u = s.c.length;
                        ye(t, o, s, s.f, s.u, u);
                        var h = 30 + s.f.length + _e(s.extra)
                          , d = o + h;
                        t.set(s.c, d),
                        ye(t, a, s, s.f, s.u, u, o, s.m),
                        a += 16 + h + (s.m ? s.m.length : 0),
                        o = d + u
                    } catch (t) {
                        return n(t, null)
                    }
                }
                xe(t, a, c.length, r, e),
                n(null, t)
            };
            s || d();
            for (var f = function(t) {
                var e = i[t]
                  , l = r[e]
                  , f = l[0]
                  , p = l[1]
                  , m = nt()
                  , g = f.length;
                m.p(f);
                var v = de(e)
                  , _ = v.length
                  , y = p.comment
                  , x = y && de(y)
                  , b = x && x.length
                  , w = _e(p.extra)
                  , M = 0 == p.level ? 0 : 8
                  , T = function(r, i) {
                    if (r)
                        h(),
                        n(r, null);
                    else {
                        var l = i.length;
                        c[t] = st(p, {
                            size: g,
                            crc: m.d(),
                            c: i,
                            f: v,
                            m: x,
                            u: _ != e.length || x && y.length != b,
                            compression: M
                        }),
                        a += 30 + _ + w + l,
                        o += 76 + 2 * (_ + w) + (b || 0) + l,
                        --s || d()
                    }
                };
                if (_ > 65535 && T("filename too long", null),
                M)
                    if (g < 16e4)
                        try {
                            T(null, Nt(f, p))
                        } catch (t) {
                            T(t, null)
                        }
                    else
                        u.push(It(f, p, T));
                else
                    T(null, f)
            }, p = 0; p < l; ++p)
                f(p);
            return h
        }
        function Ee(t, e) {
            e || (e = {});
            var n = {}
              , r = [];
            se(t, "", n, e);
            var i = 0
              , s = 0;
            for (var a in n) {
                var o = n[a]
                  , l = o[0]
                  , c = o[1]
                  , u = 0 == c.level ? 0 : 8
                  , h = (T = de(a)).length
                  , d = c.comment
                  , f = d && de(d)
                  , p = f && f.length
                  , g = _e(c.extra);
                if (h > 65535)
                    throw "filename too long";
                var v = u ? Nt(l, c) : l
                  , _ = v.length
                  , y = nt();
                y.p(l),
                r.push(st(c, {
                    size: l.length,
                    crc: y.d(),
                    c: v,
                    f: T,
                    m: f,
                    u: h != a.length || f && d.length != p,
                    o: i,
                    compression: u
                })),
                i += 30 + h + g + _,
                s += 76 + 2 * (h + g) + (p || 0) + _
            }
            for (var x = new m(s + 22), b = i, w = s - i, M = 0; M < r.length; ++M) {
                var T = r[M];
                ye(x, T.o, T, T.f, T.u, T.c.length);
                var S = 30 + T.f.length + _e(T.extra);
                x.set(T.c, T.o + S),
                ye(x, i, T, T.f, T.u, T.c.length, T.o, T.m),
                i += 16 + S + (T.m ? T.m.length : 0)
            }
            return xe(x, i, r.length, w, b),
            x
        }
        var Ae = function() {
            function t() {}
            return t.prototype.push = function(t, e) {
                this.ondata(null, t, e)
            }
            ,
            t.compression = 0,
            t
        }()
          , Re = function() {
            function t() {
                var t = this;
                this.i = new Ft((function(e, n) {
                    t.ondata(null, e, n)
                }
                ))
            }
            return t.prototype.push = function(t, e) {
                try {
                    this.i.push(t, e)
                } catch (n) {
                    this.ondata(n, t, e)
                }
            }
            ,
            t.compression = 8,
            t
        }()
          , Le = function() {
            function t(t, e) {
                var n = this;
                e < 32e4 ? this.i = new Ft((function(t, e) {
                    n.ondata(null, t, e)
                }
                )) : (this.i = new Ot((function(t, e, r) {
                    n.ondata(t, e, r)
                }
                )),
                this.terminate = this.i.terminate)
            }
            return t.prototype.push = function(t, e) {
                this.i.terminate && (t = H(t, 0)),
                this.i.push(t, e)
            }
            ,
            t.compression = 8,
            t
        }()
          , Pe = function() {
            function t(t) {
                this.onfile = t,
                this.k = [],
                this.o = {
                    0: Ae
                },
                this.p = $
            }
            return t.prototype.push = function(t, e) {
                var n = this;
                if (!this.onfile)
                    throw "no callback";
                if (!this.p)
                    throw "stream finished";
                if (this.c > 0) {
                    var r = Math.min(this.c, t.length)
                      , i = t.subarray(0, r);
                    if (this.c -= r,
                    this.d ? this.d.push(i, !this.c) : this.k[0].push(i),
                    (t = t.subarray(r)).length)
                        return this.push(t, e)
                } else {
                    var s = 0
                      , a = 0
                      , o = void 0
                      , l = void 0;
                    this.p.length ? t.length ? ((l = new m(this.p.length + t.length)).set(this.p),
                    l.set(t, this.p.length)) : l = this.p : l = t;
                    for (var c = l.length, u = this.c, h = u && this.d, d = function() {
                        var t, e = bt(l, a);
                        if (67324752 == e) {
                            s = 1,
                            o = a,
                            f.d = null,
                            f.c = 0;
                            var r = xt(l, a + 6)
                              , i = xt(l, a + 8)
                              , h = 2048 & r
                              , d = 8 & r
                              , p = xt(l, a + 26)
                              , m = xt(l, a + 28);
                            if (c > a + 30 + p + m) {
                                var g = [];
                                f.k.unshift(g),
                                s = 2;
                                var v, _ = bt(l, a + 18), y = bt(l, a + 22), x = fe(l.subarray(a + 30, a += 30 + p), !h);
                                4294967295 == _ ? (t = d ? [-2] : ve(l, a),
                                _ = t[0],
                                y = t[1]) : d && (_ = -1),
                                a += m,
                                f.c = _;
                                var b = {
                                    name: x,
                                    compression: i,
                                    start: function() {
                                        if (!b.ondata)
                                            throw "no callback";
                                        if (_) {
                                            var t = n.o[i];
                                            if (!t)
                                                throw "unknown compression type " + i;
                                            (v = _ < 0 ? new t(x) : new t(x,_,y)).ondata = function(t, e, n) {
                                                b.ondata(t, e, n)
                                            }
                                            ;
                                            for (var e = 0, r = g; e < r.length; e++) {
                                                var s = r[e];
                                                v.push(s, !1)
                                            }
                                            n.k[0] == g && n.c ? n.d = v : v.push($, !0)
                                        } else
                                            b.ondata(null, $, !0)
                                    },
                                    terminate: function() {
                                        v && v.terminate && v.terminate()
                                    }
                                };
                                _ >= 0 && (b.size = _,
                                b.originalSize = y),
                                f.onfile(b)
                            }
                            return "break"
                        }
                        if (u) {
                            if (134695760 == e)
                                return o = a += 12 + (-2 == u && 8),
                                s = 3,
                                f.c = 0,
                                "break";
                            if (33639248 == e)
                                return o = a -= 4,
                                s = 3,
                                f.c = 0,
                                "break"
                        }
                    }, f = this; a < c - 4; ++a) {
                        if ("break" === d())
                            break
                    }
                    if (this.p = $,
                    u < 0) {
                        var p = s ? l.subarray(0, o - 12 - (-2 == u && 8) - (134695760 == bt(l, o - 16) && 4)) : l.subarray(0, a);
                        h ? h.push(p, !!s) : this.k[+(2 == s)].push(p)
                    }
                    if (2 & s)
                        return this.push(l.subarray(a), e);
                    this.p = l.subarray(a)
                }
                if (e) {
                    if (this.c)
                        throw "invalid zip file";
                    this.p = null
                }
            }
            ,
            t.prototype.register = function(t) {
                this.o[t.compression] = t
            }
            ,
            t
        }();
        function Ce(t, e) {
            if ("function" != typeof e)
                throw "no callback";
            for (var n = [], r = function() {
                for (var t = 0; t < n.length; ++t)
                    n[t]()
            }, i = {}, s = t.length - 22; 101010256 != bt(t, s); --s)
                if (!s || t.length - s > 65558)
                    return void e("invalid zip file", null);
            var a = xt(t, s + 8);
            a || e(null, {});
            var o = a
              , l = bt(t, s + 16)
              , c = 4294967295 == l;
            if (c) {
                if (s = bt(t, s - 12),
                101075792 != bt(t, s))
                    return void e("invalid zip file", null);
                o = a = bt(t, s + 32),
                l = bt(t, s + 48)
            }
            for (var u = function(s) {
                var o = ge(t, l, c)
                  , u = o[0]
                  , h = o[1]
                  , d = o[2]
                  , f = o[3]
                  , p = o[4]
                  , g = o[5]
                  , v = me(t, g);
                l = p;
                var _ = function(t, n) {
                    t ? (r(),
                    e(t, null)) : (i[f] = n,
                    --a || e(null, i))
                };
                if (u)
                    if (8 == u) {
                        var y = t.subarray(v, v + h);
                        if (h < 32e4)
                            try {
                                _(null, zt(y, new m(d)))
                            } catch (t) {
                                _(t, null)
                            }
                        else
                            n.push(Ut(y, {
                                size: d
                            }, _))
                    } else
                        _("unknown compression type " + u, null);
                else
                    _(null, H(t, v, v + h))
            }, h = 0; h < o; ++h)
                u();
            return r
        }
        function De(t) {
            for (var e = {}, n = t.length - 22; 101010256 != bt(t, n); --n)
                if (!n || t.length - n > 65558)
                    throw "invalid zip file";
            var r = xt(t, n + 8);
            if (!r)
                return {};
            var i = bt(t, n + 16)
              , s = 4294967295 == i;
            if (s) {
                if (n = bt(t, n - 12),
                101075792 != bt(t, n))
                    throw "invalid zip file";
                r = bt(t, n + 32),
                i = bt(t, n + 48)
            }
            for (var a = 0; a < r; ++a) {
                var o = ge(t, i, s)
                  , l = o[0]
                  , c = o[1]
                  , u = o[2]
                  , h = o[3]
                  , d = o[4]
                  , f = o[5]
                  , p = me(t, f);
                if (i = d,
                l) {
                    if (8 != l)
                        throw "unknown compression type " + l;
                    e[h] = zt(t.subarray(p, p + c), new m(u))
                } else
                    e[h] = H(t, p, p + c)
            }
            return e
        }
        class Ie extends l {
            constructor(t) {
                super(t),
                this.type = i.cLu
            }
            parse(t) {
                const e = 65536
                  , n = e >> 3
                  , s = 14
                  , a = 65537
                  , o = 1 << s
                  , l = o - 1
                  , c = 32768
                  , u = 65535
                  , d = 59
                  , f = 63
                  , p = 2 + f - d
                  , m = 8
                  , g = 4
                  , v = 4
                  , _ = 2
                  , y = 1
                  , x = 0
                  , b = 1
                  , w = 0
                  , M = 2
                  , T = Math.pow(2.7182818, 2.2);
                var S = new DataView(new ArrayBuffer(8));
                function E(t) {
                    if (0 === t)
                        return [t, 0];
                    S.setFloat64(0, t);
                    var e = S.getUint32(0) >>> 20 & 2047;
                    0 === e && (S.setFloat64(0, t * Math.pow(2, 64)),
                    e = (S.getUint32(0) >>> 20 & 2047) - 64);
                    var n = e - 1022
                      , r = function(t, e) {
                        for (var n = Math.min(3, Math.ceil(Math.abs(e) / 1023)), r = t, i = 0; i < n; i++)
                            r *= Math.pow(2, Math.floor((e + i) / n));
                        return r
                    }(t, -n);
                    return [r, n]
                }
                const A = {
                    l: 0,
                    c: 0,
                    lc: 0
                };
                function R(t, e, n, r, i) {
                    for (; n < t; )
                        e = e << 8 | st(r, i),
                        n += 8;
                    n -= t,
                    A.l = e >> n & (1 << t) - 1,
                    A.c = e,
                    A.lc = n
                }
                const L = new Array(59);
                function P(t, e, n, r, i, s, o) {
                    for (var l = n, c = 0, u = 0; i <= s; i++) {
                        if (l.value - n.value > r)
                            return !1;
                        R(6, c, u, t, l);
                        var h = A.l;
                        if (c = A.c,
                        u = A.lc,
                        o[i] = h,
                        h == f) {
                            if (l.value - n.value > r)
                                throw "Something wrong with hufUnpackEncTable";
                            R(8, c, u, t, l);
                            var m = A.l + p;
                            if (c = A.c,
                            u = A.lc,
                            i + m > s + 1)
                                throw "Something wrong with hufUnpackEncTable";
                            for (; m--; )
                                o[i++] = 0;
                            i--
                        } else if (h >= d) {
                            if (i + (m = h - d + 2) > s + 1)
                                throw "Something wrong with hufUnpackEncTable";
                            for (; m--; )
                                o[i++] = 0;
                            i--
                        }
                    }
                    !function(t) {
                        for (var e = 0; e <= 58; ++e)
                            L[e] = 0;
                        for (e = 0; e < a; ++e)
                            L[t[e]] += 1;
                        var n = 0;
                        for (e = 58; e > 0; --e) {
                            var r = n + L[e] >> 1;
                            L[e] = n,
                            n = r
                        }
                        for (e = 0; e < a; ++e) {
                            var i = t[e];
                            i > 0 && (t[e] = i | L[i]++ << 6)
                        }
                    }(o)
                }
                function C(t) {
                    return 63 & t
                }
                function D(t) {
                    return t >> 6
                }
                const I = {
                    c: 0,
                    lc: 0
                };
                function N(t, e, n, r) {
                    t = t << 8 | st(n, r),
                    e += 8,
                    I.c = t,
                    I.lc = e
                }
                const F = {
                    c: 0,
                    lc: 0
                };
                function O(t, e, n, r, i, s, a, o, l, c) {
                    if (t == e) {
                        r < 8 && (N(n, r, i, a),
                        n = I.c,
                        r = I.lc);
                        var u = n >> (r -= 8);
                        u = new Uint8Array([u])[0];
                        if (l.value + u > c)
                            return !1;
                        for (var h = o[l.value - 1]; u-- > 0; )
                            o[l.value++] = h
                    } else {
                        if (!(l.value < c))
                            return !1;
                        o[l.value++] = t
                    }
                    F.c = n,
                    F.lc = r
                }
                function U(t) {
                    return 65535 & t
                }
                function z(t) {
                    var e = U(t);
                    return e > 32767 ? e - 65536 : e
                }
                const B = {
                    a: 0,
                    b: 0
                };
                function k(t, e) {
                    var n = z(t)
                      , r = z(e)
                      , i = n + (1 & r) + (r >> 1)
                      , s = i
                      , a = i - r;
                    B.a = s,
                    B.b = a
                }
                function G(t, e) {
                    var n = U(t)
                      , r = U(e)
                      , i = n - (r >> 1) & u
                      , s = r + i - c & u;
                    B.a = s,
                    B.b = i
                }
                function H(t, e, n, r, i, s, a) {
                    for (var o, l = a < 16384, c = n > i ? i : n, u = 1; u <= c; )
                        u <<= 1;
                    for (o = u >>= 1,
                    u >>= 1; u >= 1; ) {
                        for (var h, d, f, p, m = 0, g = m + s * (i - o), v = s * u, _ = s * o, y = r * u, x = r * o; m <= g; m += _) {
                            for (var b = m, w = m + r * (n - o); b <= w; b += x) {
                                var M = b + y
                                  , T = (S = b + v) + y;
                                l ? (k(t[b + e], t[S + e]),
                                h = B.a,
                                f = B.b,
                                k(t[M + e], t[T + e]),
                                d = B.a,
                                p = B.b,
                                k(h, d),
                                t[b + e] = B.a,
                                t[M + e] = B.b,
                                k(f, p),
                                t[S + e] = B.a,
                                t[T + e] = B.b) : (G(t[b + e], t[S + e]),
                                h = B.a,
                                f = B.b,
                                G(t[M + e], t[T + e]),
                                d = B.a,
                                p = B.b,
                                G(h, d),
                                t[b + e] = B.a,
                                t[M + e] = B.b,
                                G(f, p),
                                t[S + e] = B.a,
                                t[T + e] = B.b)
                            }
                            if (n & u) {
                                var S = b + v;
                                l ? k(t[b + e], t[S + e]) : G(t[b + e], t[S + e]),
                                h = B.a,
                                t[S + e] = B.b,
                                t[b + e] = h
                            }
                        }
                        if (i & u)
                            for (b = m,
                            w = m + r * (n - o); b <= w; b += x) {
                                M = b + y;
                                l ? k(t[b + e], t[M + e]) : G(t[b + e], t[M + e]),
                                h = B.a,
                                t[M + e] = B.b,
                                t[b + e] = h
                            }
                        o = u,
                        u >>= 1
                    }
                    return m
                }
                function V(t, e, n, r, i, c) {
                    var u = n.value
                      , h = it(e, n)
                      , d = it(e, n);
                    n.value += 4;
                    var f = it(e, n);
                    if (n.value += 4,
                    h < 0 || h >= a || d < 0 || d >= a)
                        throw "Something wrong with HUF_ENCSIZE";
                    var p = new Array(a)
                      , m = new Array(o);
                    if (function(t) {
                        for (var e = 0; e < o; e++)
                            t[e] = {},
                            t[e].len = 0,
                            t[e].lit = 0,
                            t[e].p = null
                    }(m),
                    P(t, 0, n, r - (n.value - u), h, d, p),
                    f > 8 * (r - (n.value - u)))
                        throw "Something wrong with hufUncompress";
                    !function(t, e, n, r) {
                        for (; e <= n; e++) {
                            var i = D(t[e])
                              , a = C(t[e]);
                            if (i >> a)
                                throw "Invalid table entry";
                            if (a > s) {
                                if ((u = r[i >> a - s]).len)
                                    throw "Invalid table entry";
                                if (u.lit++,
                                u.p) {
                                    var o = u.p;
                                    u.p = new Array(u.lit);
                                    for (var l = 0; l < u.lit - 1; ++l)
                                        u.p[l] = o[l]
                                } else
                                    u.p = new Array(1);
                                u.p[u.lit - 1] = e
                            } else if (a) {
                                var c = 0;
                                for (l = 1 << s - a; l > 0; l--) {
                                    var u;
                                    if ((u = r[(i << s - a) + c]).len || u.p)
                                        throw "Invalid table entry";
                                    u.len = a,
                                    u.lit = e,
                                    c++
                                }
                            }
                        }
                    }(p, h, d, m),
                    function(t, e, n, r, i, a, o, c, u, h) {
                        for (var d = 0, f = 0, p = c, m = Math.trunc(i.value + (a + 7) / 8); i.value < m; )
                            for (N(d, f, n, i),
                            d = I.c,
                            f = I.lc; f >= s; )
                                if ((y = e[d >> f - s & l]).len)
                                    f -= y.len,
                                    O(y.lit, o, d, f, n, 0, i, u, h, p),
                                    d = F.c,
                                    f = F.lc;
                                else {
                                    if (!y.p)
                                        throw "hufDecode issues";
                                    var g;
                                    for (g = 0; g < y.lit; g++) {
                                        for (var v = C(t[y.p[g]]); f < v && i.value < m; )
                                            N(d, f, n, i),
                                            d = I.c,
                                            f = I.lc;
                                        if (f >= v && D(t[y.p[g]]) == (d >> f - v & (1 << v) - 1)) {
                                            f -= v,
                                            O(y.p[g], o, d, f, n, 0, i, u, h, p),
                                            d = F.c,
                                            f = F.lc;
                                            break
                                        }
                                    }
                                    if (g == y.lit)
                                        throw "hufDecode issues"
                                }
                        var _ = 8 - a & 7;
                        for (d >>= _,
                        f -= _; f > 0; ) {
                            var y;
                            if (!(y = e[d << s - f & l]).len)
                                throw "hufDecode issues";
                            f -= y.len,
                            O(y.lit, o, d, f, n, 0, i, u, h, p),
                            d = F.c,
                            f = F.lc
                        }
                    }(p, m, t, 0, n, f, d, c, i, {
                        value: 0
                    })
                }
                function W(t) {
                    for (var e = 1; e < t.length; e++) {
                        var n = t[e - 1] + t[e] - 128;
                        t[e] = n
                    }
                }
                function X(t, e) {
                    for (var n = 0, r = Math.floor((t.length + 1) / 2), i = 0, s = t.length - 1; !(i > s || (e[i++] = t[n++],
                    i > s)); )
                        e[i++] = t[r++]
                }
                function j(t) {
                    for (var e = t.byteLength, n = new Array, r = 0, i = new DataView(t); e > 0; ) {
                        var s = i.getInt8(r++);
                        if (s < 0) {
                            e -= (o = -s) + 1;
                            for (var a = 0; a < o; a++)
                                n.push(i.getUint8(r++))
                        } else {
                            var o = s;
                            e -= 2;
                            var l = i.getUint8(r++);
                            for (a = 0; a < o + 1; a++)
                                n.push(l)
                        }
                    }
                    return n
                }
                function Y(t, e, n) {
                    for (var r, i = 1; i < 64; )
                        65280 == (r = e[t.value]) ? i = 64 : r >> 8 == 255 ? i += 255 & r : (n[i] = r,
                        i++),
                        t.value++
                }
                function q(t, e) {
                    e[0] = ct(t[0]),
                    e[1] = ct(t[1]),
                    e[2] = ct(t[5]),
                    e[3] = ct(t[6]),
                    e[4] = ct(t[14]),
                    e[5] = ct(t[15]),
                    e[6] = ct(t[27]),
                    e[7] = ct(t[28]),
                    e[8] = ct(t[2]),
                    e[9] = ct(t[4]),
                    e[10] = ct(t[7]),
                    e[11] = ct(t[13]),
                    e[12] = ct(t[16]),
                    e[13] = ct(t[26]),
                    e[14] = ct(t[29]),
                    e[15] = ct(t[42]),
                    e[16] = ct(t[3]),
                    e[17] = ct(t[8]),
                    e[18] = ct(t[12]),
                    e[19] = ct(t[17]),
                    e[20] = ct(t[25]),
                    e[21] = ct(t[30]),
                    e[22] = ct(t[41]),
                    e[23] = ct(t[43]),
                    e[24] = ct(t[9]),
                    e[25] = ct(t[11]),
                    e[26] = ct(t[18]),
                    e[27] = ct(t[24]),
                    e[28] = ct(t[31]),
                    e[29] = ct(t[40]),
                    e[30] = ct(t[44]),
                    e[31] = ct(t[53]),
                    e[32] = ct(t[10]),
                    e[33] = ct(t[19]),
                    e[34] = ct(t[23]),
                    e[35] = ct(t[32]),
                    e[36] = ct(t[39]),
                    e[37] = ct(t[45]),
                    e[38] = ct(t[52]),
                    e[39] = ct(t[54]),
                    e[40] = ct(t[20]),
                    e[41] = ct(t[22]),
                    e[42] = ct(t[33]),
                    e[43] = ct(t[38]),
                    e[44] = ct(t[46]),
                    e[45] = ct(t[51]),
                    e[46] = ct(t[55]),
                    e[47] = ct(t[60]),
                    e[48] = ct(t[21]),
                    e[49] = ct(t[34]),
                    e[50] = ct(t[37]),
                    e[51] = ct(t[47]),
                    e[52] = ct(t[50]),
                    e[53] = ct(t[56]),
                    e[54] = ct(t[59]),
                    e[55] = ct(t[61]),
                    e[56] = ct(t[35]),
                    e[57] = ct(t[36]),
                    e[58] = ct(t[48]),
                    e[59] = ct(t[49]),
                    e[60] = ct(t[57]),
                    e[61] = ct(t[58]),
                    e[62] = ct(t[62]),
                    e[63] = ct(t[63])
                }
                function Z(t) {
                    const e = .5 * Math.cos(.7853975)
                      , n = .5 * Math.cos(3.14159 / 16)
                      , r = .5 * Math.cos(3.14159 / 8)
                      , i = .5 * Math.cos(3 * 3.14159 / 16)
                      , s = .5 * Math.cos(.981746875)
                      , a = .5 * Math.cos(3 * 3.14159 / 8)
                      , o = .5 * Math.cos(1.374445625);
                    for (var l = new Array(4), c = new Array(4), u = new Array(4), h = new Array(4), d = 0; d < 8; ++d) {
                        var f = 8 * d;
                        l[0] = r * t[f + 2],
                        l[1] = a * t[f + 2],
                        l[2] = r * t[f + 6],
                        l[3] = a * t[f + 6],
                        c[0] = n * t[f + 1] + i * t[f + 3] + s * t[f + 5] + o * t[f + 7],
                        c[1] = i * t[f + 1] - o * t[f + 3] - n * t[f + 5] - s * t[f + 7],
                        c[2] = s * t[f + 1] - n * t[f + 3] + o * t[f + 5] + i * t[f + 7],
                        c[3] = o * t[f + 1] - s * t[f + 3] + i * t[f + 5] - n * t[f + 7],
                        u[0] = e * (t[f + 0] + t[f + 4]),
                        u[3] = e * (t[f + 0] - t[f + 4]),
                        u[1] = l[0] + l[3],
                        u[2] = l[1] - l[2],
                        h[0] = u[0] + u[1],
                        h[1] = u[3] + u[2],
                        h[2] = u[3] - u[2],
                        h[3] = u[0] - u[1],
                        t[f + 0] = h[0] + c[0],
                        t[f + 1] = h[1] + c[1],
                        t[f + 2] = h[2] + c[2],
                        t[f + 3] = h[3] + c[3],
                        t[f + 4] = h[3] - c[3],
                        t[f + 5] = h[2] - c[2],
                        t[f + 6] = h[1] - c[1],
                        t[f + 7] = h[0] - c[0]
                    }
                    for (var p = 0; p < 8; ++p)
                        l[0] = r * t[16 + p],
                        l[1] = a * t[16 + p],
                        l[2] = r * t[48 + p],
                        l[3] = a * t[48 + p],
                        c[0] = n * t[8 + p] + i * t[24 + p] + s * t[40 + p] + o * t[56 + p],
                        c[1] = i * t[8 + p] - o * t[24 + p] - n * t[40 + p] - s * t[56 + p],
                        c[2] = s * t[8 + p] - n * t[24 + p] + o * t[40 + p] + i * t[56 + p],
                        c[3] = o * t[8 + p] - s * t[24 + p] + i * t[40 + p] - n * t[56 + p],
                        u[0] = e * (t[p] + t[32 + p]),
                        u[3] = e * (t[p] - t[32 + p]),
                        u[1] = l[0] + l[3],
                        u[2] = l[1] - l[2],
                        h[0] = u[0] + u[1],
                        h[1] = u[3] + u[2],
                        h[2] = u[3] - u[2],
                        h[3] = u[0] - u[1],
                        t[0 + p] = h[0] + c[0],
                        t[8 + p] = h[1] + c[1],
                        t[16 + p] = h[2] + c[2],
                        t[24 + p] = h[3] + c[3],
                        t[32 + p] = h[3] - c[3],
                        t[40 + p] = h[2] - c[2],
                        t[48 + p] = h[1] - c[1],
                        t[56 + p] = h[0] - c[0]
                }
                function K(t) {
                    for (var e = 0; e < 64; ++e) {
                        var n = t[0][e]
                          , r = t[1][e]
                          , i = t[2][e];
                        t[0][e] = n + 1.5747 * i,
                        t[1][e] = n - .1873 * r - .4682 * i,
                        t[2][e] = n + 1.8556 * r
                    }
                }
                function J(t, e, n) {
                    for (var r = 0; r < 64; ++r)
                        e[n + r] = h.toHalfFloat(Q(t[r]))
                }
                function Q(t) {
                    return t <= 1 ? Math.sign(t) * Math.pow(Math.abs(t), 2.2) : Math.sign(t) * Math.pow(T, Math.abs(t) - 1)
                }
                function $(t) {
                    var e = t.array.slice(t.offset.value, t.offset.value + t.size);
                    void 0 === r && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                    var n = te(e)
                      , i = new Uint8Array(n.length);
                    return W(n),
                    X(n, i),
                    new DataView(i.buffer)
                }
                function tt(t) {
                    var e = t.viewer
                      , n = {
                        value: t.offset.value
                    }
                      , r = new Uint8Array(t.width * t.lines * (pt.channels.length * t.type * _))
                      , i = {
                        version: ot(e, n),
                        unknownUncompressedSize: ot(e, n),
                        unknownCompressedSize: ot(e, n),
                        acCompressedSize: ot(e, n),
                        dcCompressedSize: ot(e, n),
                        rleCompressedSize: ot(e, n),
                        rleUncompressedSize: ot(e, n),
                        rleRawSize: ot(e, n),
                        totalAcUncompressedCount: ot(e, n),
                        totalDcUncompressedCount: ot(e, n),
                        acCompression: ot(e, n)
                    };
                    if (i.version < 2)
                        throw "EXRLoader.parse: " + pt.compression + " version " + i.version + " is unsupported";
                    for (var s = new Array, a = ut(e, n) - _; a > 0; ) {
                        var o = et(e.buffer, n)
                          , l = at(e, n)
                          , c = l >> 2 & 3
                          , u = new Int8Array([(l >> 4) - 1])[0]
                          , h = at(e, n);
                        s.push({
                            name: o,
                            index: u,
                            type: h,
                            compression: c
                        }),
                        a -= o.length + 3
                    }
                    for (var d = pt.channels, f = new Array(t.channels), p = 0; p < t.channels; ++p) {
                        var m = f[p] = {}
                          , g = d[p];
                        m.name = g.name,
                        m.compression = w,
                        m.decoded = !1,
                        m.type = g.pixelType,
                        m.pLinear = g.pLinear,
                        m.width = t.width,
                        m.height = t.lines
                    }
                    for (var v = {
                        idx: new Array(3)
                    }, y = 0; y < t.channels; ++y)
                        for (m = f[y],
                        p = 0; p < s.length; ++p) {
                            var T = s[p];
                            m.name == T.name && (m.compression = T.compression,
                            T.index >= 0 && (v.idx[T.index] = y),
                            m.offset = y)
                        }
                    if (i.acCompressedSize > 0)
                        switch (i.acCompression) {
                        case x:
                            var S = new Uint16Array(i.totalAcUncompressedCount);
                            V(t.array, e, n, i.acCompressedSize, S, i.totalAcUncompressedCount);
                            break;
                        case b:
                            var E = te(t.array.slice(n.value, n.value + i.totalAcUncompressedCount));
                            S = new Uint16Array(E.buffer);
                            n.value += i.totalAcUncompressedCount
                        }
                    if (i.dcCompressedSize > 0) {
                        var A = {
                            array: t.array,
                            offset: n,
                            size: i.dcCompressedSize
                        }
                          , R = new Uint16Array($(A).buffer);
                        n.value += i.dcCompressedSize
                    }
                    if (i.rleRawSize > 0) {
                        var L = j((E = te(t.array.slice(n.value, n.value + i.rleCompressedSize))).buffer);
                        n.value += i.rleCompressedSize
                    }
                    var P = 0
                      , C = new Array(f.length);
                    for (p = 0; p < C.length; ++p)
                        C[p] = new Array;
                    for (var D = 0; D < t.lines; ++D)
                        for (var I = 0; I < f.length; ++I)
                            C[I].push(P),
                            P += f[I].width * t.type * _;
                    !function(t, e, n, r, i, s) {
                        var a = new DataView(s.buffer)
                          , o = n[t.idx[0]].width
                          , l = n[t.idx[0]].height
                          , c = Math.floor(o / 8)
                          , u = Math.ceil(o / 8)
                          , h = Math.ceil(l / 8)
                          , d = o - 8 * (u - 1)
                          , f = l - 8 * (h - 1)
                          , p = {
                            value: 0
                        }
                          , m = new Array(3)
                          , g = new Array(3)
                          , v = new Array(3)
                          , y = new Array(3)
                          , x = new Array(3);
                        for (let n = 0; n < 3; ++n)
                            x[n] = e[t.idx[n]],
                            m[n] = n < 1 ? 0 : m[n - 1] + u * h,
                            g[n] = new Float32Array(64),
                            v[n] = new Uint16Array(64),
                            y[n] = new Uint16Array(64 * u);
                        for (let e = 0; e < h; ++e) {
                            var b = 8;
                            e == h - 1 && (b = f);
                            var w = 8;
                            for (let t = 0; t < u; ++t) {
                                t == u - 1 && (w = d);
                                for (let t = 0; t < 3; ++t)
                                    v[t].fill(0),
                                    v[t][0] = i[m[t]++],
                                    Y(p, r, v[t]),
                                    q(v[t], g[t]),
                                    Z(g[t]);
                                K(g);
                                for (let e = 0; e < 3; ++e)
                                    J(g[e], y[e], 64 * t)
                            }
                            let s = 0;
                            for (let r = 0; r < 3; ++r) {
                                const i = n[t.idx[r]].type;
                                for (let t = 8 * e; t < 8 * e + b; ++t) {
                                    s = x[r][t];
                                    for (let e = 0; e < c; ++e) {
                                        const n = 64 * e + 8 * (7 & t);
                                        a.setUint16(s + 0 * _ * i, y[r][n + 0], !0),
                                        a.setUint16(s + 1 * _ * i, y[r][n + 1], !0),
                                        a.setUint16(s + 2 * _ * i, y[r][n + 2], !0),
                                        a.setUint16(s + 3 * _ * i, y[r][n + 3], !0),
                                        a.setUint16(s + 4 * _ * i, y[r][n + 4], !0),
                                        a.setUint16(s + 5 * _ * i, y[r][n + 5], !0),
                                        a.setUint16(s + 6 * _ * i, y[r][n + 6], !0),
                                        a.setUint16(s + 7 * _ * i, y[r][n + 7], !0),
                                        s += 8 * _ * i
                                    }
                                }
                                if (c != u)
                                    for (let t = 8 * e; t < 8 * e + b; ++t) {
                                        const e = x[r][t] + 8 * c * _ * i
                                          , n = 64 * c + 8 * (7 & t);
                                        for (let t = 0; t < w; ++t)
                                            a.setUint16(e + t * _ * i, y[r][n + t], !0)
                                    }
                            }
                        }
                        for (var M = new Uint16Array(o), T = (a = new DataView(s.buffer),
                        0); T < 3; ++T) {
                            n[t.idx[T]].decoded = !0;
                            var S = n[t.idx[T]].type;
                            if (2 == n[T].type)
                                for (var E = 0; E < l; ++E) {
                                    const t = x[T][E];
                                    for (var A = 0; A < o; ++A)
                                        M[A] = a.getUint16(t + A * _ * S, !0);
                                    for (A = 0; A < o; ++A)
                                        a.setFloat32(t + A * _ * S, ct(M[A]), !0)
                                }
                        }
                    }(v, C, f, S, R, r);
                    for (p = 0; p < f.length; ++p) {
                        if (!(m = f[p]).decoded) {
                            if (m.compression !== M)
                                throw "EXRLoader.parse: unsupported channel compression";
                            var N = 0
                              , F = 0;
                            for (D = 0; D < t.lines; ++D) {
                                for (var O = C[p][N], U = 0; U < m.width; ++U) {
                                    for (var z = 0; z < _ * m.type; ++z)
                                        r[O++] = L[F + z * m.width * m.height];
                                    F++
                                }
                                N++
                            }
                        }
                    }
                    return new DataView(r.buffer)
                }
                function et(t, e) {
                    for (var n = new Uint8Array(t), r = 0; 0 != n[e.value + r]; )
                        r += 1;
                    var i = (new TextDecoder).decode(n.slice(e.value, e.value + r));
                    return e.value = e.value + r + 1,
                    i
                }
                function nt(t, e) {
                    var n = t.getUint32(0, !0);
                    return e.value = e.value + m,
                    n
                }
                function rt(t, e) {
                    var n = t.getInt32(e.value, !0);
                    return e.value = e.value + v,
                    n
                }
                function it(t, e) {
                    var n = t.getUint32(e.value, !0);
                    return e.value = e.value + v,
                    n
                }
                function st(t, e) {
                    var n = t[e.value];
                    return e.value = e.value + y,
                    n
                }
                function at(t, e) {
                    var n = t.getUint8(e.value);
                    return e.value = e.value + y,
                    n
                }
                function ot(t, e) {
                    var n = Number(t.getBigInt64(e.value, !0));
                    return e.value += m,
                    n
                }
                function lt(t, e) {
                    var n = t.getFloat32(e.value, !0);
                    return e.value += g,
                    n
                }
                function ct(t) {
                    var e = (31744 & t) >> 10
                      , n = 1023 & t;
                    return (t >> 15 ? -1 : 1) * (e ? 31 === e ? n ? NaN : 1 / 0 : Math.pow(2, e - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
                }
                function ut(t, e) {
                    var n = t.getUint16(e.value, !0);
                    return e.value += _,
                    n
                }
                function ht(t, e, n, r, i) {
                    return "string" === r || "stringvector" === r || "iccProfile" === r ? function(t, e, n) {
                        var r = (new TextDecoder).decode(new Uint8Array(t).slice(e.value, e.value + n));
                        return e.value = e.value + n,
                        r
                    }(e, n, i) : "chlist" === r ? function(t, e, n, r) {
                        for (var i = n.value, s = []; n.value < i + r - 1; ) {
                            var a = et(e, n)
                              , o = rt(t, n)
                              , l = at(t, n);
                            n.value += 3;
                            var c = rt(t, n)
                              , u = rt(t, n);
                            s.push({
                                name: a,
                                pixelType: o,
                                pLinear: l,
                                xSampling: c,
                                ySampling: u
                            })
                        }
                        return n.value += 1,
                        s
                    }(t, e, n, i) : "chromaticities" === r ? function(t, e) {
                        return {
                            redX: lt(t, e),
                            redY: lt(t, e),
                            greenX: lt(t, e),
                            greenY: lt(t, e),
                            blueX: lt(t, e),
                            blueY: lt(t, e),
                            whiteX: lt(t, e),
                            whiteY: lt(t, e)
                        }
                    }(t, n) : "compression" === r ? function(t, e) {
                        return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][at(t, e)]
                    }(t, n) : "box2i" === r ? function(t, e) {
                        return {
                            xMin: it(t, e),
                            yMin: it(t, e),
                            xMax: it(t, e),
                            yMax: it(t, e)
                        }
                    }(t, n) : "lineOrder" === r ? function(t, e) {
                        return ["INCREASING_Y"][at(t, e)]
                    }(t, n) : "float" === r ? lt(t, n) : "v2f" === r ? function(t, e) {
                        return [lt(t, e), lt(t, e)]
                    }(t, n) : "v3f" === r ? function(t, e) {
                        return [lt(t, e), lt(t, e), lt(t, e)]
                    }(t, n) : "int" === r ? rt(t, n) : "rational" === r ? function(t, e) {
                        return [rt(t, e), it(t, e)]
                    }(t, n) : "timecode" === r ? function(t, e) {
                        return [it(t, e), it(t, e)]
                    }(t, n) : "preview" === r ? (n.value += i,
                    "skipped") : void (n.value += i)
                }
                var dt = new DataView(t)
                  , ft = new Uint8Array(t)
                  , pt = {};
                dt.getUint32(0, !0),
                dt.getUint8(4, !0),
                dt.getUint8(5, !0);
                for (var mt = {
                    value: 8
                }, gt = !0; gt; ) {
                    var vt = et(t, mt);
                    if (0 == vt)
                        gt = !1;
                    else {
                        var _t = et(t, mt)
                          , yt = ht(dt, t, mt, _t, it(dt, mt));
                        void 0 === yt ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${_t}'.`) : pt[vt] = yt
                    }
                }
                var xt, bt, wt, Mt, Tt = pt.dataWindow.yMax + 1;
                switch (pt.compression) {
                case "NO_COMPRESSION":
                    bt = 1,
                    xt = function(t) {
                        return new DataView(t.array.buffer,t.offset.value,t.size)
                    }
                    ;
                    break;
                case "RLE_COMPRESSION":
                    bt = 1,
                    xt = function(t) {
                        var e = t.viewer.buffer.slice(t.offset.value, t.offset.value + t.size)
                          , n = new Uint8Array(j(e))
                          , r = new Uint8Array(n.length);
                        return W(n),
                        X(n, r),
                        new DataView(r.buffer)
                    }
                    ;
                    break;
                case "ZIPS_COMPRESSION":
                    bt = 1,
                    xt = $;
                    break;
                case "ZIP_COMPRESSION":
                    bt = 16,
                    xt = $;
                    break;
                case "PIZ_COMPRESSION":
                    bt = 32,
                    xt = function(t) {
                        for (var r = t.viewer, i = {
                            value: t.offset.value
                        }, s = t.width * bt * (pt.channels.length * t.type), a = new Uint16Array(s), o = new Uint8Array(n), l = 0, c = new Array(t.channels), u = 0; u < t.channels; u++)
                            c[u] = {},
                            c[u].start = l,
                            c[u].end = c[u].start,
                            c[u].nx = t.width,
                            c[u].ny = t.lines,
                            c[u].size = t.type,
                            l += c[u].nx * c[u].ny * c[u].size;
                        var h = ut(r, i)
                          , d = ut(r, i);
                        if (d >= n)
                            throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
                        if (h <= d)
                            for (u = 0; u < d - h + 1; u++)
                                o[u + h] = at(r, i);
                        var f = new Uint16Array(e)
                          , p = function(t, n) {
                            for (var r = 0, i = 0; i < e; ++i)
                                (0 == i || t[i >> 3] & 1 << (7 & i)) && (n[r++] = i);
                            for (var s = r - 1; r < e; )
                                n[r++] = 0;
                            return s
                        }(o, f)
                          , m = it(r, i);
                        for (V(t.array, r, i, m, a, l),
                        u = 0; u < t.channels; ++u)
                            for (var g = c[u], v = 0; v < c[u].size; ++v)
                                H(a, g.start + v, g.nx, g.size, g.ny, g.nx * g.size, p);
                        !function(t, e, n) {
                            for (var r = 0; r < n; ++r)
                                e[r] = t[e[r]]
                        }(f, a, l);
                        for (var y = 0, x = new Uint8Array(a.buffer.byteLength), b = 0; b < t.lines; b++)
                            for (var w = 0; w < t.channels; w++) {
                                var M = (g = c[w]).nx * g.size
                                  , T = new Uint8Array(a.buffer,g.end * _,M * _);
                                x.set(T, y),
                                y += M * _,
                                g.end += M
                            }
                        return new DataView(x.buffer)
                    }
                    ;
                    break;
                case "PXR24_COMPRESSION":
                    bt = 16,
                    xt = function(t) {
                        var e = t.array.slice(t.offset.value, t.offset.value + t.size);
                        void 0 === r && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                        var n = te(e);
                        const i = t.lines * t.channels * t.width
                          , s = 1 == t.type ? new Uint16Array(i) : new Uint32Array(i);
                        let a = 0
                          , o = 0;
                        const l = new Array(4);
                        for (let e = 0; e < t.lines; e++)
                            for (let e = 0; e < t.channels; e++) {
                                let e = 0;
                                switch (t.type) {
                                case 1:
                                    l[0] = a,
                                    l[1] = l[0] + t.width,
                                    a = l[1] + t.width;
                                    for (let r = 0; r < t.width; ++r)
                                        e += n[l[0]++] << 8 | n[l[1]++],
                                        s[o] = e,
                                        o++;
                                    break;
                                case 2:
                                    l[0] = a,
                                    l[1] = l[0] + t.width,
                                    l[2] = l[1] + t.width,
                                    a = l[2] + t.width;
                                    for (let r = 0; r < t.width; ++r)
                                        e += n[l[0]++] << 24 | n[l[1]++] << 16 | n[l[2]++] << 8,
                                        s[o] = e,
                                        o++
                                }
                            }
                        return new DataView(s.buffer)
                    }
                    ;
                    break;
                case "DWAA_COMPRESSION":
                    bt = 32,
                    xt = tt;
                    break;
                case "DWAB_COMPRESSION":
                    bt = 256,
                    xt = tt;
                    break;
                default:
                    throw "EXRLoader.parse: " + pt.compression + " is unsupported"
                }
                var St = pt.channels[0].pixelType;
                if (1 === St)
                    switch (this.type) {
                    case i.ywz:
                    case i.VzW:
                        Mt = function(t, e) {
                            return ct(ut(t, e))
                        }
                        ,
                        wt = _;
                        break;
                    case i.cLu:
                        Mt = ut,
                        wt = _
                    }
                else {
                    if (2 !== St)
                        throw "EXRLoader.parse: unsupported pixelType " + St + " for " + pt.compression + ".";
                    switch (this.type) {
                    case i.ywz:
                    case i.VzW:
                        Mt = lt,
                        wt = g;
                        break;
                    case i.cLu:
                        Mt = function(t, e) {
                            return h.toHalfFloat(lt(t, e))
                        }
                        ,
                        wt = g
                    }
                }
                for (var Et = Tt / bt, At = 0; At < Et; At++)
                    nt(dt, mt);
                var Rt = pt.dataWindow.xMax - pt.dataWindow.xMin + 1
                  , Lt = pt.dataWindow.yMax - pt.dataWindow.yMin + 1
                  , Pt = Rt * Lt * 4;
                switch (this.type) {
                case i.ywz:
                case i.VzW:
                    var Ct = new Float32Array(Pt);
                    pt.channels.length < 4 && Ct.fill(1, 0, Pt);
                    break;
                case i.cLu:
                    Ct = new Uint16Array(Pt);
                    pt.channels.length < 4 && Ct.fill(15360, 0, Pt);
                    break;
                default:
                    console.error("THREE.EXRLoader: unsupported type: ", this.type)
                }
                for (var Dt, It, Nt = {
                    R: 0,
                    G: 1,
                    B: 2,
                    A: 3
                }, Ft = {
                    size: 0,
                    width: Rt,
                    lines: bt,
                    offset: mt,
                    array: ft,
                    viewer: dt,
                    type: St,
                    channels: pt.channels.length
                }, Ot = {
                    value: 0
                }, Ut = 0; Ut < Lt / bt; Ut++) {
                    Dt = it(dt, mt),
                    Pt = it(dt, mt),
                    Ft.lines = Dt + bt > Lt ? Lt - Dt : bt,
                    Ft.offset = mt,
                    Ft.size = Pt,
                    It = xt(Ft),
                    mt.value += Pt;
                    for (var zt = 0; zt < bt; zt++) {
                        var Bt = zt + Ut * bt;
                        if (Bt >= Lt)
                            break;
                        for (var kt = 0; kt < pt.channels.length; kt++)
                            for (var Gt = Nt[pt.channels[kt].name], Ht = 0; Ht < Rt; Ht++) {
                                var Vt = zt * (pt.channels.length * Rt) + kt * Rt + Ht;
                                Ot.value = Vt * wt;
                                var Wt = Mt(It, Ot);
                                Ct[4 * Rt * (Lt - 1 - Bt) + 4 * Ht + Gt] = Wt
                            }
                    }
                }
                if (this.type === i.ywz) {
                    let t, e;
                    const n = Ct.length
                      , r = new Uint8Array(n);
                    for (let n = 0; n < Lt; ++n)
                        for (let i = 0; i < Rt; ++i) {
                            e = n * Rt * 4 + 4 * i;
                            const s = Ct[e]
                              , a = Ct[e + 1]
                              , o = Ct[e + 2];
                            if (t = s > a ? s : a,
                            t = o > t ? o : t,
                            t < 1e-32)
                                r[e] = r[e + 1] = r[e + 2] = r[e + 3] = 0;
                            else {
                                const n = E(t);
                                t = 256 * n[0] / t,
                                r[e] = s * t,
                                r[e + 1] = a * t,
                                r[e + 2] = o * t,
                                r[e + 3] = n[1] + 128
                            }
                        }
                    Ct = r
                }
                const Xt = this.type === i.ywz ? i.aoB : i.wk1;
                return {
                    header: pt,
                    width: Rt,
                    height: Lt,
                    data: Ct,
                    format: Xt,
                    type: this.type
                }
            }
            setDataType(t) {
                return this.type = t,
                this
            }
            load(t, e, n, r) {
                return super.load(t, (function(t, n) {
                    switch (t.type) {
                    case i.ywz:
                        t.encoding = i.KC9,
                        t.minFilter = i.TyD,
                        t.magFilter = i.TyD,
                        t.generateMipmaps = !1,
                        t.flipY = !1;
                        break;
                    case i.VzW:
                    case i.cLu:
                        t.encoding = i.rnI,
                        t.minFilter = i.wem,
                        t.magFilter = i.wem,
                        t.generateMipmaps = !1,
                        t.flipY = !1
                    }
                    e && e(t, n)
                }
                ), n, r)
            }
        }
    },
    792: function(t, e, n) {
        n.d(e, {
            E: function() {
                return Wt
            }
        });
        var r = n(5183);
        class i {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, r = t.length; n < r; n++)
                    e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        }
        var s = n(5092)
          , a = n(3662)
          , o = n(4291);
        class l extends o.T {
            constructor(t, e=1) {
                super(),
                this.type = "Light",
                this.color = new a.I(t),
                this.intensity = e
            }
            dispose() {}
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        }
        l.prototype.isLight = !0;
        var c = n(9203)
          , u = n(1138)
          , h = n(6881)
          , d = n(223)
          , f = n(4698);
        const p = new c.y
          , m = new h.P
          , g = new h.P;
        class v {
            constructor(t) {
                this.camera = t,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new u.F(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new c.y,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new f.i,
                this._frameExtents = new u.F(1,1),
                this._viewportCount = 1,
                this._viewports = [new d.L(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = this.matrix;
                m.setFromMatrixPosition(t.matrixWorld),
                e.position.copy(m),
                g.setFromMatrixPosition(t.target.matrixWorld),
                e.lookAt(g),
                e.updateMatrixWorld(),
                p.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(p),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(e.projectionMatrix),
                n.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(!1).object,
                delete t.camera.matrix,
                t
            }
        }
        var _ = n(3131);
        class y extends v {
            constructor() {
                super(new _.i(-5,5,5,-5,.5,500))
            }
        }
        y.prototype.isDirectionalLightShadow = !0;
        class x extends l {
            constructor(t, e) {
                super(t, e),
                this.type = "DirectionalLight",
                this.position.copy(o.T.DefaultUp),
                this.updateMatrix(),
                this.target = new o.T,
                this.shadow = new y
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        x.prototype.isDirectionalLight = !0;
        var b = n(1051);
        const w = new c.y
          , M = new h.P
          , T = new h.P;
        class S extends v {
            constructor() {
                super(new b.c(90,1,.5,500)),
                this._frameExtents = new u.F(4,2),
                this._viewportCount = 6,
                this._viewports = [new d.L(2,1,1,1), new d.L(0,1,1,1), new d.L(3,1,1,1), new d.L(1,1,1,1), new d.L(3,0,1,1), new d.L(1,0,1,1)],
                this._cubeDirections = [new h.P(1,0,0), new h.P(-1,0,0), new h.P(0,0,1), new h.P(0,0,-1), new h.P(0,1,0), new h.P(0,-1,0)],
                this._cubeUps = [new h.P(0,1,0), new h.P(0,1,0), new h.P(0,1,0), new h.P(0,1,0), new h.P(0,0,1), new h.P(0,0,-1)]
            }
            updateMatrices(t, e=0) {
                const n = this.camera
                  , r = this.matrix
                  , i = t.distance || n.far;
                i !== n.far && (n.far = i,
                n.updateProjectionMatrix()),
                M.setFromMatrixPosition(t.matrixWorld),
                n.position.copy(M),
                T.copy(n.position),
                T.add(this._cubeDirections[e]),
                n.up.copy(this._cubeUps[e]),
                n.lookAt(T),
                n.updateMatrixWorld(),
                r.makeTranslation(-M.x, -M.y, -M.z),
                w.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(w)
            }
        }
        S.prototype.isPointLightShadow = !0;
        class E extends l {
            constructor(t, e, n=0, r=1) {
                super(t, e),
                this.type = "PointLight",
                this.distance = n,
                this.decay = r,
                this.shadow = new S
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.decay = t.decay,
                this.shadow = t.shadow.clone(),
                this
            }
        }
        E.prototype.isPointLight = !0;
        var A = n(2043);
        class R extends v {
            constructor() {
                super(new b.c(50,1,.5,500)),
                this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = 2 * A.I3 * t.angle * this.focus
                  , r = this.mapSize.width / this.mapSize.height
                  , i = t.distance || e.far;
                n === e.fov && r === e.aspect && i === e.far || (e.fov = n,
                e.aspect = r,
                e.far = i,
                e.updateProjectionMatrix()),
                super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t),
                this.focus = t.focus,
                this
            }
        }
        R.prototype.isSpotLightShadow = !0;
        class L extends l {
            constructor(t, e, n=0, r=Math.PI / 3, i=0, s=1) {
                super(t, e),
                this.type = "SpotLight",
                this.position.copy(o.T.DefaultUp),
                this.updateMatrix(),
                this.target = new o.T,
                this.distance = n,
                this.angle = r,
                this.penumbra = i,
                this.decay = s,
                this.shadow = new R
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.angle = t.angle,
                this.penumbra = t.penumbra,
                this.decay = t.decay,
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        L.prototype.isSpotLight = !0;
        var P = n(6173)
          , C = n(1661)
          , D = n(4164);
        class I extends D.F {
            constructor(t) {
                super(),
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new a.I(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new a.I(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = C.IOt,
                this.normalScale = new u.F(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(t.color),
                this.roughness = t.roughness,
                this.metalness = t.metalness,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.roughnessMap = t.roughnessMap,
                this.metalnessMap = t.metalnessMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapIntensity = t.envMapIntensity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.flatShading = t.flatShading,
                this
            }
        }
        I.prototype.isMeshStandardMaterial = !0;
        class N extends I {
            constructor(t) {
                super(),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new u.F(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return A.uZ(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }),
                this.sheenTint = new a.I(0),
                this.transmission = 0,
                this.transmissionMap = null,
                this.thickness = .01,
                this.thicknessMap = null,
                this.attenuationDistance = 0,
                this.attenuationTint = new a.I(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularTint = new a.I(1,1,1),
                this.specularTintMap = null,
                this._clearcoat = 0,
                this._transmission = 0,
                this.setValues(t)
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++,
                this._clearcoat = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++,
                this._transmission = t
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.clearcoat = t.clearcoat,
                this.clearcoatMap = t.clearcoatMap,
                this.clearcoatRoughness = t.clearcoatRoughness,
                this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
                this.clearcoatNormalMap = t.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                this.ior = t.ior,
                this.sheenTint.copy(t.sheenTint),
                this.transmission = t.transmission,
                this.transmissionMap = t.transmissionMap,
                this.thickness = t.thickness,
                this.thicknessMap = t.thicknessMap,
                this.attenuationDistance = t.attenuationDistance,
                this.attenuationTint.copy(t.attenuationTint),
                this.specularIntensity = t.specularIntensity,
                this.specularIntensityMap = t.specularIntensityMap,
                this.specularTint.copy(t.specularTint),
                this.specularTintMap = t.specularTintMap,
                this
            }
        }
        N.prototype.isMeshPhysicalMaterial = !0;
        class F {
            constructor(t, e, n, r) {
                this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== r ? r : new e.constructor(n),
                this.sampleValues = e,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex
                  , r = e[n]
                  , i = e[n - 1];
                t: {
                    e: {
                        let s;
                        n: {
                            r: if (!(t < r)) {
                                for (let s = n + 2; ; ) {
                                    if (void 0 === r) {
                                        if (t < i)
                                            break r;
                                        return n = e.length,
                                        this._cachedIndex = n,
                                        this.afterEnd_(n - 1, t, i)
                                    }
                                    if (n === s)
                                        break;
                                    if (i = r,
                                    r = e[++n],
                                    t < r)
                                        break e
                                }
                                s = e.length;
                                break n
                            }
                            if (t >= i)
                                break t;
                            {
                                const a = e[1];
                                t < a && (n = 2,
                                i = a);
                                for (let s = n - 2; ; ) {
                                    if (void 0 === i)
                                        return this._cachedIndex = 0,
                                        this.beforeStart_(0, t, r);
                                    if (n === s)
                                        break;
                                    if (r = i,
                                    i = e[--n - 1],
                                    t >= i)
                                        break e
                                }
                                s = n,
                                n = 0
                            }
                        }
                        for (; n < s; ) {
                            const r = n + s >>> 1;
                            t < e[r] ? s = r : n = r + 1
                        }
                        if (r = e[n],
                        i = e[n - 1],
                        void 0 === i)
                            return this._cachedIndex = 0,
                            this.beforeStart_(0, t, r);
                        if (void 0 === r)
                            return n = e.length,
                            this._cachedIndex = n,
                            this.afterEnd_(n - 1, i, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, t, r)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , r = this.valueSize
                  , i = t * r;
                for (let t = 0; t !== r; ++t)
                    e[t] = n[i + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        F.prototype.beforeStart_ = F.prototype.copySampleValue_,
        F.prototype.afterEnd_ = F.prototype.copySampleValue_;
        var O = n(7092)
          , U = n(2626);
        class z extends r.a {
            constructor(t) {
                super(t),
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t,
                this
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const i = this
                  , s = U.C.get(t);
                if (void 0 !== s)
                    return i.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        i.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                a.headers = this.requestHeader,
                fetch(t, a).then((function(t) {
                    return t.blob()
                }
                )).then((function(t) {
                    return createImageBitmap(t, Object.assign(i.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    U.C.add(t, n),
                    e && e(n),
                    i.manager.itemEnd(t)
                }
                )).catch((function(e) {
                    r && r(e),
                    i.manager.itemError(t),
                    i.manager.itemEnd(t)
                }
                )),
                i.manager.itemStart(t)
            }
        }
        z.prototype.isImageBitmapLoader = !0;
        var B = n(3278);
        class k {
            constructor(t, e) {
                this.array = t,
                this.stride = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.usage = C.W2J,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = A.DO()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array),
                this.count = t.count,
                this.stride = t.stride,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.stride,
                n *= e.stride;
                for (let r = 0, i = this.stride; r < i; r++)
                    this.array[t + r] = e.array[n + r];
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = A.DO()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(e,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = A.DO()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        k.prototype.isInterleavedBuffer = !0;
        var G = n(140);
        const H = new h.P;
        class V {
            constructor(t, e, n, r=!1) {
                this.name = "",
                this.data = t,
                this.itemSize = e,
                this.offset = n,
                this.normalized = !0 === r
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++)
                    H.x = this.getX(e),
                    H.y = this.getY(e),
                    H.z = this.getZ(e),
                    H.applyMatrix4(t),
                    this.setXYZ(e, H.x, H.y, H.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    H.x = this.getX(e),
                    H.y = this.getY(e),
                    H.z = this.getZ(e),
                    H.applyNormalMatrix(t),
                    this.setXYZ(e, H.x, H.y, H.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    H.x = this.getX(e),
                    H.y = this.getY(e),
                    H.z = this.getZ(e),
                    H.transformDirection(t),
                    this.setXYZ(e, H.x, H.y, H.z);
                return this
            }
            setX(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e,
                this
            }
            setY(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e,
                this
            }
            setZ(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e,
                this
            }
            setW(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e,
                this
            }
            getX(t) {
                return this.data.array[t * this.data.stride + this.offset]
            }
            getY(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }
            getZ(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }
            getW(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, r) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = r,
                this
            }
            setXYZW(t, e, n, r, i) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = r,
                this.data.array[t + 3] = i,
                this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return new G.Tl(new this.array.constructor(t),this.itemSize,this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new V(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        V.prototype.isInterleavedBufferAttribute = !0;
        var W = n(1244);
        class X extends D.F {
            constructor(t) {
                super(),
                this.type = "PointsMaterial",
                this.color = new a.I(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this
            }
        }
        X.prototype.isPointsMaterial = !0;
        var j = n(5785);
        const Y = "\\[\\]\\.:\\/"
          , q = new RegExp("[" + Y + "]","g")
          , Z = "[^" + Y + "]"
          , K = "[^" + Y.replace("\\.", "") + "]"
          , J = /((?:WC+[\/:])*)/.source.replace("WC", Z)
          , Q = /(WCOD+)?/.source.replace("WCOD", K)
          , $ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Z)
          , tt = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Z)
          , et = new RegExp("^" + J + Q + $ + tt + "$")
          , nt = ["material", "materials", "bones"];
        class rt {
            constructor(t, e, n) {
                this.path = e,
                this.parsedPath = n || rt.parseTrackName(e),
                this.node = rt.findNode(t, this.parsedPath.nodeName) || t,
                this.rootNode = t,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new rt.Composite(t,e,n) : new rt(t,e,n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(q, "")
            }
            static parseTrackName(t) {
                const e = et.exec(t);
                if (!e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    const t = n.nodeName.substring(r + 1);
                    -1 !== nt.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r),
                    n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n)
                        return n
                }
                if (t.children) {
                    const n = function(t) {
                        for (let r = 0; r < t.length; r++) {
                            const i = t[r];
                            if (i.name === e || i.uuid === e)
                                return i;
                            const s = n(i.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                      , r = n(t.children);
                    if (r)
                        return r
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    t[e++] = n[r]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    n[r] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    n[r] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r)
                    n[r] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(),
                this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(),
                this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath
                  , n = e.objectName
                  , r = e.propertyName;
                let i = e.propertyIndex;
                if (t || (t = rt.findNode(this.rootNode, e.nodeName) || this.rootNode,
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let r = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === r) {
                                r = e;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== r) {
                        if (void 0 === t[r])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[r]
                    }
                }
                const s = t[r];
                if (void 0 === s) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                }
                let a = this.Versioning.None;
                this.targetObject = t,
                void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!t.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                    }
                    o = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = i
                } else
                    void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
                    this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
                    this.resolvedProperty = s) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[o],
                this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        rt.Composite = class {
            constructor(t, e, n) {
                const r = n || rt.parseTrackName(e);
                this._targetGroup = t,
                this._bindings = t.subscribe_(e, r)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , r = this._bindings[n];
                void 0 !== r && r.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)
                    n[r].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].unbind()
            }
        }
        ,
        rt.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        rt.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        rt.prototype.GetterByBindingType = [rt.prototype._getValue_direct, rt.prototype._getValue_array, rt.prototype._getValue_arrayElement, rt.prototype._getValue_toArray],
        rt.prototype.SetterByBindingTypeAndVersioning = [[rt.prototype._setValue_direct, rt.prototype._setValue_direct_setNeedsUpdate, rt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [rt.prototype._setValue_array, rt.prototype._setValue_array_setNeedsUpdate, rt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [rt.prototype._setValue_arrayElement, rt.prototype._setValue_arrayElement_setNeedsUpdate, rt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [rt.prototype._setValue_fromArray, rt.prototype._setValue_fromArray_setNeedsUpdate, rt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        var it = n(9046)
          , st = n(6454);
        const at = new h.P
          , ot = new d.L
          , lt = new d.L
          , ct = new h.P
          , ut = new c.y;
        class ht extends st.K {
            constructor(t, e) {
                super(t, e),
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new c.y,
                this.bindMatrixInverse = new c.y
            }
            copy(t) {
                return super.copy(t),
                this.bindMode = t.bindMode,
                this.bindMatrix.copy(t.bindMatrix),
                this.bindMatrixInverse.copy(t.bindMatrixInverse),
                this.skeleton = t.skeleton,
                this
            }
            bind(t, e) {
                this.skeleton = t,
                void 0 === e && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                e = this.matrixWorld),
                this.bindMatrix.copy(e),
                this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new d.L
                  , e = this.geometry.attributes.skinWeight;
                for (let n = 0, r = e.count; n < r; n++) {
                    t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.w = e.getW(n);
                    const r = 1 / t.manhattanLength();
                    r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
                    e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(t, e) {
                const n = this.skeleton
                  , r = this.geometry;
                ot.fromBufferAttribute(r.attributes.skinIndex, t),
                lt.fromBufferAttribute(r.attributes.skinWeight, t),
                at.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix),
                e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const r = lt.getComponent(t);
                    if (0 !== r) {
                        const i = ot.getComponent(t);
                        ut.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
                        e.addScaledVector(ct.copy(at).applyMatrix4(ut), r)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        ht.prototype.isSkinnedMesh = !0;
        var dt = n(5920)
          , ft = n(1301);
        class pt extends ft.x {
            constructor(t, e) {
                super(t, e),
                this.type = "LineLoop"
            }
        }
        pt.prototype.isLineLoop = !0;
        var mt = n(4699)
          , gt = n(7540);
        const vt = new c.y
          , _t = new gt.z
          , yt = new mt.a
          , xt = new h.P;
        class bt extends o.T {
            constructor(t=new it.u, e=new X) {
                super(),
                this.type = "Points",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            raycast(t, e) {
                const n = this.geometry
                  , r = this.matrixWorld
                  , i = t.params.Points.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                yt.copy(n.boundingSphere),
                yt.applyMatrix4(r),
                yt.radius += i,
                !1 === t.ray.intersectsSphere(yt))
                    return;
                vt.copy(r).invert(),
                _t.copy(t.ray).applyMatrix4(vt);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a;
                if (n.isBufferGeometry) {
                    const i = n.index
                      , a = n.attributes.position;
                    if (null !== i) {
                        for (let n = Math.max(0, s.start), l = Math.min(i.count, s.start + s.count); n < l; n++) {
                            const s = i.getX(n);
                            xt.fromBufferAttribute(a, s),
                            wt(xt, s, o, r, t, e, this)
                        }
                    } else {
                        for (let n = Math.max(0, s.start), i = Math.min(a.count, s.start + s.count); n < i; n++)
                            xt.fromBufferAttribute(a, n),
                            wt(xt, n, o, r, t, e, this)
                    }
                } else
                    console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        function wt(t, e, n, r, i, s, a) {
            const o = _t.distanceSqToPoint(t);
            if (o < n) {
                const n = new h.P;
                _t.closestPointToPoint(t, n),
                n.applyMatrix4(r);
                const l = i.ray.origin.distanceTo(n);
                if (l < i.near || l > i.far)
                    return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(o),
                    point: n,
                    index: e,
                    face: null,
                    object: a
                })
            }
        }
        bt.prototype.isPoints = !0;
        var Mt = n(2010);
        class Tt extends F {
            constructor(t, e, n, r) {
                super(t, e, n, r),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: C.Pnf,
                    endingEnd: C.Pnf
                }
            }
            intervalChanged_(t, e, n) {
                const r = this.parameterPositions;
                let i = t - 2
                  , s = t + 1
                  , a = r[i]
                  , o = r[s];
                if (void 0 === a)
                    switch (this.getSettings_().endingStart) {
                    case C._lf:
                        i = t,
                        a = 2 * e - n;
                        break;
                    case C._sL:
                        i = r.length - 2,
                        a = e + r[i] - r[i + 1];
                        break;
                    default:
                        i = t,
                        a = n
                    }
                if (void 0 === o)
                    switch (this.getSettings_().endingEnd) {
                    case C._lf:
                        s = t,
                        o = 2 * n - e;
                        break;
                    case C._sL:
                        s = 1,
                        o = n + r[1] - r[0];
                        break;
                    default:
                        s = t - 1,
                        o = e
                    }
                const l = .5 * (n - e)
                  , c = this.valueSize;
                this._weightPrev = l / (e - a),
                this._weightNext = l / (o - n),
                this._offsetPrev = i * c,
                this._offsetNext = s * c
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = t * a
                  , l = o - a
                  , c = this._offsetPrev
                  , u = this._offsetNext
                  , h = this._weightPrev
                  , d = this._weightNext
                  , f = (n - e) / (r - e)
                  , p = f * f
                  , m = p * f
                  , g = -h * m + 2 * h * p - h * f
                  , v = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1
                  , _ = (-1 - d) * m + (1.5 + d) * p + .5 * f
                  , y = d * m - d * p;
                for (let t = 0; t !== a; ++t)
                    i[t] = g * s[c + t] + v * s[l + t] + _ * s[o + t] + y * s[u + t];
                return i
            }
        }
        class St extends F {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = t * a
                  , l = o - a
                  , c = (n - e) / (r - e)
                  , u = 1 - c;
                for (let t = 0; t !== a; ++t)
                    i[t] = s[l + t] * u + s[o + t] * c;
                return i
            }
        }
        class Et extends F {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        const At = {
            arraySlice: function(t, e, n) {
                return At.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                const e = t.length
                  , n = new Array(e);
                for (let t = 0; t !== e; ++t)
                    n[t] = t;
                return n.sort((function(e, n) {
                    return t[e] - t[n]
                }
                )),
                n
            },
            sortedArray: function(t, e, n) {
                const r = t.length
                  , i = new t.constructor(r);
                for (let s = 0, a = 0; a !== r; ++s) {
                    const r = n[s] * e;
                    for (let n = 0; n !== e; ++n)
                        i[a++] = t[r + n]
                }
                return i
            },
            flattenJSON: function(t, e, n, r) {
                let i = 1
                  , s = t[0];
                for (; void 0 !== s && void 0 === s[r]; )
                    s = t[i++];
                if (void 0 === s)
                    return;
                let a = s[r];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            a = s[r],
                            void 0 !== a && (e.push(s.time),
                            n.push.apply(n, a)),
                            s = t[i++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                        do {
                            a = s[r],
                            void 0 !== a && (e.push(s.time),
                            a.toArray(n, n.length)),
                            s = t[i++]
                        } while (void 0 !== s);
                    else
                        do {
                            a = s[r],
                            void 0 !== a && (e.push(s.time),
                            n.push(a)),
                            s = t[i++]
                        } while (void 0 !== s)
            },
            subclip: function(t, e, n, r, i=30) {
                const s = t.clone();
                s.name = e;
                const a = [];
                for (let t = 0; t < s.tracks.length; ++t) {
                    const e = s.tracks[t]
                      , o = e.getValueSize()
                      , l = []
                      , c = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const s = e.times[t] * i;
                        if (!(s < n || s >= r)) {
                            l.push(e.times[t]);
                            for (let n = 0; n < o; ++n)
                                c.push(e.values[t * o + n])
                        }
                    }
                    0 !== l.length && (e.times = At.convertArray(l, e.times.constructor),
                    e.values = At.convertArray(c, e.values.constructor),
                    a.push(e))
                }
                s.tracks = a;
                let o = 1 / 0;
                for (let t = 0; t < s.tracks.length; ++t)
                    o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                for (let t = 0; t < s.tracks.length; ++t)
                    s.tracks[t].shift(-1 * o);
                return s.resetDuration(),
                s
            },
            makeClipAdditive: function(t, e=0, n=t, r=30) {
                r <= 0 && (r = 30);
                const i = n.tracks.length
                  , s = e / r;
                for (let e = 0; e < i; ++e) {
                    const r = n.tracks[e]
                      , i = r.ValueTypeName;
                    if ("bool" === i || "string" === i)
                        continue;
                    const a = t.tracks.find((function(t) {
                        return t.name === r.name && t.ValueTypeName === i
                    }
                    ));
                    if (void 0 === a)
                        continue;
                    let o = 0;
                    const l = r.getValueSize();
                    r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                    let c = 0;
                    const u = a.getValueSize();
                    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                    const h = r.times.length - 1;
                    let d;
                    if (s <= r.times[0]) {
                        const t = o
                          , e = l - o;
                        d = At.arraySlice(r.values, t, e)
                    } else if (s >= r.times[h]) {
                        const t = h * l + o
                          , e = t + l - o;
                        d = At.arraySlice(r.values, t, e)
                    } else {
                        const t = r.createInterpolant()
                          , e = o
                          , n = l - o;
                        t.evaluate(s),
                        d = At.arraySlice(t.resultBuffer, e, n)
                    }
                    if ("quaternion" === i) {
                        (new O._).fromArray(d).normalize().conjugate().toArray(d)
                    }
                    const f = a.times.length;
                    for (let t = 0; t < f; ++t) {
                        const e = t * u + c;
                        if ("quaternion" === i)
                            O._.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                        else {
                            const t = u - 2 * c;
                            for (let n = 0; n < t; ++n)
                                a.values[e + n] -= d[n]
                        }
                    }
                }
                return t.blendMode = C.gSk,
                t
            }
        };
        class Rt {
            constructor(t, e, n, r) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                this.times = At.convertArray(e, this.TimeBufferType),
                this.values = At.convertArray(n, this.ValueBufferType),
                this.setInterpolation(r || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON)
                    n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: At.convertArray(t.times, Array),
                        values: At.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new Et(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new St(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new Tt(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                case C.Syv:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case C.NMF:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case C.pIN:
                    e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                    this
                }
                return this.createInterpolant = e,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return C.Syv;
                case this.InterpolantFactoryMethodLinear:
                    return C.NMF;
                case this.InterpolantFactoryMethodSmooth:
                    return C.pIN
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, r = e.length; n !== r; ++n)
                        e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, r = e.length; n !== r; ++n)
                        e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times
                  , r = n.length;
                let i = 0
                  , s = r - 1;
                for (; i !== r && n[i] < t; )
                    ++i;
                for (; -1 !== s && n[s] > e; )
                    --s;
                if (++s,
                0 !== i || s !== r) {
                    i >= s && (s = Math.max(s, 1),
                    i = s - 1);
                    const t = this.getValueSize();
                    this.times = At.arraySlice(n, i, s),
                    this.values = At.arraySlice(this.values, i * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                t = !1);
                const n = this.times
                  , r = this.values
                  , i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                t = !1);
                let s = null;
                for (let e = 0; e !== i; e++) {
                    const r = n[e];
                    if ("number" == typeof r && isNaN(r)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, r),
                        t = !1;
                        break
                    }
                    if (null !== s && s > r) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, r, s),
                        t = !1;
                        break
                    }
                    s = r
                }
                if (void 0 !== r && At.isTypedArray(r))
                    for (let e = 0, n = r.length; e !== n; ++e) {
                        const n = r[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                            t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = At.arraySlice(this.times)
                  , e = At.arraySlice(this.values)
                  , n = this.getValueSize()
                  , r = this.getInterpolation() === C.pIN
                  , i = t.length - 1;
                let s = 1;
                for (let a = 1; a < i; ++a) {
                    let i = !1;
                    const o = t[a];
                    if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                        if (r)
                            i = !0;
                        else {
                            const t = a * n
                              , r = t - n
                              , s = t + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = e[t + a];
                                if (n !== e[r + a] || n !== e[s + a]) {
                                    i = !0;
                                    break
                                }
                            }
                        }
                    if (i) {
                        if (a !== s) {
                            t[s] = t[a];
                            const r = a * n
                              , i = s * n;
                            for (let t = 0; t !== n; ++t)
                                e[i + t] = e[r + t]
                        }
                        ++s
                    }
                }
                if (i > 0) {
                    t[s] = t[i];
                    for (let t = i * n, r = s * n, a = 0; a !== n; ++a)
                        e[r + a] = e[t + a];
                    ++s
                }
                return s !== t.length ? (this.times = At.arraySlice(t, 0, s),
                this.values = At.arraySlice(e, 0, s * n)) : (this.times = t,
                this.values = e),
                this
            }
            clone() {
                const t = At.arraySlice(this.times, 0)
                  , e = At.arraySlice(this.values, 0)
                  , n = new (0,
                this.constructor)(this.name,t,e);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        Rt.prototype.TimeBufferType = Float32Array,
        Rt.prototype.ValueBufferType = Float32Array,
        Rt.prototype.DefaultInterpolation = C.NMF;
        class Lt extends Rt {
        }
        Lt.prototype.ValueTypeName = "number";
        class Pt extends F {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = (n - e) / (r - e);
                let l = t * a;
                for (let t = l + a; l !== t; l += 4)
                    O._.slerpFlat(i, 0, s, l - a, s, l, o);
                return i
            }
        }
        class Ct extends Rt {
            InterpolantFactoryMethodLinear(t) {
                return new Pt(this.times,this.values,this.getValueSize(),t)
            }
        }
        Ct.prototype.ValueTypeName = "quaternion",
        Ct.prototype.DefaultInterpolation = C.NMF,
        Ct.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Dt extends Rt {
        }
        Dt.prototype.ValueTypeName = "vector";
        class It extends Rt {
        }
        It.prototype.ValueTypeName = "bool",
        It.prototype.ValueBufferType = Array,
        It.prototype.DefaultInterpolation = C.Syv,
        It.prototype.InterpolantFactoryMethodLinear = void 0,
        It.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Nt extends Rt {
        }
        Nt.prototype.ValueTypeName = "color";
        class Ft extends Rt {
        }
        Ft.prototype.ValueTypeName = "string",
        Ft.prototype.ValueBufferType = Array,
        Ft.prototype.DefaultInterpolation = C.Syv,
        Ft.prototype.InterpolantFactoryMethodLinear = void 0,
        Ft.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Ot {
            constructor(t, e=-1, n, r=C.IFH) {
                this.name = t,
                this.tracks = n,
                this.duration = e,
                this.blendMode = r,
                this.uuid = A.DO(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = []
                  , n = t.tracks
                  , r = 1 / (t.fps || 1);
                for (let t = 0, i = n.length; t !== i; ++t)
                    e.push(Ut(n[t]).scale(r));
                const i = new this(t.name,t.duration,e,t.blendMode);
                return i.uuid = t.uuid,
                i
            }
            static toJSON(t) {
                const e = []
                  , n = t.tracks
                  , r = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
                for (let t = 0, r = n.length; t !== r; ++t)
                    e.push(Rt.toJSON(n[t]));
                return r
            }
            static CreateFromMorphTargetSequence(t, e, n, r) {
                const i = e.length
                  , s = [];
                for (let t = 0; t < i; t++) {
                    let a = []
                      , o = [];
                    a.push((t + i - 1) % i, t, (t + 1) % i),
                    o.push(0, 1, 0);
                    const l = At.getKeyframeOrder(a);
                    a = At.sortedArray(a, 1, l),
                    o = At.sortedArray(o, 1, l),
                    r || 0 !== a[0] || (a.push(i),
                    o.push(o[0])),
                    s.push(new Lt(".morphTargetInfluences[" + e[t].name + "]",a,o).scale(1 / n))
                }
                return new this(t,-1,s)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e)
                        return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const r = {}
                  , i = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e]
                      , s = n.name.match(i);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = r[t];
                        e || (r[t] = e = []),
                        e.push(n)
                    }
                }
                const s = [];
                for (const t in r)
                    s.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
                return s
            }
            static parseAnimation(t, e) {
                if (!t)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(t, e, n, r, i) {
                    if (0 !== n.length) {
                        const s = []
                          , a = [];
                        At.flattenJSON(n, s, a, r),
                        0 !== s.length && i.push(new t(e,s,a))
                    }
                }
                  , r = []
                  , i = t.name || "default"
                  , s = t.fps || 30
                  , a = t.blendMode;
                let o = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const i = l[t].keys;
                    if (i && 0 !== i.length)
                        if (i[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < i.length; e++)
                                if (i[e].morphTargets)
                                    for (let n = 0; n < i[e].morphTargets.length; n++)
                                        t[i[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = []
                                  , s = [];
                                for (let r = 0; r !== i[e].morphTargets.length; ++r) {
                                    const r = i[e];
                                    t.push(r.time),
                                    s.push(r.morphTarget === n ? 1 : 0)
                                }
                                r.push(new Lt(".morphTargetInfluence[" + n + "]",t,s))
                            }
                            o = t.length * (s || 1)
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(Dt, s + ".position", i, "pos", r),
                            n(Ct, s + ".quaternion", i, "rot", r),
                            n(Dt, s + ".scale", i, "scl", r)
                        }
                }
                if (0 === r.length)
                    return null;
                return new this(i,o,r,a)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t,
                this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++)
                    t.push(this.tracks[e].clone());
                return new this.constructor(this.name,this.duration,t,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function Ut(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Lt;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Dt;
                case "color":
                    return Nt;
                case "quaternion":
                    return Ct;
                case "bool":
                case "boolean":
                    return It;
                case "string":
                    return Ft
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = []
                  , n = [];
                At.flattenJSON(t.keys, e, n, "value"),
                t.times = e,
                t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        }
        class zt extends o.T {
            constructor() {
                super(),
                this.type = "Bone"
            }
        }
        zt.prototype.isBone = !0;
        var Bt = n(3993);
        const kt = new c.y
          , Gt = new c.y;
        class Ht {
            constructor(t=[], e=[]) {
                this.uuid = A.DO(),
                this.bones = t.slice(0),
                this.boneInverses = e,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.frame = -1,
                this.init()
            }
            init() {
                const t = this.bones
                  , e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length),
                0 === e.length)
                    this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++)
                        this.boneInverses.push(new c.y)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new c.y;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                    this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                    e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones
                  , e = this.boneInverses
                  , n = this.boneMatrices
                  , r = this.boneTexture;
                for (let r = 0, i = t.length; r < i; r++) {
                    const i = t[r] ? t[r].matrixWorld : Gt;
                    kt.multiplyMatrices(i, e[r]),
                    kt.toArray(n, 16 * r)
                }
                null !== r && (r.needsUpdate = !0)
            }
            clone() {
                return new Ht(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let t = Math.sqrt(4 * this.bones.length);
                t = A.h3(t),
                t = Math.max(t, 4);
                const e = new Float32Array(t * t * 4);
                e.set(this.boneMatrices);
                const n = new Bt.I(e,t,t,C.wk1,C.VzW);
                return this.boneMatrices = e,
                this.boneTexture = n,
                this.boneTextureSize = t,
                this
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, r = t.bones.length; n < r; n++) {
                    const r = t.bones[n];
                    let i = e[r];
                    void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
                    i = new zt),
                    this.bones.push(i),
                    this.boneInverses.push((new c.y).fromArray(t.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones
                  , n = this.boneInverses;
                for (let r = 0, i = e.length; r < i; r++) {
                    const i = e[r];
                    t.bones.push(i.uuid);
                    const s = n[r];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        }
        var Vt = n(1898);
        class Wt extends r.a {
            constructor(t) {
                super(t),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(t) {
                    return new Zt(t)
                }
                )),
                this.register((function(t) {
                    return new te(t)
                }
                )),
                this.register((function(t) {
                    return new ee(t)
                }
                )),
                this.register((function(t) {
                    return new Kt(t)
                }
                )),
                this.register((function(t) {
                    return new Jt(t)
                }
                )),
                this.register((function(t) {
                    return new Qt(t)
                }
                )),
                this.register((function(t) {
                    return new $t(t)
                }
                )),
                this.register((function(t) {
                    return new Yt(t)
                }
                )),
                this.register((function(t) {
                    return new ne(t)
                }
                ))
            }
            load(t, e, n, r) {
                const a = this;
                let o;
                o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i.extractUrlBase(t),
                this.manager.itemStart(t);
                const l = function(e) {
                    r ? r(e) : console.error(e),
                    a.manager.itemError(t),
                    a.manager.itemEnd(t)
                }
                  , c = new s.h(this.manager);
                c.setPath(this.path),
                c.setResponseType("arraybuffer"),
                c.setRequestHeader(this.requestHeader),
                c.setWithCredentials(this.withCredentials),
                c.load(t, (function(n) {
                    try {
                        a.parse(n, o, (function(n) {
                            e(n),
                            a.manager.itemEnd(t)
                        }
                        ), l)
                    } catch (t) {
                        l(t)
                    }
                }
                ), n, l)
            }
            setDRACOLoader(t) {
                return this.dracoLoader = t,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(t) {
                return this.ktx2Loader = t,
                this
            }
            setMeshoptDecoder(t) {
                return this.meshoptDecoder = t,
                this
            }
            register(t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
                this
            }
            unregister(t) {
                return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                this
            }
            parse(t, e, n, r) {
                let s;
                const a = {}
                  , o = {};
                if ("string" == typeof t)
                    s = t;
                else {
                    if (i.decodeText(new Uint8Array(t,0,4)) === re) {
                        try {
                            a[jt.KHR_BINARY_GLTF] = new ae(t)
                        } catch (t) {
                            return void (r && r(t))
                        }
                        s = a[jt.KHR_BINARY_GLTF].content
                    } else
                        s = i.decodeText(new Uint8Array(t))
                }
                const l = JSON.parse(s);
                if (void 0 === l.asset || l.asset.version[0] < 2)
                    return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const c = new Be(l,{
                    path: e || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                c.fileLoader.setRequestHeader(this.requestHeader);
                for (let t = 0; t < this.pluginCallbacks.length; t++) {
                    const e = this.pluginCallbacks[t](c);
                    o[e.name] = e,
                    a[e.name] = !0
                }
                if (l.extensionsUsed)
                    for (let t = 0; t < l.extensionsUsed.length; ++t) {
                        const e = l.extensionsUsed[t]
                          , n = l.extensionsRequired || [];
                        switch (e) {
                        case jt.KHR_MATERIALS_UNLIT:
                            a[e] = new qt;
                            break;
                        case jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            a[e] = new ue;
                            break;
                        case jt.KHR_DRACO_MESH_COMPRESSION:
                            a[e] = new oe(l,this.dracoLoader);
                            break;
                        case jt.KHR_TEXTURE_TRANSFORM:
                            a[e] = new le;
                            break;
                        case jt.KHR_MESH_QUANTIZATION:
                            a[e] = new he;
                            break;
                        default:
                            n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                c.setExtensions(a),
                c.setPlugins(o),
                c.parse(n, r)
            }
        }
        function Xt() {
            let t = {};
            return {
                get: function(e) {
                    return t[e]
                },
                add: function(e, n) {
                    t[e] = n
                },
                remove: function(e) {
                    delete t[e]
                },
                removeAll: function() {
                    t = {}
                }
            }
        }
        const jt = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        };
        class Yt {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const t = this.parser
                  , e = this.parser.json.nodes || [];
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
            _loadLight(t) {
                const e = this.parser
                  , n = "light:" + t;
                let r = e.cache.get(n);
                if (r)
                    return r;
                const i = e.json
                  , s = ((i.extensions && i.extensions[this.name] || {}).lights || [])[t];
                let o;
                const l = new a.I(16777215);
                void 0 !== s.color && l.fromArray(s.color);
                const c = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                case "directional":
                    o = new x(l),
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                case "point":
                    o = new E(l),
                    o.distance = c;
                    break;
                case "spot":
                    o = new L(l),
                    o.distance = c,
                    s.spot = s.spot || {},
                    s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                    s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                    o.angle = s.spot.outerConeAngle,
                    o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                }
                return o.position.set(0, 0, 0),
                o.decay = 2,
                void 0 !== s.intensity && (o.intensity = s.intensity),
                o.name = e.createUniqueName(s.name || "light_" + t),
                r = Promise.resolve(o),
                e.cache.add(n, r),
                r
            }
            createNodeAttachment(t) {
                const e = this
                  , n = this.parser
                  , r = n.json.nodes[t]
                  , i = (r.extensions && r.extensions[this.name] || {}).light;
                return void 0 === i ? null : this._loadLight(i).then((function(t) {
                    return n._getNodeRef(e.cache, i, t)
                }
                ))
            }
        }
        class qt {
            constructor() {
                this.name = jt.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return P.v
            }
            extendParams(t, e, n) {
                const r = [];
                t.color = new a.I(1,1,1),
                t.opacity = 1;
                const i = e.pbrMetallicRoughness;
                if (i) {
                    if (Array.isArray(i.baseColorFactor)) {
                        const e = i.baseColorFactor;
                        t.color.fromArray(e),
                        t.opacity = e[3]
                    }
                    void 0 !== i.baseColorTexture && r.push(n.assignTexture(t, "map", i.baseColorTexture))
                }
                return Promise.all(r)
            }
        }
        class Zt {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? N : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , s = r.extensions[this.name];
                if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
                void 0 !== s.clearcoatTexture && i.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
                void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
                void 0 !== s.clearcoatRoughnessTexture && i.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
                void 0 !== s.clearcoatNormalTexture && (i.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)),
                void 0 !== s.clearcoatNormalTexture.scale)) {
                    const t = s.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new u.F(t,-t)
                }
                return Promise.all(i)
            }
        }
        class Kt {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? N : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , s = r.extensions[this.name];
                return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
                void 0 !== s.transmissionTexture && i.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
                Promise.all(i)
            }
        }
        class Jt {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_MATERIALS_VOLUME
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? N : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , s = r.extensions[this.name];
                e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
                void 0 !== s.thicknessTexture && i.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
                e.attenuationDistance = s.attenuationDistance || 0;
                const o = s.attenuationColor || [1, 1, 1];
                return e.attenuationTint = new a.I(o[0],o[1],o[2]),
                Promise.all(i)
            }
        }
        class Qt {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_MATERIALS_IOR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? N : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const r = n.extensions[this.name];
                return e.ior = void 0 !== r.ior ? r.ior : 1.5,
                Promise.resolve()
            }
        }
        class $t {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? N : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const i = []
                  , s = r.extensions[this.name];
                e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
                void 0 !== s.specularTexture && i.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
                const o = s.specularColorFactor || [1, 1, 1];
                return e.specularTint = new a.I(o[0],o[1],o[2]),
                void 0 !== s.specularColorTexture && i.push(n.assignTexture(e, "specularTintMap", s.specularColorTexture).then((function(t) {
                    t.encoding = C.knz
                }
                ))),
                Promise.all(i)
            }
        }
        class te {
            constructor(t) {
                this.parser = t,
                this.name = jt.KHR_TEXTURE_BASISU
            }
            loadTexture(t) {
                const e = this.parser
                  , n = e.json
                  , r = n.textures[t];
                if (!r.extensions || !r.extensions[this.name])
                    return null;
                const i = r.extensions[this.name]
                  , s = n.images[i.source]
                  , a = e.options.ktx2Loader;
                if (!a) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return e.loadTextureImage(t, s, a)
            }
        }
        class ee {
            constructor(t) {
                this.parser = t,
                this.name = jt.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name
                  , n = this.parser
                  , r = n.json
                  , i = r.textures[t];
                if (!i.extensions || !i.extensions[e])
                    return null;
                const s = i.extensions[e]
                  , a = r.images[s.source];
                let o = n.textureLoader;
                if (a.uri) {
                    const t = n.options.manager.getHandler(a.uri);
                    null !== t && (o = t)
                }
                return this.detectSupport().then((function(i) {
                    if (i)
                        return n.loadTextureImage(t, a, o);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(t)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(t) {
                    const e = new Image;
                    e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    e.onload = e.onerror = function() {
                        t(1 === e.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class ne {
            constructor(t) {
                this.name = jt.EXT_MESHOPT_COMPRESSION,
                this.parser = t
            }
            loadBufferView(t) {
                const e = this.parser.json
                  , n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                    const t = n.extensions[this.name]
                      , r = this.parser.getDependency("buffer", t.buffer)
                      , i = this.parser.options.meshoptDecoder;
                    if (!i || !i.supported) {
                        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return Promise.all([r, i.ready]).then((function(e) {
                        const n = t.byteOffset || 0
                          , r = t.byteLength || 0
                          , s = t.count
                          , a = t.byteStride
                          , o = new ArrayBuffer(s * a)
                          , l = new Uint8Array(e[0],n,r);
                        return i.decodeGltfBuffer(new Uint8Array(o), s, a, l, t.mode, t.filter),
                        o
                    }
                    ))
                }
                return null
            }
        }
        const re = "glTF"
          , ie = 1313821514
          , se = 5130562;
        class ae {
            constructor(t) {
                this.name = jt.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const e = new DataView(t,0,12);
                if (this.header = {
                    magic: i.decodeText(new Uint8Array(t.slice(0, 4))),
                    version: e.getUint32(4, !0),
                    length: e.getUint32(8, !0)
                },
                this.header.magic !== re)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - 12
                  , r = new DataView(t,12);
                let s = 0;
                for (; s < n; ) {
                    const e = r.getUint32(s, !0);
                    s += 4;
                    const n = r.getUint32(s, !0);
                    if (s += 4,
                    n === ie) {
                        const n = new Uint8Array(t,12 + s,e);
                        this.content = i.decodeText(n)
                    } else if (n === se) {
                        const n = 12 + s;
                        this.body = t.slice(n, n + e)
                    }
                    s += e
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class oe {
            constructor(t, e) {
                if (!e)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = jt.KHR_DRACO_MESH_COMPRESSION,
                this.json = t,
                this.dracoLoader = e,
                this.dracoLoader.preload()
            }
            decodePrimitive(t, e) {
                const n = this.json
                  , r = this.dracoLoader
                  , i = t.extensions[this.name].bufferView
                  , s = t.extensions[this.name].attributes
                  , a = {}
                  , o = {}
                  , l = {};
                for (const t in s) {
                    const e = Ee[t] || t.toLowerCase();
                    a[e] = s[t]
                }
                for (const e in t.attributes) {
                    const r = Ee[e] || e.toLowerCase();
                    if (void 0 !== s[e]) {
                        const i = n.accessors[t.attributes[e]]
                          , s = we[i.componentType];
                        l[r] = s,
                        o[r] = !0 === i.normalized
                    }
                }
                return e.getDependency("bufferView", i).then((function(t) {
                    return new Promise((function(e) {
                        r.decodeDracoFile(t, (function(t) {
                            for (const e in t.attributes) {
                                const n = t.attributes[e]
                                  , r = o[e];
                                void 0 !== r && (n.normalized = r)
                            }
                            e(t)
                        }
                        ), a, l)
                    }
                    ))
                }
                ))
            }
        }
        class le {
            constructor() {
                this.name = jt.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(t, e) {
                return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
                void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(),
                void 0 !== e.offset && t.offset.fromArray(e.offset),
                void 0 !== e.rotation && (t.rotation = e.rotation),
                void 0 !== e.scale && t.repeat.fromArray(e.scale),
                t.needsUpdate = !0),
                t
            }
        }
        class ce extends I {
            constructor(t) {
                super(),
                this.isGLTFSpecularGlossinessMaterial = !0;
                const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
                  , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
                  , r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
                  , i = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
                  , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
                  , o = {
                    specular: {
                        value: (new a.I).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
                this._extraUniforms = o,
                this.onBeforeCompile = function(t) {
                    for (const e in o)
                        t.uniforms[e] = o[e];
                    t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", i).replace("#include <lights_physical_fragment>", s)
                }
                ,
                Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return o.specular.value
                        },
                        set: function(t) {
                            o.specular.value = t
                        }
                    },
                    specularMap: {
                        get: function() {
                            return o.specularMap.value
                        },
                        set: function(t) {
                            o.specularMap.value = t,
                            t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function() {
                            return o.glossiness.value
                        },
                        set: function(t) {
                            o.glossiness.value = t
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return o.glossinessMap.value
                        },
                        set: function(t) {
                            o.glossinessMap.value = t,
                            t ? (this.defines.USE_GLOSSINESSMAP = "",
                            this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                            delete this.defines.USE_UV)
                        }
                    }
                }),
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.specularMap = t.specularMap,
                this.specular.copy(t.specular),
                this.glossinessMap = t.glossinessMap,
                this.glossiness = t.glossiness,
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this
            }
        }
        class ue {
            constructor() {
                this.name = jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
            }
            getMaterialType() {
                return ce
            }
            extendParams(t, e, n) {
                const r = e.extensions[this.name];
                t.color = new a.I(1,1,1),
                t.opacity = 1;
                const i = [];
                if (Array.isArray(r.diffuseFactor)) {
                    const e = r.diffuseFactor;
                    t.color.fromArray(e),
                    t.opacity = e[3]
                }
                if (void 0 !== r.diffuseTexture && i.push(n.assignTexture(t, "map", r.diffuseTexture)),
                t.emissive = new a.I(0,0,0),
                t.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1,
                t.specular = new a.I(1,1,1),
                Array.isArray(r.specularFactor) && t.specular.fromArray(r.specularFactor),
                void 0 !== r.specularGlossinessTexture) {
                    const e = r.specularGlossinessTexture;
                    i.push(n.assignTexture(t, "glossinessMap", e)),
                    i.push(n.assignTexture(t, "specularMap", e))
                }
                return Promise.all(i)
            }
            createMaterial(t) {
                const e = new ce(t);
                return e.fog = !0,
                e.color = t.color,
                e.map = void 0 === t.map ? null : t.map,
                e.lightMap = null,
                e.lightMapIntensity = 1,
                e.aoMap = void 0 === t.aoMap ? null : t.aoMap,
                e.aoMapIntensity = 1,
                e.emissive = t.emissive,
                e.emissiveIntensity = 1,
                e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap,
                e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap,
                e.bumpScale = 1,
                e.normalMap = void 0 === t.normalMap ? null : t.normalMap,
                e.normalMapType = C.IOt,
                t.normalScale && (e.normalScale = t.normalScale),
                e.displacementMap = null,
                e.displacementScale = 1,
                e.displacementBias = 0,
                e.specularMap = void 0 === t.specularMap ? null : t.specularMap,
                e.specular = t.specular,
                e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap,
                e.glossiness = t.glossiness,
                e.alphaMap = null,
                e.envMap = void 0 === t.envMap ? null : t.envMap,
                e.envMapIntensity = 1,
                e.refractionRatio = .98,
                e
            }
        }
        class he {
            constructor() {
                this.name = jt.KHR_MESH_QUANTIZATION
            }
        }
        class de extends F {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , r = this.valueSize
                  , i = t * r * 3 + r;
                for (let t = 0; t !== r; t++)
                    e[t] = n[i + t];
                return e
            }
        }
        de.prototype.beforeStart_ = de.prototype.copySampleValue_,
        de.prototype.afterEnd_ = de.prototype.copySampleValue_,
        de.prototype.interpolate_ = function(t, e, n, r) {
            const i = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = 2 * a
              , l = 3 * a
              , c = r - e
              , u = (n - e) / c
              , h = u * u
              , d = h * u
              , f = t * l
              , p = f - l
              , m = -2 * d + 3 * h
              , g = d - h
              , v = 1 - m
              , _ = g - h + u;
            for (let t = 0; t !== a; t++) {
                const e = s[p + t + a]
                  , n = s[p + t + o] * c
                  , r = s[f + t + a]
                  , l = s[f + t] * c;
                i[t] = v * e + _ * n + m * r + g * l
            }
            return i
        }
        ;
        const fe = new O._;
        class pe extends de {
            interpolate_(t, e, n, r) {
                const i = super.interpolate_(t, e, n, r);
                return fe.fromArray(i).normalize().toArray(i),
                i
            }
        }
        const me = 0
          , ge = 1
          , ve = 2
          , _e = 3
          , ye = 4
          , xe = 5
          , be = 6
          , we = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , Me = {
            9728: C.TyD,
            9729: C.wem,
            9984: C.YLQ,
            9985: C.qyh,
            9986: C.aH4,
            9987: C.D1R
        }
          , Te = {
            33071: C.uWy,
            33648: C.OoA,
            10497: C.rpg
        }
          , Se = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , Ee = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , Ae = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , Re = {
            CUBICSPLINE: void 0,
            LINEAR: C.NMF,
            STEP: C.Syv
        }
          , Le = "OPAQUE"
          , Pe = "MASK"
          , Ce = "BLEND";
        function De(t, e) {
            return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
        }
        function Ie(t, e, n) {
            for (const r in n.extensions)
                void 0 === t[r] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
                e.userData.gltfExtensions[r] = n.extensions[r])
        }
        function Ne(t, e) {
            void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }
        function Fe(t, e) {
            if (t.updateMorphTargets(),
            void 0 !== e.weights)
                for (let n = 0, r = e.weights.length; n < r; n++)
                    t.morphTargetInfluences[n] = e.weights[n];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const n = e.extras.targetNames;
                if (t.morphTargetInfluences.length === n.length) {
                    t.morphTargetDictionary = {};
                    for (let e = 0, r = n.length; e < r; e++)
                        t.morphTargetDictionary[n[e]] = e
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function Oe(t) {
            const e = t.extensions && t.extensions[jt.KHR_DRACO_MESH_COMPRESSION];
            let n;
            return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + Ue(e.attributes) : t.indices + ":" + Ue(t.attributes) + ":" + t.mode,
            n
        }
        function Ue(t) {
            let e = "";
            const n = Object.keys(t).sort();
            for (let r = 0, i = n.length; r < i; r++)
                e += n[r] + ":" + t[n[r]] + ";";
            return e
        }
        function ze(t) {
            switch (t) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        class Be {
            constructor(t={}, e={}) {
                this.json = t,
                this.extensions = {},
                this.plugins = {},
                this.options = e,
                this.cache = new Xt,
                this.associations = new Map,
                this.primitiveCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.textureCache = {},
                this.nodeNamesUsed = {},
                "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new z(this.options.manager) : this.textureLoader = new B.d(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new s.h(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(t) {
                this.extensions = t
            }
            setPlugins(t) {
                this.plugins = t
            }
            parse(t, e) {
                const n = this
                  , r = this.json
                  , i = this.extensions;
                this.cache.removeAll(),
                this._invokeAll((function(t) {
                    return t._markDefs && t._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(t) {
                    return t.beforeRoot && t.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(e) {
                    const s = {
                        scene: e[0][r.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: r.asset,
                        parser: n,
                        userData: {}
                    };
                    Ie(i, s, r),
                    Ne(s, r),
                    Promise.all(n._invokeAll((function(t) {
                        return t.afterRoot && t.afterRoot(s)
                    }
                    ))).then((function() {
                        t(s)
                    }
                    ))
                }
                )).catch(e)
            }
            _markDefs() {
                const t = this.json.nodes || []
                  , e = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n].joints;
                    for (let e = 0, n = r.length; e < n; e++)
                        t[r[e]].isBone = !0
                }
                for (let e = 0, r = t.length; e < r; e++) {
                    const r = t[e];
                    void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh),
                    void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)),
                    void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
                }
            }
            _addNodeRef(t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
                t.refs[e]++)
            }
            _getNodeRef(t, e, n) {
                if (t.refs[e] <= 1)
                    return n;
                const r = n.clone();
                return r.name += "_instance_" + t.uses[e]++,
                r
            }
            _invokeOne(t) {
                const e = Object.values(this.plugins);
                e.push(this);
                for (let n = 0; n < e.length; n++) {
                    const r = t(e[n]);
                    if (r)
                        return r
                }
                return null
            }
            _invokeAll(t) {
                const e = Object.values(this.plugins);
                e.unshift(this);
                const n = [];
                for (let r = 0; r < e.length; r++) {
                    const i = t(e[r]);
                    i && n.push(i)
                }
                return n
            }
            getDependency(t, e) {
                const n = t + ":" + e;
                let r = this.cache.get(n);
                if (!r) {
                    switch (t) {
                    case "scene":
                        r = this.loadScene(e);
                        break;
                    case "node":
                        r = this.loadNode(e);
                        break;
                    case "mesh":
                        r = this._invokeOne((function(t) {
                            return t.loadMesh && t.loadMesh(e)
                        }
                        ));
                        break;
                    case "accessor":
                        r = this.loadAccessor(e);
                        break;
                    case "bufferView":
                        r = this._invokeOne((function(t) {
                            return t.loadBufferView && t.loadBufferView(e)
                        }
                        ));
                        break;
                    case "buffer":
                        r = this.loadBuffer(e);
                        break;
                    case "material":
                        r = this._invokeOne((function(t) {
                            return t.loadMaterial && t.loadMaterial(e)
                        }
                        ));
                        break;
                    case "texture":
                        r = this._invokeOne((function(t) {
                            return t.loadTexture && t.loadTexture(e)
                        }
                        ));
                        break;
                    case "skin":
                        r = this.loadSkin(e);
                        break;
                    case "animation":
                        r = this.loadAnimation(e);
                        break;
                    case "camera":
                        r = this.loadCamera(e);
                        break;
                    default:
                        throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, r)
                }
                return r
            }
            getDependencies(t) {
                let e = this.cache.get(t);
                if (!e) {
                    const n = this
                      , r = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(r.map((function(e, r) {
                        return n.getDependency(t, r)
                    }
                    ))),
                    this.cache.add(t, e)
                }
                return e
            }
            loadBuffer(t) {
                const e = this.json.buffers[t]
                  , n = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type)
                    throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t)
                    return Promise.resolve(this.extensions[jt.KHR_BINARY_GLTF].body);
                const r = this.options;
                return new Promise((function(t, i) {
                    n.load(De(e.uri, r.path), t, void 0, (function() {
                        i(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(t) {
                const e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function(t) {
                    const n = e.byteLength || 0
                      , r = e.byteOffset || 0;
                    return t.slice(r, r + n)
                }
                ))
            }
            loadAccessor(t) {
                const e = this
                  , n = this.json
                  , r = this.json.accessors[t];
                if (void 0 === r.bufferView && void 0 === r.sparse)
                    return Promise.resolve(null);
                const i = [];
                return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null),
                void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
                i.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
                Promise.all(i).then((function(t) {
                    const i = t[0]
                      , s = Se[r.type]
                      , a = we[r.componentType]
                      , o = a.BYTES_PER_ELEMENT
                      , l = o * s
                      , c = r.byteOffset || 0
                      , u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0
                      , h = !0 === r.normalized;
                    let d, f;
                    if (u && u !== l) {
                        const t = Math.floor(c / u)
                          , n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + t + ":" + r.count;
                        let l = e.cache.get(n);
                        l || (d = new a(i,t * u,r.count * u / o),
                        l = new k(d,u / o),
                        e.cache.add(n, l)),
                        f = new V(l,s,c % u / o,h)
                    } else
                        d = null === i ? new a(r.count * s) : new a(i,c,r.count * s),
                        f = new G.Tl(d,s,h);
                    if (void 0 !== r.sparse) {
                        const e = Se.SCALAR
                          , n = we[r.sparse.indices.componentType]
                          , o = r.sparse.indices.byteOffset || 0
                          , l = r.sparse.values.byteOffset || 0
                          , c = new n(t[1],o,r.sparse.count * e)
                          , u = new a(t[2],l,r.sparse.count * s);
                        null !== i && (f = new G.Tl(f.array.slice(),f.itemSize,f.normalized));
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            if (f.setX(e, u[t * s]),
                            s >= 2 && f.setY(e, u[t * s + 1]),
                            s >= 3 && f.setZ(e, u[t * s + 2]),
                            s >= 4 && f.setW(e, u[t * s + 3]),
                            s >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return f
                }
                ))
            }
            loadTexture(t) {
                const e = this.json
                  , n = this.options
                  , r = e.textures[t]
                  , i = e.images[r.source];
                let s = this.textureLoader;
                if (i.uri) {
                    const t = n.manager.getHandler(i.uri);
                    null !== t && (s = t)
                }
                return this.loadTextureImage(t, i, s)
            }
            loadTextureImage(t, e, n) {
                const r = this
                  , i = this.json
                  , s = this.options
                  , a = i.textures[t]
                  , o = (e.uri || e.bufferView) + ":" + a.sampler;
                if (this.textureCache[o])
                    return this.textureCache[o];
                const l = self.URL || self.webkitURL;
                let c = e.uri || ""
                  , u = !1
                  , h = !0;
                const d = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/);
                if (("image/jpeg" === e.mimeType || d) && (h = !1),
                void 0 !== e.bufferView)
                    c = r.getDependency("bufferView", e.bufferView).then((function(t) {
                        if ("image/png" === e.mimeType) {
                            const e = new DataView(t,25,1).getUint8(0, !1);
                            h = 6 === e || 4 === e || 3 === e
                        }
                        u = !0;
                        const n = new Blob([t],{
                            type: e.mimeType
                        });
                        return c = l.createObjectURL(n),
                        c
                    }
                    ));
                else if (void 0 === e.uri)
                    throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                const f = Promise.resolve(c).then((function(t) {
                    return new Promise((function(e, r) {
                        let i = e;
                        !0 === n.isImageBitmapLoader && (i = function(t) {
                            const n = new W.x(t);
                            n.needsUpdate = !0,
                            e(n)
                        }
                        ),
                        n.load(De(t, s.path), i, void 0, r)
                    }
                    ))
                }
                )).then((function(e) {
                    !0 === u && l.revokeObjectURL(c),
                    e.flipY = !1,
                    a.name && (e.name = a.name),
                    h || (e.format = C.UCm);
                    const n = (i.samplers || {})[a.sampler] || {};
                    return e.magFilter = Me[n.magFilter] || C.wem,
                    e.minFilter = Me[n.minFilter] || C.D1R,
                    e.wrapS = Te[n.wrapS] || C.rpg,
                    e.wrapT = Te[n.wrapT] || C.rpg,
                    r.associations.set(e, {
                        type: "textures",
                        index: t
                    }),
                    e
                }
                )).catch((function() {
                    return console.error("THREE.GLTFLoader: Couldn't load texture", c),
                    null
                }
                ));
                return this.textureCache[o] = f,
                f
            }
            assignTexture(t, e, n) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(i) {
                    if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."),
                    r.extensions[jt.KHR_TEXTURE_TRANSFORM]) {
                        const t = void 0 !== n.extensions ? n.extensions[jt.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (t) {
                            const e = r.associations.get(i);
                            i = r.extensions[jt.KHR_TEXTURE_TRANSFORM].extendTexture(i, t),
                            r.associations.set(i, e)
                        }
                    }
                    return t[e] = i,
                    i
                }
                ))
            }
            assignFinalMaterial(t) {
                const e = t.geometry;
                let n = t.material;
                const r = void 0 !== e.attributes.tangent
                  , i = void 0 !== e.attributes.color
                  , s = void 0 === e.attributes.normal;
                if (t.isPoints) {
                    const t = "PointsMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new X,
                    D.F.prototype.copy.call(e, n),
                    e.color.copy(n.color),
                    e.map = n.map,
                    e.sizeAttenuation = !1,
                    this.cache.add(t, e)),
                    n = e
                } else if (t.isLine) {
                    const t = "LineBasicMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new j.n,
                    D.F.prototype.copy.call(e, n),
                    e.color.copy(n.color),
                    this.cache.add(t, e)),
                    n = e
                }
                if (r || i || s) {
                    let t = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
                    r && (t += "vertex-tangents:"),
                    i && (t += "vertex-colors:"),
                    s && (t += "flat-shading:");
                    let e = this.cache.get(t);
                    e || (e = n.clone(),
                    i && (e.vertexColors = !0),
                    s && (e.flatShading = !0),
                    r && (e.normalScale && (e.normalScale.y *= -1),
                    e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                    this.cache.add(t, e),
                    this.associations.set(e, this.associations.get(n))),
                    n = e
                }
                n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv),
                t.material = n
            }
            getMaterialType() {
                return I
            }
            loadMaterial(t) {
                const e = this
                  , n = this.json
                  , r = this.extensions
                  , i = n.materials[t];
                let s;
                const o = {}
                  , l = i.extensions || {}
                  , c = [];
                if (l[jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    const t = r[jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    s = t.getMaterialType(),
                    c.push(t.extendParams(o, i, e))
                } else if (l[jt.KHR_MATERIALS_UNLIT]) {
                    const t = r[jt.KHR_MATERIALS_UNLIT];
                    s = t.getMaterialType(),
                    c.push(t.extendParams(o, i, e))
                } else {
                    const n = i.pbrMetallicRoughness || {};
                    if (o.color = new a.I(1,1,1),
                    o.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const t = n.baseColorFactor;
                        o.color.fromArray(t),
                        o.opacity = t[3]
                    }
                    void 0 !== n.baseColorTexture && c.push(e.assignTexture(o, "map", n.baseColorTexture)),
                    o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (c.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)),
                    c.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))),
                    s = this._invokeOne((function(e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    }
                    )),
                    c.push(Promise.all(this._invokeAll((function(e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, o)
                    }
                    ))))
                }
                !0 === i.doubleSided && (o.side = C.ehD);
                const h = i.alphaMode || Le;
                return h === Ce ? (o.transparent = !0,
                o.depthWrite = !1) : (o.format = C.UCm,
                o.transparent = !1,
                h === Pe && (o.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)),
                void 0 !== i.normalTexture && s !== P.v && (c.push(e.assignTexture(o, "normalMap", i.normalTexture)),
                o.normalScale = new u.F(1,-1),
                void 0 !== i.normalTexture.scale && o.normalScale.set(i.normalTexture.scale, -i.normalTexture.scale)),
                void 0 !== i.occlusionTexture && s !== P.v && (c.push(e.assignTexture(o, "aoMap", i.occlusionTexture)),
                void 0 !== i.occlusionTexture.strength && (o.aoMapIntensity = i.occlusionTexture.strength)),
                void 0 !== i.emissiveFactor && s !== P.v && (o.emissive = (new a.I).fromArray(i.emissiveFactor)),
                void 0 !== i.emissiveTexture && s !== P.v && c.push(e.assignTexture(o, "emissiveMap", i.emissiveTexture)),
                Promise.all(c).then((function() {
                    let n;
                    return n = s === ce ? r[jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o),
                    i.name && (n.name = i.name),
                    n.map && (n.map.encoding = C.knz),
                    n.emissiveMap && (n.emissiveMap.encoding = C.knz),
                    Ne(n, i),
                    e.associations.set(n, {
                        type: "materials",
                        index: t
                    }),
                    i.extensions && Ie(r, n, i),
                    n
                }
                ))
            }
            createUniqueName(t) {
                const e = rt.sanitizeNodeName(t || "");
                let n = e;
                for (let t = 1; this.nodeNamesUsed[n]; ++t)
                    n = e + "_" + t;
                return this.nodeNamesUsed[n] = !0,
                n
            }
            loadGeometries(t) {
                const e = this
                  , n = this.extensions
                  , r = this.primitiveCache;
                function i(t) {
                    return n[jt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                        return Ge(n, t, e)
                    }
                    ))
                }
                const s = [];
                for (let n = 0, a = t.length; n < a; n++) {
                    const a = t[n]
                      , o = Oe(a)
                      , l = r[o];
                    if (l)
                        s.push(l.promise);
                    else {
                        let t;
                        t = a.extensions && a.extensions[jt.KHR_DRACO_MESH_COMPRESSION] ? i(a) : Ge(new it.u, a, e),
                        r[o] = {
                            primitive: a,
                            promise: t
                        },
                        s.push(t)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(t) {
                const e = this
                  , n = this.json
                  , r = this.extensions
                  , i = n.meshes[t]
                  , s = i.primitives
                  , a = [];
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = void 0 === s[t].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new I({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: C.Wl3
                    })),
                    o.DefaultMaterial) : this.getDependency("material", s[t].material);
                    a.push(e)
                }
                var o;
                return a.push(e.loadGeometries(s)),
                Promise.all(a).then((function(n) {
                    const a = n.slice(0, n.length - 1)
                      , o = n[n.length - 1]
                      , l = [];
                    for (let n = 0, c = o.length; n < c; n++) {
                        const c = o[n]
                          , u = s[n];
                        let h;
                        const d = a[n];
                        if (u.mode === ye || u.mode === xe || u.mode === be || void 0 === u.mode)
                            h = !0 === i.isSkinnedMesh ? new ht(c,d) : new st.K(c,d),
                            !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(),
                            u.mode === xe ? h.geometry = He(h.geometry, C.UlW) : u.mode === be && (h.geometry = He(h.geometry, C.z$h));
                        else if (u.mode === ge)
                            h = new dt.e(c,d);
                        else if (u.mode === _e)
                            h = new ft.x(c,d);
                        else if (u.mode === ve)
                            h = new pt(c,d);
                        else {
                            if (u.mode !== me)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                            h = new bt(c,d)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && Fe(h, i),
                        h.name = e.createUniqueName(i.name || "mesh_" + t),
                        Ne(h, i),
                        u.extensions && Ie(r, h, u),
                        e.assignFinalMaterial(h),
                        l.push(h)
                    }
                    if (1 === l.length)
                        return l[0];
                    const c = new Mt.Z;
                    for (let t = 0, e = l.length; t < e; t++)
                        c.add(l[t]);
                    return c
                }
                ))
            }
            loadCamera(t) {
                let e;
                const n = this.json.cameras[t]
                  , r = n[n.type];
                if (r)
                    return "perspective" === n.type ? e = new b.c(A.ZY(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : "orthographic" === n.type && (e = new _.i(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
                    n.name && (e.name = this.createUniqueName(n.name)),
                    Ne(e, n),
                    Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(t) {
                const e = this.json.skins[t]
                  , n = {
                    joints: e.joints
                };
                return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                    return n.inverseBindMatrices = t,
                    n
                }
                ))
            }
            loadAnimation(t) {
                const e = this.json.animations[t]
                  , n = []
                  , r = []
                  , i = []
                  , s = []
                  , a = [];
                for (let t = 0, o = e.channels.length; t < o; t++) {
                    const o = e.channels[t]
                      , l = e.samplers[o.sampler]
                      , c = o.target
                      , u = void 0 !== c.node ? c.node : c.id
                      , h = void 0 !== e.parameters ? e.parameters[l.input] : l.input
                      , d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                    n.push(this.getDependency("node", u)),
                    r.push(this.getDependency("accessor", h)),
                    i.push(this.getDependency("accessor", d)),
                    s.push(l),
                    a.push(c)
                }
                return Promise.all([Promise.all(n), Promise.all(r), Promise.all(i), Promise.all(s), Promise.all(a)]).then((function(n) {
                    const r = n[0]
                      , i = n[1]
                      , s = n[2]
                      , a = n[3]
                      , o = n[4]
                      , l = [];
                    for (let t = 0, e = r.length; t < e; t++) {
                        const e = r[t]
                          , n = i[t]
                          , c = s[t]
                          , u = a[t]
                          , h = o[t];
                        if (void 0 === e)
                            continue;
                        let d;
                        switch (e.updateMatrix(),
                        e.matrixAutoUpdate = !0,
                        Ae[h.path]) {
                        case Ae.weights:
                            d = Lt;
                            break;
                        case Ae.rotation:
                            d = Ct;
                            break;
                        default:
                            d = Dt
                        }
                        const f = e.name ? e.name : e.uuid
                          , p = void 0 !== u.interpolation ? Re[u.interpolation] : C.NMF
                          , m = [];
                        Ae[h.path] === Ae.weights ? e.traverse((function(t) {
                            !0 === t.isMesh && t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid)
                        }
                        )) : m.push(f);
                        let g = c.array;
                        if (c.normalized) {
                            const t = ze(g.constructor)
                              , e = new Float32Array(g.length);
                            for (let n = 0, r = g.length; n < r; n++)
                                e[n] = g[n] * t;
                            g = e
                        }
                        for (let t = 0, e = m.length; t < e; t++) {
                            const e = new d(m[t] + "." + Ae[h.path],n.array,g,p);
                            "CUBICSPLINE" === u.interpolation && (e.createInterpolant = function(t) {
                                return new (this instanceof Ct ? pe : de)(this.times,this.values,this.getValueSize() / 3,t)
                            }
                            ,
                            e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                            l.push(e)
                        }
                    }
                    const c = e.name ? e.name : "animation_" + t;
                    return new Ot(c,void 0,l)
                }
                ))
            }
            createNodeMesh(t) {
                const e = this.json
                  , n = this
                  , r = e.nodes[t];
                return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(t) {
                    const e = n._getNodeRef(n.meshCache, r.mesh, t);
                    return void 0 !== r.weights && e.traverse((function(t) {
                        if (t.isMesh)
                            for (let e = 0, n = r.weights.length; e < n; e++)
                                t.morphTargetInfluences[e] = r.weights[e]
                    }
                    )),
                    e
                }
                ))
            }
            loadNode(t) {
                const e = this.json
                  , n = this.extensions
                  , r = this
                  , i = e.nodes[t]
                  , s = i.name ? r.createUniqueName(i.name) : "";
                return function() {
                    const e = []
                      , n = r._invokeOne((function(e) {
                        return e.createNodeMesh && e.createNodeMesh(t)
                    }
                    ));
                    return n && e.push(n),
                    void 0 !== i.camera && e.push(r.getDependency("camera", i.camera).then((function(t) {
                        return r._getNodeRef(r.cameraCache, i.camera, t)
                    }
                    ))),
                    r._invokeAll((function(e) {
                        return e.createNodeAttachment && e.createNodeAttachment(t)
                    }
                    )).forEach((function(t) {
                        e.push(t)
                    }
                    )),
                    Promise.all(e)
                }().then((function(e) {
                    let a;
                    if (a = !0 === i.isBone ? new zt : e.length > 1 ? new Mt.Z : 1 === e.length ? e[0] : new o.T,
                    a !== e[0])
                        for (let t = 0, n = e.length; t < n; t++)
                            a.add(e[t]);
                    if (i.name && (a.userData.name = i.name,
                    a.name = s),
                    Ne(a, i),
                    i.extensions && Ie(n, a, i),
                    void 0 !== i.matrix) {
                        const t = new c.y;
                        t.fromArray(i.matrix),
                        a.applyMatrix4(t)
                    } else
                        void 0 !== i.translation && a.position.fromArray(i.translation),
                        void 0 !== i.rotation && a.quaternion.fromArray(i.rotation),
                        void 0 !== i.scale && a.scale.fromArray(i.scale);
                    return r.associations.set(a, {
                        type: "nodes",
                        index: t
                    }),
                    a
                }
                ))
            }
            loadScene(t) {
                const e = this.json
                  , n = this.extensions
                  , r = this.json.scenes[t]
                  , i = this
                  , s = new Mt.Z;
                r.name && (s.name = i.createUniqueName(r.name)),
                Ne(s, r),
                r.extensions && Ie(n, s, r);
                const a = r.nodes || []
                  , o = [];
                for (let t = 0, n = a.length; t < n; t++)
                    o.push(ke(a[t], s, e, i));
                return Promise.all(o).then((function() {
                    return s
                }
                ))
            }
        }
        function ke(t, e, n, r) {
            const i = n.nodes[t];
            return r.getDependency("node", t).then((function(t) {
                if (void 0 === i.skin)
                    return t;
                let e;
                return r.getDependency("skin", i.skin).then((function(t) {
                    e = t;
                    const n = [];
                    for (let t = 0, i = e.joints.length; t < i; t++)
                        n.push(r.getDependency("node", e.joints[t]));
                    return Promise.all(n)
                }
                )).then((function(n) {
                    return t.traverse((function(t) {
                        if (!t.isMesh)
                            return;
                        const r = []
                          , i = [];
                        for (let t = 0, s = n.length; t < s; t++) {
                            const s = n[t];
                            if (s) {
                                r.push(s);
                                const n = new c.y;
                                void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t),
                                i.push(n)
                            } else
                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                        }
                        t.bind(new Ht(r,i), t.matrixWorld)
                    }
                    )),
                    t
                }
                ))
            }
            )).then((function(t) {
                e.add(t);
                const s = [];
                if (i.children) {
                    const e = i.children;
                    for (let i = 0, a = e.length; i < a; i++) {
                        const a = e[i];
                        s.push(ke(a, t, n, r))
                    }
                }
                return Promise.all(s)
            }
            ))
        }
        function Ge(t, e, n) {
            const r = e.attributes
              , i = [];
            function s(e, r) {
                return n.getDependency("accessor", e).then((function(e) {
                    t.setAttribute(r, e)
                }
                ))
            }
            for (const e in r) {
                const n = Ee[e] || e.toLowerCase();
                n in t.attributes || i.push(s(r[e], n))
            }
            if (void 0 !== e.indices && !t.index) {
                const r = n.getDependency("accessor", e.indices).then((function(e) {
                    t.setIndex(e)
                }
                ));
                i.push(r)
            }
            return Ne(t, e),
            function(t, e, n) {
                const r = e.attributes
                  , i = new Vt.Z;
                if (void 0 === r.POSITION)
                    return;
                {
                    const t = n.json.accessors[r.POSITION]
                      , e = t.min
                      , s = t.max;
                    if (void 0 === e || void 0 === s)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (i.set(new h.P(e[0],e[1],e[2]), new h.P(s[0],s[1],s[2])),
                    t.normalized) {
                        const e = ze(we[t.componentType]);
                        i.min.multiplyScalar(e),
                        i.max.multiplyScalar(e)
                    }
                }
                const s = e.targets;
                if (void 0 !== s) {
                    const t = new h.P
                      , e = new h.P;
                    for (let r = 0, i = s.length; r < i; r++) {
                        const i = s[r];
                        if (void 0 !== i.POSITION) {
                            const r = n.json.accessors[i.POSITION]
                              , s = r.min
                              , a = r.max;
                            if (void 0 !== s && void 0 !== a) {
                                if (e.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                                e.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                                e.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                                r.normalized) {
                                    const t = ze(we[r.componentType]);
                                    e.multiplyScalar(t)
                                }
                                t.max(e)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    i.expandByVector(t)
                }
                t.boundingBox = i;
                const a = new mt.a;
                i.getCenter(a.center),
                a.radius = i.min.distanceTo(i.max) / 2,
                t.boundingSphere = a
            }(t, e, n),
            Promise.all(i).then((function() {
                return void 0 !== e.targets ? function(t, e, n) {
                    let r = !1
                      , i = !1;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        if (void 0 !== n.POSITION && (r = !0),
                        void 0 !== n.NORMAL && (i = !0),
                        r && i)
                            break
                    }
                    if (!r && !i)
                        return Promise.resolve(t);
                    const s = []
                      , a = [];
                    for (let o = 0, l = e.length; o < l; o++) {
                        const l = e[o];
                        if (r) {
                            const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                            s.push(e)
                        }
                        if (i) {
                            const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                            a.push(e)
                        }
                    }
                    return Promise.all([Promise.all(s), Promise.all(a)]).then((function(e) {
                        const n = e[0]
                          , s = e[1];
                        return r && (t.morphAttributes.position = n),
                        i && (t.morphAttributes.normal = s),
                        t.morphTargetsRelative = !0,
                        t
                    }
                    ))
                }(t, e.targets, n) : t
            }
            ))
        }
        function He(t, e) {
            let n = t.getIndex();
            if (null === n) {
                const e = []
                  , r = t.getAttribute("position");
                if (void 0 === r)
                    return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                    t;
                for (let t = 0; t < r.count; t++)
                    e.push(t);
                t.setIndex(e),
                n = t.getIndex()
            }
            const r = n.count - 2
              , i = [];
            if (e === C.z$h)
                for (let t = 1; t <= r; t++)
                    i.push(n.getX(0)),
                    i.push(n.getX(t)),
                    i.push(n.getX(t + 1));
            else
                for (let t = 0; t < r; t++)
                    t % 2 == 0 ? (i.push(n.getX(t)),
                    i.push(n.getX(t + 1)),
                    i.push(n.getX(t + 2))) : (i.push(n.getX(t + 2)),
                    i.push(n.getX(t + 1)),
                    i.push(n.getX(t)));
            i.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const s = t.clone();
            return s.setIndex(i),
            s
        }
    },
    2579: function(t, e, n) {
        n.d(e, {
            a: function() {
                return u
            }
        });
        var r = n(5183)
          , i = n(5092)
          , s = n(1244);
        class a extends s.x {
            constructor(t, e, n, r, i, s, a, o, l, c, u, h) {
                super(null, s, a, o, l, c, r, i, u, h),
                this.image = {
                    width: e,
                    height: n
                },
                this.mipmaps = t,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        a.prototype.isCompressedTexture = !0;
        var o = n(1661);
        class l {
            constructor(t=4) {
                this.pool = t,
                this.queue = [],
                this.workers = [],
                this.workersResolve = [],
                this.workerStatus = 0
            }
            _initWorker(t) {
                if (!this.workers[t]) {
                    const e = this.workerCreator();
                    e.addEventListener("message", this._onMessage.bind(this, t)),
                    this.workers[t] = e
                }
            }
            _getIdleWorker() {
                for (let t = 0; t < this.pool; t++)
                    if (!(this.workerStatus & 1 << t))
                        return t;
                return -1
            }
            _onMessage(t, e) {
                const n = this.workersResolve[t];
                if (n && n(e),
                this.queue.length) {
                    const {resolve: e, msg: n, transfer: r} = this.queue.shift();
                    this.workersResolve[t] = e,
                    this.workers[t].postMessage(n, r)
                } else
                    this.workerStatus ^= 1 << t
            }
            setWorkerCreator(t) {
                this.workerCreator = t
            }
            setWorkerLimit(t) {
                this.pool = t
            }
            postMessage(t, e) {
                return new Promise((n=>{
                    const r = this._getIdleWorker();
                    -1 !== r ? (this._initWorker(r),
                    this.workerStatus |= 1 << r,
                    this.workersResolve[r] = n,
                    this.workers[r].postMessage(t, e)) : this.queue.push({
                        resolve: n,
                        msg: t,
                        transfer: e
                    })
                }
                ))
            }
            dispose() {
                this.workers.forEach((t=>t.terminate())),
                this.workersResolve.length = 0,
                this.workers.length = 0,
                this.queue.length = 0,
                this.workerStatus = 0
            }
        }
        const c = new WeakMap;
        class u extends r.a {
            constructor(t) {
                super(t),
                this.transcoderPath = "",
                this.transcoderBinary = null,
                this.transcoderPending = null,
                this.workerPool = new l,
                this.workerSourceURL = "",
                this.workerConfig = null,
                "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
            }
            setTranscoderPath(t) {
                return this.transcoderPath = t,
                this
            }
            setWorkerLimit(t) {
                return this.workerPool.setWorkerLimit(t),
                this
            }
            detectSupport(t) {
                return this.workerConfig = {
                    astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
                    etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
                    etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
                    dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
                    bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
                    pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                },
                this
            }
            dispose() {
                return this.workerPool.dispose(),
                this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                this
            }
            init() {
                if (!this.transcoderPending) {
                    const t = new i.h(this.manager);
                    t.setPath(this.transcoderPath),
                    t.setWithCredentials(this.withCredentials);
                    const e = t.loadAsync("basis_transcoder.js")
                      , n = new i.h(this.manager);
                    n.setPath(this.transcoderPath),
                    n.setResponseType("arraybuffer"),
                    n.setWithCredentials(this.withCredentials);
                    const r = n.loadAsync("basis_transcoder.wasm");
                    this.transcoderPending = Promise.all([e, r]).then((([t,e])=>{
                        const n = u.BasisWorker.toString()
                          , r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(u.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(u.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(u.BasisFormat), "/* basis_transcoder.js */", t, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([r])),
                        this.transcoderBinary = e,
                        this.workerPool.setWorkerCreator((()=>{
                            const t = new Worker(this.workerSourceURL)
                              , e = this.transcoderBinary.slice(0);
                            return t.postMessage({
                                type: "init",
                                config: this.workerConfig,
                                transcoderBinary: e
                            }, [e]),
                            t
                        }
                        ))
                    }
                    ))
                }
                return this.transcoderPending
            }
            load(t, e, n, r) {
                const s = new i.h(this.manager);
                s.setResponseType("arraybuffer"),
                s.setWithCredentials(this.withCredentials);
                const o = new a;
                return s.load(t, (t=>{
                    if (c.has(t)) {
                        return c.get(t).promise.then(e).catch(r)
                    }
                    this._createTexture([t]).then((function(t) {
                        o.copy(t),
                        o.needsUpdate = !0,
                        e && e(o)
                    }
                    )).catch(r)
                }
                ), n, r),
                o
            }
            createTextureFrom(t) {
                const {mipmaps: e, width: n, height: r, format: i, type: s, error: l, dfdTransferFn: c, dfdFlags: u} = t;
                if ("error" === s)
                    return Promise.reject(l);
                const h = new a(e,n,r,i,o.ywz);
                return h.minFilter = 1 === e.length ? o.wem : o.D1R,
                h.magFilter = o.wem,
                h.generateMipmaps = !1,
                h.needsUpdate = !0,
                h.encoding = 2 === c ? o.knz : o.rnI,
                h.premultiplyAlpha = !!(1 & u),
                h
            }
            _createTexture(t, e={}) {
                const n = e
                  , r = this.init().then((()=>this.workerPool.postMessage({
                    type: "transcode",
                    buffers: t,
                    taskConfig: n
                }, t))).then((t=>this.createTextureFrom(t.data)));
                return c.set(t[0], {
                    promise: r
                }),
                r
            }
            dispose() {
                return URL.revokeObjectURL(this.workerSourceURL),
                this.workerPool.dispose(),
                this
            }
        }
        u.BasisFormat = {
            ETC1S: 0,
            UASTC_4x4: 1
        },
        u.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16
        },
        u.EngineFormat = {
            RGBAFormat: o.wk1,
            RGBA_ASTC_4x4_Format: o.ptH,
            RGBA_BPTC_Format: o.bsb,
            RGBA_ETC2_EAC_Format: o.ekQ,
            RGBA_PVRTC_4BPPV1_Format: o.eaV,
            RGBA_S3TC_DXT5_Format: o.ILR,
            RGB_ETC1_Format: o.fto,
            RGB_ETC2_Format: o.l0P,
            RGB_PVRTC_4BPPV1_Format: o._AM,
            RGB_S3TC_DXT1_Format: o.wuA
        },
        u.BasisWorker = function() {
            let t, e, n;
            const r = _EngineFormat
              , i = _TranscoderFormat
              , s = _BasisFormat;
            self.addEventListener("message", (function(a) {
                const u = a.data;
                switch (u.type) {
                case "init":
                    t = u.config,
                    h = u.transcoderBinary,
                    e = new Promise((t=>{
                        n = {
                            wasmBinary: h,
                            onRuntimeInitialized: t
                        },
                        BASIS(n)
                    }
                    )).then((()=>{
                        n.initializeBasis(),
                        void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                    }
                    ));
                    break;
                case "transcode":
                    e.then((()=>{
                        try {
                            const {width: e, height: a, hasAlpha: h, mipmaps: d, format: f, dfdTransferFn: p, dfdFlags: m} = function(e) {
                                const a = new n.KTX2File(new Uint8Array(e));
                                function u() {
                                    a.close(),
                                    a.delete()
                                }
                                if (!a.isValid())
                                    throw u(),
                                    new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                const h = a.isUASTC() ? s.UASTC_4x4 : s.ETC1S
                                  , d = a.getWidth()
                                  , f = a.getHeight()
                                  , p = a.getLevels()
                                  , m = a.getHasAlpha()
                                  , g = a.getDFDTransferFunc()
                                  , v = a.getDFDFlags()
                                  , {transcoderFormat: _, engineFormat: y} = function(e, n, a, u) {
                                    let h, d;
                                    const f = e === s.ETC1S ? o : l;
                                    for (let r = 0; r < f.length; r++) {
                                        const i = f[r];
                                        if (t[i.if] && (i.basisFormat.includes(e) && (!i.needsPowerOfTwo || c(n) && c(a))))
                                            return h = i.transcoderFormat[u ? 1 : 0],
                                            d = i.engineFormat[u ? 1 : 0],
                                            {
                                                transcoderFormat: h,
                                                engineFormat: d
                                            }
                                    }
                                    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."),
                                    h = i.RGBA32,
                                    d = r.RGBAFormat,
                                    {
                                        transcoderFormat: h,
                                        engineFormat: d
                                    }
                                }(h, d, f, m);
                                if (!d || !f || !p)
                                    throw u(),
                                    new Error("THREE.KTX2Loader:\tInvalid texture");
                                if (!a.startTranscoding())
                                    throw u(),
                                    new Error("THREE.KTX2Loader: .startTranscoding failed");
                                const x = [];
                                for (let t = 0; t < p; t++) {
                                    const e = a.getImageLevelInfo(t, 0, 0)
                                      , n = e.origWidth
                                      , r = e.origHeight
                                      , i = new Uint8Array(a.getImageTranscodedSizeInBytes(t, 0, 0, _));
                                    if (!a.transcodeImage(i, t, 0, 0, _, 0, -1, -1))
                                        throw u(),
                                        new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                    x.push({
                                        data: i,
                                        width: n,
                                        height: r
                                    })
                                }
                                return u(),
                                {
                                    width: d,
                                    height: f,
                                    hasAlpha: m,
                                    mipmaps: x,
                                    format: y,
                                    dfdTransferFn: g,
                                    dfdFlags: v
                                }
                            }(u.buffers[0])
                              , g = [];
                            for (let t = 0; t < d.length; ++t)
                                g.push(d[t].data.buffer);
                            self.postMessage({
                                type: "transcode",
                                id: u.id,
                                width: e,
                                height: a,
                                hasAlpha: h,
                                mipmaps: d,
                                format: f,
                                dfdTransferFn: p,
                                dfdFlags: m
                            }, g)
                        } catch (t) {
                            console.error(t),
                            self.postMessage({
                                type: "error",
                                id: u.id,
                                error: t.message
                            })
                        }
                    }
                    ))
                }
                var h
            }
            ));
            const a = [{
                if: "astcSupported",
                basisFormat: [s.UASTC_4x4],
                transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
                engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1
            }, {
                if: "bptcSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.BC7_M5, i.BC7_M5],
                engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1
            }, {
                if: "dxtSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.BC1, i.BC3],
                engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1
            }, {
                if: "etc2Supported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.ETC1, i.ETC2],
                engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1
            }, {
                if: "etc1Supported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.ETC1, i.ETC1],
                engineFormat: [r.RGB_ETC1_Format, r.RGB_ETC1_Format],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1
            }, {
                if: "pvrtcSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
                engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0
            }]
              , o = a.sort((function(t, e) {
                return t.priorityETC1S - e.priorityETC1S
            }
            ))
              , l = a.sort((function(t, e) {
                return t.priorityUASTC - e.priorityUASTC
            }
            ));
            function c(t) {
                return t <= 2 || 0 == (t & t - 1) && 0 !== t
            }
        }
    },
    8038: function(t, e, n) {
        n.d(e, {
            xC: function() {
                return g
            }
        });
        var r = n(1661)
          , i = n(1138)
          , s = n(4302);
        class a {
            constructor(t=!0) {
                this.autoStart = t,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = o(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const e = o();
                    t = (e - this.oldTime) / 1e3,
                    this.oldTime = e,
                    this.elapsedTime += t
                }
                return t
            }
        }
        function o() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        var l = n(3131)
          , c = n(9046)
          , u = n(140)
          , h = n(1154)
          , d = n(7531)
          , f = n(8304);
        class p extends f.w {
            constructor(t, e) {
                super(),
                this.scene = t,
                this.camera = e,
                this.clear = !0,
                this.needsSwap = !1,
                this.inverse = !1
            }
            render(t, e, n) {
                const r = t.getContext()
                  , i = t.state;
                let s, a;
                i.buffers.color.setMask(!1),
                i.buffers.depth.setMask(!1),
                i.buffers.color.setLocked(!0),
                i.buffers.depth.setLocked(!0),
                this.inverse ? (s = 0,
                a = 1) : (s = 1,
                a = 0),
                i.buffers.stencil.setTest(!0),
                i.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE),
                i.buffers.stencil.setFunc(r.ALWAYS, s, 4294967295),
                i.buffers.stencil.setClear(a),
                i.buffers.stencil.setLocked(!0),
                t.setRenderTarget(n),
                this.clear && t.clear(),
                t.render(this.scene, this.camera),
                t.setRenderTarget(e),
                this.clear && t.clear(),
                t.render(this.scene, this.camera),
                i.buffers.color.setLocked(!1),
                i.buffers.depth.setLocked(!1),
                i.buffers.stencil.setLocked(!1),
                i.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295),
                i.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP),
                i.buffers.stencil.setLocked(!0)
            }
        }
        class m extends f.w {
            constructor() {
                super(),
                this.needsSwap = !1
            }
            render(t) {
                t.state.buffers.stencil.setLocked(!1),
                t.state.buffers.stencil.setTest(!1)
            }
        }
        class g {
            constructor(t, e) {
                if (this.renderer = t,
                void 0 === e) {
                    const n = {
                        minFilter: r.wem,
                        magFilter: r.wem,
                        format: r.wk1
                    }
                      , a = t.getSize(new i.F);
                    this._pixelRatio = t.getPixelRatio(),
                    this._width = a.width,
                    this._height = a.height,
                    (e = new s.d(this._width * this._pixelRatio,this._height * this._pixelRatio,n)).texture.name = "EffectComposer.rt1"
                } else
                    this._pixelRatio = 1,
                    this._width = e.width,
                    this._height = e.height;
                this.renderTarget1 = e,
                this.renderTarget2 = e.clone(),
                this.renderTarget2.texture.name = "EffectComposer.rt2",
                this.writeBuffer = this.renderTarget1,
                this.readBuffer = this.renderTarget2,
                this.renderToScreen = !0,
                this.passes = [],
                void 0 === h.C && console.error("THREE.EffectComposer relies on CopyShader"),
                void 0 === d.T && console.error("THREE.EffectComposer relies on ShaderPass"),
                this.copyPass = new d.T(h.C),
                this.clock = new a
            }
            swapBuffers() {
                const t = this.readBuffer;
                this.readBuffer = this.writeBuffer,
                this.writeBuffer = t
            }
            addPass(t) {
                this.passes.push(t),
                t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            insertPass(t, e) {
                this.passes.splice(e, 0, t),
                t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            removePass(t) {
                const e = this.passes.indexOf(t);
                -1 !== e && this.passes.splice(e, 1)
            }
            isLastEnabledPass(t) {
                for (let e = t + 1; e < this.passes.length; e++)
                    if (this.passes[e].enabled)
                        return !1;
                return !0
            }
            render(t) {
                void 0 === t && (t = this.clock.getDelta());
                const e = this.renderer.getRenderTarget();
                let n = !1;
                for (let e = 0, r = this.passes.length; e < r; e++) {
                    const r = this.passes[e];
                    if (!1 !== r.enabled) {
                        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e),
                        r.render(this.renderer, this.writeBuffer, this.readBuffer, t, n),
                        r.needsSwap) {
                            if (n) {
                                const e = this.renderer.getContext()
                                  , n = this.renderer.state.buffers.stencil;
                                n.setFunc(e.NOTEQUAL, 1, 4294967295),
                                this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t),
                                n.setFunc(e.EQUAL, 1, 4294967295)
                            }
                            this.swapBuffers()
                        }
                        void 0 !== p && (r instanceof p ? n = !0 : r instanceof m && (n = !1))
                    }
                }
                this.renderer.setRenderTarget(e)
            }
            reset(t) {
                if (void 0 === t) {
                    const e = this.renderer.getSize(new i.F);
                    this._pixelRatio = this.renderer.getPixelRatio(),
                    this._width = e.width,
                    this._height = e.height,
                    (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                }
                this.renderTarget1.dispose(),
                this.renderTarget2.dispose(),
                this.renderTarget1 = t,
                this.renderTarget2 = t.clone(),
                this.writeBuffer = this.renderTarget1,
                this.readBuffer = this.renderTarget2
            }
            setSize(t, e) {
                this._width = t,
                this._height = e;
                const n = this._width * this._pixelRatio
                  , r = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, r),
                this.renderTarget2.setSize(n, r);
                for (let t = 0; t < this.passes.length; t++)
                    this.passes[t].setSize(n, r)
            }
            setPixelRatio(t) {
                this._pixelRatio = t,
                this.setSize(this._width, this._height)
            }
        }
        new l.i(-1,1,1,-1,0,1);
        const v = new c.u;
        v.setAttribute("position", new u.a$([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
        v.setAttribute("uv", new u.a$([0, 2, 0, 0, 2, 0],2))
    },
    8304: function(t, e, n) {
        n.d(e, {
            T: function() {
                return u
            },
            w: function() {
                return o
            }
        });
        var r = n(3131)
          , i = n(9046)
          , s = n(140)
          , a = n(6454);
        class o {
            constructor() {
                this.enabled = !0,
                this.needsSwap = !0,
                this.clear = !1,
                this.renderToScreen = !1
            }
            setSize() {}
            render() {
                console.error("THREE.Pass: .render() must be implemented in derived pass.")
            }
        }
        const l = new r.i(-1,1,1,-1,0,1)
          , c = new i.u;
        c.setAttribute("position", new s.a$([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
        c.setAttribute("uv", new s.a$([0, 2, 0, 0, 2, 0],2));
        class u {
            constructor(t) {
                this._mesh = new a.K(c,t)
            }
            dispose() {
                this._mesh.geometry.dispose()
            }
            render(t) {
                t.render(this._mesh, l)
            }
            get material() {
                return this._mesh.material
            }
            set material(t) {
                this._mesh.material = t
            }
        }
    },
    4458: function(t, e, n) {
        n.d(e, {
            C: function() {
                return s
            }
        });
        var r = n(3662)
          , i = n(8304);
        class s extends i.w {
            constructor(t, e, n, i, s) {
                super(),
                this.scene = t,
                this.camera = e,
                this.overrideMaterial = n,
                this.clearColor = i,
                this.clearAlpha = void 0 !== s ? s : 0,
                this.clear = !0,
                this.clearDepth = !1,
                this.needsSwap = !1,
                this._oldClearColor = new r.I
            }
            render(t, e, n) {
                const r = t.autoClear;
                let i, s;
                t.autoClear = !1,
                void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial,
                this.scene.overrideMaterial = this.overrideMaterial),
                this.clearColor && (t.getClearColor(this._oldClearColor),
                i = t.getClearAlpha(),
                t.setClearColor(this.clearColor, this.clearAlpha)),
                this.clearDepth && t.clearDepth(),
                t.setRenderTarget(this.renderToScreen ? null : n),
                this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                t.render(this.scene, this.camera),
                this.clearColor && t.setClearColor(this._oldClearColor, i),
                void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s),
                t.autoClear = r
            }
        }
    },
    7531: function(t, e, n) {
        n.d(e, {
            T: function() {
                return a
            }
        });
        var r = n(876)
          , i = n(6682)
          , s = n(8304);
        class a extends s.w {
            constructor(t, e) {
                super(),
                this.textureID = void 0 !== e ? e : "tDiffuse",
                t instanceof r.j ? (this.uniforms = t.uniforms,
                this.material = t) : t && (this.uniforms = i.rD.clone(t.uniforms),
                this.material = new r.j({
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })),
                this.fsQuad = new s.T(this.material)
            }
            render(t, e, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture),
                this.fsQuad.material = this.material,
                this.renderToScreen ? (t.setRenderTarget(null),
                this.fsQuad.render(t)) : (t.setRenderTarget(e),
                this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                this.fsQuad.render(t))
            }
        }
    },
    6591: function(t, e, n) {
        n.d(e, {
            m: function() {
                return p
            }
        });
        var r = n(1138)
          , i = n(3662)
          , s = n(1661)
          , a = n(4302)
          , o = n(6682)
          , l = n(876)
          , c = n(6881)
          , u = n(6173)
          , h = n(8304)
          , d = n(1154);
        const f = {
            shaderID: "luminosityHighPass",
            uniforms: {
                tDiffuse: {
                    value: null
                },
                luminosityThreshold: {
                    value: 1
                },
                smoothWidth: {
                    value: 1
                },
                defaultColor: {
                    value: new i.I(0)
                },
                defaultOpacity: {
                    value: 0
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"
        };
        class p extends h.w {
            constructor(t, e, n, p) {
                super(),
                this.strength = void 0 !== e ? e : 1,
                this.radius = n,
                this.threshold = p,
                this.resolution = void 0 !== t ? new r.F(t.x,t.y) : new r.F(256,256),
                this.clearColor = new i.I(0,0,0);
                const m = {
                    minFilter: s.wem,
                    magFilter: s.wem,
                    format: s.wk1
                };
                this.renderTargetsHorizontal = [],
                this.renderTargetsVertical = [],
                this.nMips = 5;
                let g = Math.round(this.resolution.x / 2)
                  , v = Math.round(this.resolution.y / 2);
                this.renderTargetBright = new a.d(g,v,m),
                this.renderTargetBright.texture.name = "UnrealBloomPass.bright",
                this.renderTargetBright.texture.generateMipmaps = !1;
                for (let t = 0; t < this.nMips; t++) {
                    const e = new a.d(g,v,m);
                    e.texture.name = "UnrealBloomPass.h" + t,
                    e.texture.generateMipmaps = !1,
                    this.renderTargetsHorizontal.push(e);
                    const n = new a.d(g,v,m);
                    n.texture.name = "UnrealBloomPass.v" + t,
                    n.texture.generateMipmaps = !1,
                    this.renderTargetsVertical.push(n),
                    g = Math.round(g / 2),
                    v = Math.round(v / 2)
                }
                void 0 === f && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
                const _ = f;
                this.highPassUniforms = o.rD.clone(_.uniforms),
                this.highPassUniforms.luminosityThreshold.value = p,
                this.highPassUniforms.smoothWidth.value = .01,
                this.materialHighPassFilter = new l.j({
                    uniforms: this.highPassUniforms,
                    vertexShader: _.vertexShader,
                    fragmentShader: _.fragmentShader,
                    defines: {}
                }),
                this.separableBlurMaterials = [];
                const y = [3, 5, 7, 9, 11];
                g = Math.round(this.resolution.x / 2),
                v = Math.round(this.resolution.y / 2);
                for (let t = 0; t < this.nMips; t++)
                    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(y[t])),
                    this.separableBlurMaterials[t].uniforms.texSize.value = new r.F(g,v),
                    g = Math.round(g / 2),
                    v = Math.round(v / 2);
                this.compositeMaterial = this.getCompositeMaterial(this.nMips),
                this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture,
                this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture,
                this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture,
                this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture,
                this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture,
                this.compositeMaterial.uniforms.bloomStrength.value = e,
                this.compositeMaterial.uniforms.bloomRadius.value = .1,
                this.compositeMaterial.needsUpdate = !0;
                this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2],
                this.bloomTintColors = [new c.P(1,1,1), new c.P(1,1,1), new c.P(1,1,1), new c.P(1,1,1), new c.P(1,1,1)],
                this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors,
                void 0 === d.C && console.error("THREE.UnrealBloomPass relies on CopyShader");
                const x = d.C;
                this.copyUniforms = o.rD.clone(x.uniforms),
                this.copyUniforms.opacity.value = 1,
                this.materialCopy = new l.j({
                    uniforms: this.copyUniforms,
                    vertexShader: x.vertexShader,
                    fragmentShader: x.fragmentShader,
                    blending: s.WMw,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                }),
                this.enabled = !0,
                this.needsSwap = !1,
                this._oldClearColor = new i.I,
                this.oldClearAlpha = 1,
                this.basic = new u.v,
                this.fsQuad = new h.T(null)
            }
            dispose() {
                for (let t = 0; t < this.renderTargetsHorizontal.length; t++)
                    this.renderTargetsHorizontal[t].dispose();
                for (let t = 0; t < this.renderTargetsVertical.length; t++)
                    this.renderTargetsVertical[t].dispose();
                this.renderTargetBright.dispose()
            }
            setSize(t, e) {
                let n = Math.round(t / 2)
                  , i = Math.round(e / 2);
                this.renderTargetBright.setSize(n, i);
                for (let t = 0; t < this.nMips; t++)
                    this.renderTargetsHorizontal[t].setSize(n, i),
                    this.renderTargetsVertical[t].setSize(n, i),
                    this.separableBlurMaterials[t].uniforms.texSize.value = new r.F(n,i),
                    n = Math.round(n / 2),
                    i = Math.round(i / 2)
            }
            render(t, e, n, r, i) {
                t.getClearColor(this._oldClearColor),
                this.oldClearAlpha = t.getClearAlpha();
                const s = t.autoClear;
                t.autoClear = !1,
                t.setClearColor(this.clearColor, 0),
                i && t.state.buffers.stencil.setTest(!1),
                this.renderToScreen && (this.fsQuad.material = this.basic,
                this.basic.map = n.texture,
                t.setRenderTarget(null),
                t.clear(),
                this.fsQuad.render(t)),
                this.highPassUniforms.tDiffuse.value = n.texture,
                this.highPassUniforms.luminosityThreshold.value = this.threshold,
                this.fsQuad.material = this.materialHighPassFilter,
                t.setRenderTarget(this.renderTargetBright),
                t.clear(),
                this.fsQuad.render(t);
                let a = this.renderTargetBright;
                for (let e = 0; e < this.nMips; e++)
                    this.fsQuad.material = this.separableBlurMaterials[e],
                    this.separableBlurMaterials[e].uniforms.colorTexture.value = a.texture,
                    this.separableBlurMaterials[e].uniforms.direction.value = p.BlurDirectionX,
                    t.setRenderTarget(this.renderTargetsHorizontal[e]),
                    t.clear(),
                    this.fsQuad.render(t),
                    this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture,
                    this.separableBlurMaterials[e].uniforms.direction.value = p.BlurDirectionY,
                    t.setRenderTarget(this.renderTargetsVertical[e]),
                    t.clear(),
                    this.fsQuad.render(t),
                    a = this.renderTargetsVertical[e];
                this.fsQuad.material = this.compositeMaterial,
                this.compositeMaterial.uniforms.bloomStrength.value = this.strength,
                this.compositeMaterial.uniforms.bloomRadius.value = this.radius,
                this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors,
                t.setRenderTarget(this.renderTargetsHorizontal[0]),
                t.clear(),
                this.fsQuad.render(t),
                this.fsQuad.material = this.materialCopy,
                this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture,
                i && t.state.buffers.stencil.setTest(!0),
                this.renderToScreen ? (t.setRenderTarget(null),
                this.fsQuad.render(t)) : (t.setRenderTarget(n),
                this.fsQuad.render(t)),
                t.setClearColor(this._oldClearColor, this.oldClearAlpha),
                t.autoClear = s
            }
            getSeperableBlurMaterial(t) {
                return new l.j({
                    defines: {
                        KERNEL_RADIUS: t,
                        SIGMA: t
                    },
                    uniforms: {
                        colorTexture: {
                            value: null
                        },
                        texSize: {
                            value: new r.F(.5,.5)
                        },
                        direction: {
                            value: new r.F(.5,.5)
                        }
                    },
                    vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                    fragmentShader: "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
                })
            }
            getCompositeMaterial(t) {
                return new l.j({
                    defines: {
                        NUM_MIPS: t
                    },
                    uniforms: {
                        blurTexture1: {
                            value: null
                        },
                        blurTexture2: {
                            value: null
                        },
                        blurTexture3: {
                            value: null
                        },
                        blurTexture4: {
                            value: null
                        },
                        blurTexture5: {
                            value: null
                        },
                        dirtTexture: {
                            value: null
                        },
                        bloomStrength: {
                            value: 1
                        },
                        bloomFactors: {
                            value: null
                        },
                        bloomTintColors: {
                            value: null
                        },
                        bloomRadius: {
                            value: 0
                        }
                    },
                    vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                    fragmentShader: "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"
                })
            }
        }
        p.BlurDirectionX = new r.F(1,0),
        p.BlurDirectionY = new r.F(0,1)
    },
    1154: function(t, e, n) {
        n.d(e, {
            C: function() {
                return r
            }
        });
        var r = {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"
        }
    },
    1264: function(t, e, n) {
        n.d(e, {
            E: function() {
                return r
            }
        });
        const r = {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                offset: {
                    value: 1
                },
                darkness: {
                    value: 1
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform float offset;\n\t\tuniform float darkness;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t// Eskil's vignette\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n\t\t\tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n\n\t\t}"
        }
    }
}]);
